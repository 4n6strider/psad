#!/usr/bin/perl -w
#
################################################################################
#
# File: psad
#
# Purpose: psad makes use of iptables logs to detect port scans,
#          probes for backdoors and DDoS tools, and other suspect traffic
#          (many signatures were adapted from the snort intrusion
#          detection system).  Data is provided by kmsgsd which reads
#          firewall messages out of the /var/lib/psad/psadfifo named pipe
#          (syslog is reconfigured to write kern.info messages there
#          which include firewall messages).  For more information read
#          the psad man page or view the documentation provided at:
#          http://www.cipherdyne.org.
#
# Author: Michael Rash (mbr@cipherdyne.org)
#
# Credits: (see the CREDITS file)
#
# Version: 1.2.4
#
# Copyright (C) 1999-2002 Michael Rash (mbr@cipherdyne.org)
#
# License (GNU Public License):
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
#    USA
#
# TODO:
#   - Replace full ascii signature listings in <ip>_signatures with sid
#     numbers and packet counts.
#   - Rework IGNORE_CONNTRACK_BUG_PKTS strategy to maximze signature
#     detection.
#   - More syslog messages from psad, psadwatchd, and kmsgsd.
#   - Put a "psad signature strategy" link in all alert emails.
#   - Module tests for Psad.pm
#   - Extract default behavior into psad.conf.
#   - Remove dependency on DROP tag in iptables messages.
#   - Custom logging line upon auto-blocking an ip.
#   - Add difference notification (via syslog) for changed variables
#     after receiving a HUP signal.
#   - Signature based auto block rules.
#   - Include the ability to specify a network in CIDR notation with
#     --Status output.
#   - Drop root privileges if not running in auto-blocking mode.
#   - Extend install.pl to provide an option to dowload the latest perl
#     modules (Date:Calc, Unix::Syslog, etc.) from CPAN.
#   - Extend passive OS fingerprinting to make use of more types of
#     packets than just tcp/syn packets.
#   - Extend passive OS fingerprinting to include signatures from
#     Xprobe from http://www.sys-security.com.
#   - Add a density calculation for a range of scanned ports, and also
#     add a "verbose" mode that will display which of the scanned ports
#     actually resolve to something in the IANA spec.
#   - Packet grapher mode with annotated scan alerts.
#   - Mysql database support?
#   - Get rid of the psad_signatures file in favor of just parsing the
#     snort rules files directly.
#   - Make use of other logging options available in iptables to detect
#     more tcp signatures.  (E.g. --log-tcp-options, --log-ip-options,
#     --log-tcp-sequence, etc.) for better signature recognition.
#   - Include a verbose message in the body of certain emails that as
#     of psad-1.0.0-pre2 only contain a subject line.
#   - Deal with the possibility that psad could eat lots of memory over
#     time if $ENABLE_PERSISTENCE="Y". This should involve periodically
#     deleting entries in %scan (or maybe the entire hash), but this
#     should be done in a way that allows some scan data to persist.
#   - Ipfilter support on *BSD platforms.
#   - Take into account syslog message summarization; i.e. "last message
#     repeated n times".
#   - Possibly add a daemon to take into account ACK PSH, ACK FIN, RST etc.
#     packets that the client may generate after the ip_conntrack module
#     is reloaded.  Without anticipating such packets psad will interpret
#     them as a belonging to a port scan.  NOTE: This problem is mostly
#     corrected by the conntrack patch to the kernel.  Also, the
#     IGNORE_CONNTRACK_BUG_PKTS variable was added to mitigate this
#     problem.
#   - Improve check_firewall_rules() to check for a state rule (iptables)
#     since having such a rule greatly improves the quality of the data
#     stream provided to psad by kmsgsd since more packet types will be
#     denied without requiring overly complicated firewall rules to detect
#     odd tcp flag combinations.
#   - Handle various logging daemons other than syslog such as msyslog,
#     and metalog (syslog-ng support was added).
#   - perldoc
#
# Default Command Line Arguments:  As of the 1.0.0-pre3 release, psad by
#   by default will have the --signatures and --auto-ips options set even
#   if these options are not specified on the command line, and psad
#   will use the default locations for the signatures and auto_ips files.
#   The default file locations can be changed by manually specifying the
#   locations to these files with the --signatures and --auto-ips options.
#   The signature matching and the auto_ips danger level assignments can
#   be disabled by using the --no-signatures and --no-auto-ips options
#   respectively.  In addition, psad adheres to the following defaults:
#
#       -passive OS fingerprinting            = yes
#       -snort sid signature matching         = yes
#       -write errors to error log            = yes
#       -daemon mode                          = yes
#       -reverse dns lookups                  = yes
#       -validate firewall rules              = yes
#       -whois lookups of scanning ips        = yes
#       -parse netstat output for local ports = yes
#
# Coding Style:  All configuration variables from psad.conf are stored in
#   the %config hash by keys that are in capital letters.  This is
#   the only place in the code where capital letters will be used in
#   variables names.  There are several variables with file-scope, and
#   these variables are clearly commented near the top of each of the
#   psad daemons.  Lines are generally limited to 80 characters for easy
#   reading.
#
# Scan hash key explanation:
#   chain     - Iptables chain under which the scan packets appear in the
#               logs.
#   s_time    - Start time for the first packet seen from src to dst.
#   alerted   - An alert has been sent.
#   pkts      - Number of packets (used for signatures and a packet counter
#               for the current interval.
#   flags     - Keeps track of tcp flags.
#   no_listen - No server running locally on the destination port used in
#               the scan packet.
#   listen    - There is a server running locally on the destination port
#               used in the scan packet.
#   curr_sig  - Current signature.
#   abs_sp    - Absolute starting port.
#   abs_ep    - Absolute ending port.
#   sp        - Starting port.
#   ep        - Ending port.
#
# Sample iptables log messages:
#
#  Sample tcp packet (rejected by iptables... --log-prefix = "DROP ")
#  Mar 11 13:15:52 orthanc kernel: DROP IN=lo OUT= MAC=00:00:00:00:00:00:00:00:
#  00:00:00:00:08:00 SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00
#  TTL=64 ID=0 DF PROTO=TCP SPT=44847 DPT=35 WINDOW=32304 RES=0x00 SYN URGP=0
#
#  Sample icmp packet rejected by iptables INPUT chain:
#  Nov 27 15:45:51 orthanc kernel: DROP IN=eth1 OUT= MAC=00:a0:cc:e2:1f:f2:00:
#  20:78:10:70:e7:08:00 SRC=192.168.10.20 DST=192.168.10.1 LEN=84 TOS=0x00
#  PREC=0x00 TTL=64 ID=0 DF PROTO=ICMP TYPE=8 CODE=0 ID=61055 SEQ=256
#
#  Sample icmp packet logged through FORWARD chain:
#  Aug 20 21:23:32 orthanc kernel: SID365 IN=eth2 OUT=eth1 SRC=192.168.20.25
#  DST=192.168.10.15 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=ICMP TYPE=8
#  CODE=0 ID=19467 SEQ=256
#
#  Occasionally the kernel klogd ring buffer must become full since log
#  entries are sometimes generated by a long port scan like this (note
#  there is no 'DPT' field):
#
#  Mar 16 23:50:25 orthanc kernel: DROP IN=lo OUT= MAC=00:00:00:00:00:00:00:
#  00:00:00:00:00:08:00 SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00
#  TTL=64 ID=0 DF PROTO=TCP SPT=39935 DINDOW=32304 RES=0x00 SYN URGP=0
#
# Note on iptables tcp log messages:
#
#   Iptables reports tcp flags in the following order:
#
#       URG ACK PSH RST SYN FIN
#
# Files specification for /var/log/psad/<srcip> directories:
#
#   psad creates a new directory "/var/log/psad/<srcip>" for each new <srcip>
#   from which a scan is detected.  Under this directory several files are
#   created:
#
#       danger_level          - Overall danger level aggregated for all scans.
#       whois                 - Whois information for <srcip>.
#       email_count           - Total email alerts sent for <srcip>.
#       <destip>_email_alert  - The most recent email alert for <destip>.
#       <destip>_packet_ctr   - Packet counters for <destip>.
#       <destip>_signatures   - Signatures detected against <destip>.
#
#   Note that some of the files above contain the destination address since a
#   single source address may scan several destination addresses.
#
###############################################################################
#
# $Id$
#

### modules used by psad
use lib '/usr/lib/psad';
use Psad;
use IPTables::Parse;
use Net::IPv4Addr 'ipv4_in_network';
use File::Copy;
use File::Path;
use Date::Calc qw(Timezone This_Year Decode_Month);
use Socket;
use POSIX;
use IO::Handle;
use Data::Dumper;
use Getopt::Long 'GetOptions';
use strict;

### ========================== main =================================

### set current the psad version number
my $version = '1.2.4';

### default config file for psad (can be changed with
### --config switch)
my $config_file  = '/etc/psad/psad.conf';

### disable debugging by default
my $debug = 0;

my $chk_ipt_chains = 0;
my $flush_fw       = 0;

### Cache the default table->chain relationships used
### by the auto blocking code for iptables firewalls.
### The nat and mangle PREROUTING chains will be added
### by get_iptables_chains() if they are active.
my %ipt_chains;

### configuration hash
my %config;

### commands hash
my %cmds;

### main psad data structure; contains ips, port ranges,
### protocol info, tcp flags, etc.
my %scan;

### cache scan danger levels
my %scan_dl;

### cache executions of external script (only used if
### ENABLE_EXT_SCRIPT_EXEC is set to 'Y');
my %scan_ext_exec;

### cache passive os fingerprinting information
my %posf;

### cache passive os fingerprinting signature information
my %posf_sigs;

### cache all scan signatures (initialized by default)
my %sigs;

### Cache snort rule messages if --snort-sids switch was
### given.  This is only useful if iptables includes rule
### that log things like "SID123".  "fwsnort"
### (http://www.cipherdyne.org/fwsnort/) will automatically
### build such a ruleset from snort signatures.
my %snort_msgs;

### cache signature info that can be check quickly against
### single hash keys
my %sigs_fast;

### cache signature messages, danger levels, etc.
my %sigs_attr;

### data array used for dshield.org logs
my @dshield_data;

### track the last time we sent an alert to dshield.org
my $last_dshield_alert;

### get the current timezone for dshield (this is calculated
### and re-calculated since the timezone may change).
my $timezone;

### get the current year for dshield
my $year;

### %auto_ips holds all ip addresses that should automatically
### be assigned a danger level (or ignored).  (Only initialized
### if the "-a <auto ips file>" is specified on the command line).
my %auto_ips;

### cache the source ips that we have automatically blocked
### (if ENABLE_AUTO_IDS == 'Y')
my %auto_blocked_ips;

### cache the addresses we have executed whois lookups for
my %whois_cache;

### cache ports the local machine is listening on (periodically
### updated by get_listening_ports()).
my %local_ports;

### cache the ip addresses associated with each interface on the
### local machine.
my %local_ips;

### regex to match an ip address
my $ip_re = '(?:\d{1,3}\.){3}\d{1,3}';

### psad logging hash
my %log_hsh;

### ttl values are decremented depending on the number of hops
### the packet has taken before it hits the firewall.  We will
### assume packets will not jump through more than 20 hops on
### average.
my $max_hops = 20;

### packet counters
my $tcp_ctr  = 0;
my $udp_ctr  = 0;
my $icmp_ctr = 0;

### pid file hash
my %pidfiles;

### initialize and scope some default variables (command
### line args can override some default values)
my $sigs_file        = '';
my $posf_file        = '';
my $autoips_file     = '';
my $snort_rules_dir  = '';
my $srules_type      = '';
my $psad_logfile     = '';
my $cmdline_file     = '';
my $output           = 0;
my $syslog_server    = 0;
my $kill             = 0;
my $restart          = 0;
my $status           = 0;
my $status_ip        = '';
my $status_sort_dl   = 0;
my $status_dl        = 0;
my $benchmark        = 0;
my $b_packets        = 0;
my $usr1             = 0;
my $hup              = 0;
my $usr1_flag        = 0;
my $hup_flag         = 0;
my $ver              = 0;
my $help             = 0;
my $dump_conf        = 0;
my $chk_interval     = 0;
my $log_len          = 23;  ### used in scan_logr()
my $fw_analyze       = 0;
my $rm_data_ctr      = 0;
my $netstat_lkup_ctr = 0;
my $local_ips_lkup_ctr = 0;

### these flags are used to disable several features
### in psad if specified from the command line
my $no_snort_sids = 0;
my $no_signatures = 0;
my $no_auto_ips   = 0;
my $no_posf       = 0;
my $no_daemon     = 0;
my $no_ipt_errors = 0;
my $no_rdns       = 0;
my $no_whois      = 0;
my $no_netstat    = 0;
my $no_fwcheck    = 0;
my $no_kmsgsd     = 0;

### old command line options
my $oldarg_snort_sids;
my $oldarg_autoips;
my $oldarg_errs;
my $oldarg_nerrs;
my $oldarg_nerrs2;
my $oldarg_rdns;
my $oldarg_nrdns;
my $oldarg_whois;
my $oldarg_nwhois;
my $oldarg_netstat;
my $oldarg_nlport;
my $oldarg_fwcheck;
my $oldarg_nfwchk;
my $oldarg_daemon;
my $oldarg_logserv;

### used in --Benchmark test
my $b_time;
my $test_pkt;
my $test_pktend;

### save a copy of the command line arguments
my @args_cp = @ARGV;

### make Getopts case sensitive
Getopt::Long::Configure('no_ignore_case');

&usage(1) unless (GetOptions(
    'signatures=s'      => \$sigs_file,       # Path to psad signatures file.
    'passive-os-sigs=s' => \$posf_file,       # Path to passive os fingerprinting
                                              # signatures.
    'snort-type=s'      => \$srules_type,     # Only process snort rules of
                                              # this type (e.g. "ddos" or
                                              # "backdoor").
    'snort-rdir=s'      => \$snort_rules_dir, # Specify a directory for snort
                                              # rules.
    'auto-ips=s'        => \$autoips_file,    # Path to psad auto ips file for
                                              # auto-setting ip danger level.
    'output'            => \$output,          # Write scanlog messages to STDOUT.
    'debug'             => \$debug,           # Run in debug mode.
    'Dump-conf'         => \$dump_conf,       # Dump config and exit.
    'interval=i'        => \$chk_interval,    # Set $chk_interval from the
                                              # command line.
    'config=s'          => \$config_file,     # Specify configuration file.
    'fw-check'          => \$fw_analyze,      # Analyze the firewall ruleset and
                                              # exit.
    'logfile=s'         => \$psad_logfile,    # The psad logfile.
    'log-server'        => \$syslog_server,   # We are running psad on a syslog
                                              # logging server.
    'Kill'              => \$kill,            # Kill all running psad processes.
                                              # (psadwatchd, psad, kmsgsd)
    'Restart'           => \$restart,         # Restart psad with all options of
                                              # the currently running psad process.
    'Flush'             => \$flush_fw,        # Flush any rules that psad previously
                                              # added via the auto blocking code.
    'Status'            => \$status,          # Display status of any currently
                                              # running psad processes.
    'status-ip=s'       => \$status_ip,       # Display status for a specific ip.
    'status-sort-dl'    => \$status_sort_dl,  # Sort by danger level instead of by
                                              # ip address in --Status output.
    'status-dl=i'       => \$status_dl,       # Display status for scans that have
                                              # reached at least this danger level.
    'Benchmark'         => \$benchmark,       # Run in benchmark mode.
    'packets=i'         => \$b_packets,       # Specify number of packets to use
                                              # in benchmark test.
    'USR1'              => \$usr1,            # Send an existing psad process a
                                              # USR1 signal (useful for debugging).
    'HUP'               => \$hup,             # Send psad processes a HUP signal
                                              # to re-import config.
    'no-snort-sids'     => \$no_snort_sids,   # Disable search for snort SID's
                                              # in iptables messages.
    'no-whois'          => \$no_whois,        # Do not issue whois lookups against
    'no-passiveos'      => \$no_posf,         # Do not attempt to passively
                                              # fingerprint the remote OS.
    'no-signatures'     => \$no_signatures,   # Disable signature processing.
    'no-auto-ips'       => \$no_auto_ips,     # Disable auto danger level
                                              # assignment.
    'no-daemon'         => \$no_daemon,       # Do not run as a daemon.
    'no-fwcheck'        => \$no_fwcheck,      # Do not check firewall rules.
    'no-rdns'           => \$no_rdns,         # Do not issue dns lookups against
                                              # Scanning ip address.
    'no-localport'      => \$no_netstat,      # Do not check to see if the
                                              # firewall is listening on localport
                                              # that has been scanned.
    'no-ipt-errors'     => \$no_ipt_errors,   # Do not write malformed packet.
                                              # messages to error log.
    'no-kmsgsd'         => \$no_kmsgsd,       # Do not start kmsgsd (used for
                                              # debugging).
    'Version'           => \$ver,             # Print the psad version and exit.
    'help'              => \$help,            # Display help.
    ### old args
    'Logging_server'    => \$oldarg_logserv, # old command line arg
#    'Daemon'            => \$oldarg_daemon, # old command line arg
    'firewallcheck'     => \$oldarg_fwcheck, # old command line arg
    'no_fw_check'       => \$oldarg_nfwchk,  # old command line arg
    'snort-sids'        => \$oldarg_snort_sids, # old command line arg
    'reversedns'        => \$oldarg_rdns,    # old command line arg
    'localport'         => \$oldarg_netstat, # old command line arg
    'errors'            => \$oldarg_errs,    # old command line arg
    'no_errors'         => \$oldarg_nerrs,   # old command line arg
    'no-errors'         => \$oldarg_nerrs2,  # old command line arg
    'whois'             => \$oldarg_whois,   # old command line arg
    'no_whois'          => \$oldarg_nwhois,  # old command line arg
    'no_rdns'           => \$oldarg_nrdns,   # old command line arg
    'no_localport'      => \$oldarg_nlport,  # old command line arg
));
&usage(0) if $help;

### Print the version number and exit if -V given on the command line.
if ($ver) {
    print " .. psad v$version, by Michael Rash ",
        "<mbr\@cipherdyne.org>\n";
    exit 0;
}

$status = 1 if ($status_ip and not $status);
$status = 1 if ($status_sort_dl and not $status);
$status = 1 if ($status_dl and not $status);
if ($status_dl and $status_dl > 5) {
    die ' ** The --status-dl must be between 1 and 5.  Exiting.';
}

if ($no_kmsgsd and not $debug) {
    die ' ** The --no-kmsgsd option can only be used with ',
        '--debug.  Exiting.';
}

### check for any old command line arguments
&check_old_cmdargs();

### Everthing after this point must be executed as root.
$< == 0 && $> == 0 or
    die ' ** psad: You must be root (or equivalent ',
        "UID 0 account) to execute psad!  Exiting.\n";

### Import all psad configuration and signatures files
### (psad.conf, psad_posf, psad_signatures, and psad_auto_ips).
&import_configs();

### check to make sure another psad process is not already running.
&Psad::unique_pid($config{'PSAD_PID_FILE'});

### get the ip addresses that are local to this machine
&get_local_ips();

### disable whois lookups if for some reason the whois client that is
### bundled with psad can't be found
unless ($no_whois) {
    unless (defined $cmds{'whois'}
            && -x $cmds{'whois'}) {  ### we couldn't find whois_psad
        warn ' ** Could not locate whois_psad binary.  ',
            "Disabling whois lookups.\n";
        $no_whois = 1;
    }
}

### if psad is running on a syslog server, don't check the firewall
### rules since they may not be local.
&fw_check() unless $no_fwcheck || $syslog_server;

### initialize benchmarking test packets if we are running
### in benchmark mode
if ($benchmark) {
    $test_pkt = 'Feb 15 16:42:58 orthanc kernel: DROP IN=eth0 ' .
        'OUT= MAC=00:a0:cc:28:42:5a:00:03:6c:00:98:54:08:00 ' .
        'SRC=10.0.0.1 DST=10.0.0.2 LEN=48 TOS=0x00 PREC=0x00 ' .
        'TTL=110 ID=13383 DF PROTO=TCP SPT=1389 DPT=';
    $test_pktend = 'WINDOW=16384 RES=0x00 SYN URGP=0';
}

### let the user know where email alerts will be sent
#print STDOUT " .. psad started; email alerts will be sent to:\n",
#    " ----> $config{'EMAIL_ADDRESSES'}\n";

### daemonize psad unless running with --no_daemon or --debug
unless ($no_daemon || $debug || $benchmark) {
    my $pid = fork();
    exit if $pid;
    die " ** $0: Couldn't fork: $!" unless defined $pid;
    POSIX::setsid() or die " ** $0: Can't start a new session: $!";
}

### write the current pid associated with psad to the psad pid file
&Psad::writepid($config{'PSAD_PID_FILE'});

### write the command line args used to start psad to $cmdline_file
&Psad::writecmdline(\@args_cp, $cmdline_file);

### psad _requires_ that kmsgsd is running to receive any data, so let's
### start it here for good measure (as of 0.9.2 it makes use of the pid
### files and unique_pid(), so we don't have to worry about starting a
### duplicate copy).  While we're at it, start psadwatchd as well.
### Note that this is the best place to start the other daemons since we
### just wrote the psad pid to PSAD_PID_FILE above.
unless ($benchmark) {
    system $cmds{'kmsgsd'} unless $no_kmsgsd;
    system $cmds{'psadwatchd'} unless $debug;
}

### Check to see if psad automatically blocked some ips from
### a previous run.  This feature is most useful for preserving
### auto-block rules ips after a reboot or after restarting
### psad.
&renew_auto_blocked_ips() if $config{'ENABLE_AUTO_IDS'} eq 'Y';

### archive old firewall and scan data
&archive_data() unless $benchmark;

### Install signal handlers for debugging %scan with Data::Dumper,
### and for reaping zombie whois processes.  Only install signal
### handlers if we are not running in benchmark mode
unless ($benchmark) {
    $SIG{'__WARN__'} = \&Psad::warn_handler;
    $SIG{'__DIE__'}  = \&Psad::die_handler;
    $SIG{'CHLD'}     = \&REAPER;
    $SIG{'USR1'}     = \&usr1_handler;
    $SIG{'HUP'}      = \&hup_handler;
}

### zero out the packet counter file (the counters
### are all zero at this point anyway).
&write_global_packet_counters();

if ($benchmark) {
    print scalar localtime(), " .. Entering benchmark mode.\n";
    $no_rdns  = 1;  ### turn off network related functions
    $no_whois = 1;
    if ($b_packets) {
        print scalar localtime(),
            " .. Executing a $b_packets packet test.\n";
    } else {
        print scalar localtime(), ' .. The --packets command line ',
            "option was not specified.\n";
        print scalar localtime(),
            " .. Defaulting to a 10,000 packet test.\n";
        $b_packets = 10000;
    }
}

### stop any old running diskmond process (psad now deals with
### disk space directly).
&stop_legacy_diskmond();

if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
    $last_dshield_alert = time() unless $last_dshield_alert;
}

### Initialize current time for disk space checking.
my $last_disk_check = time();

### Get an open filehandle for the main firewall data file FW_DATA_FILE.
### All firewall drop/deny/reject log messages are written to FW_DATA_FILE
### by kmsgsd.
open FWDATA, $config{'FW_DATA_FILE'} or die ' ** Could not open ',
    "$config{'FW_DATA_FILE'}: $!" unless $benchmark;

###=========================================================###
######                    MAIN LOOP                      ######
###=========================================================###
for (;;) {

    ### scope and clear the firewall data array
    my @fw_packets = ();

    if ($hup_flag) {
        $hup_flag = 0;  ### clear the HUP flag

        &Psad::psyslog('psad', '.. received HUP signal, ' .
            're-importing psad.conf');

        my $orig_fwdata = $config{'FW_DATA_FILE'};
        ### Re-import all used config files (psad.conf, psad_auto_ips,
        ### psad_posf, psad_signatures) if we received a HUP signal.
        &import_configs();

        if ($orig_fwdata ne $config{'FW_DATA_FILE'}) {
            close FWDATA;
            ### zero out the new fwdata file just in case (the path
            ### has changed).
            open FWDATA, "> $config{'FW_DATA_FILE'}" or die $!;
            close FWDATA;

            ### re-open the fwdata file
            open FWDATA, $config{'FW_DATA_FILE'} or die
                " ** Could not open $config{'FW_DATA_FILE'}: $!"
        }
    }

    ### See if we need to print out the %scan datastructure
    ### (we received a USR1 signal)
    if ($usr1_flag) {
        $usr1_flag = 0;  ### clear the USR1 flag

        &Psad::psyslog('psad', '.. received USR1 signal, printing scan hashes ' .
            "to $config{'PSAD_DIR'}/scan_hash.$$");
        &print_scan();
    }

    ### Get any new packets have been written to
    ### FW_DATA_FILE by kmsgsd for psad analysis.
    if ($benchmark) {
        $b_time = time();
        print scalar localtime(), " .. Creating packet array.\n";
        my $dp = 1000;
        for (my $i=0; $i <= $b_packets; $i++) {
            push @fw_packets, "$test_pkt DPT=$dp $test_pktend";
            $dp++ if $dp < 50000;
        }
    } else {
        @fw_packets = <FWDATA>;
    }
    if (@fw_packets) {
        print scalar localtime(), " .. check_scan()\n" if $benchmark;

        if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
            ### calculate the timezone offset
            $timezone = sprintf("%.2d", (Timezone())[3]) . ':00';
            $year     = This_Year();
        }

        unless ($no_netstat) {
            ### we don't expect the list of ports the machine is listening
            ### on to change very often.
            if ($netstat_lkup_ctr == 10) {
                &get_listening_ports();
                $netstat_lkup_ctr = 0;
            }
            $netstat_lkup_ctr++;
        }
        ### the local machine ip addresses could change (dhcp, etc.)
        ### but not that often.
        if ($local_ips_lkup_ctr == 30) {
            &get_local_ips();
            $local_ips_lkup_ctr = 0;
        }
        $local_ips_lkup_ctr++;

        ### Extract data and summarize scan packets, assign danger level,
        ### send email/syslog alerts.
        &check_scan(\@fw_packets);

        ### Write the number of tcp/udp/icmp packets out
        ### to the global packet counters file
        &write_global_packet_counters();
    }

    ### Timeout any auto-blocked ips that are past due (need to
    ### check the timeouts against existing ips in the scan hash
    ### even if new packets are not found).
    if ($config{'ENABLE_AUTO_IDS'} eq 'Y'
            && $config{'AUTO_BLOCK_TIMEOUT'} > 0) {
        &timeout_auto_blocked_ips();
    }

    ### Send logs to dshield in dshield format
    if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
        &dshield_email_log();
    }

    ### Allow disk space utilization checks to be disabled by
    ### setting DISK_MAX_PERCENTAGE = 0.
    if ($config{'DISK_MAX_PERCENTAGE'} > 0 and (time() - $last_disk_check)
            > $config{'DISK_CHECK_INTERVAL'}) {
        ### See how we are doing on disk space, and remove data
        ### if necessary.
        if (&disk_space_exceeded()) {
            close FWDATA;

            ### truncate fwdata file
            open FWDATA, "> $config{'FW_DATA_FILE'}" or die $!;
            close FWDATA;

            ### re-open the fwdata file
            open FWDATA, $config{'FW_DATA_FILE'} or die
                " ** Could not open $config{'FW_DATA_FILE'}: $!"
        }
        $last_disk_check = time();
    }

    ### Print the number of new packets we saw in FW_DATA_FILE if we are
    ### running in debug mode
    if ($debug) {
        print "MAIN: number of new packets: $#fw_packets\n";
    }

    if ($benchmark) {
        print scalar localtime(), " .. Packet creation and processing time: ",
            time() - $b_time, " sec.\n";
        print scalar localtime(), " .. Exiting benchmark mode.\n";
        exit 0;
    }

    ### clearerr() on the FWDATA filehandle to be ready for new packets
    FWDATA->clearerr() unless $benchmark;

    ### sleep for the check interval number of seconds
    sleep $config{'PSAD_CHECK_INTERVAL'};
}
exit 0;
###=========================================================###
######                    END MAIN                       ######
###=========================================================###

#=================== BEGIN SUBROUTINES ========================

### Keeps track of scanning ip's, increments packet counters,
### keep track of tcp flags for each scan (iptables only),
### test for snort sid values in iptables packets (if fwsnort
### is being used).
sub check_scan() {
    my $fw_packets_aref = shift;

    my %current_scan = ();;
    my @err_pkts = ();

    PKT: for my $pkt (@$fw_packets_aref) {
        my $src;
        my $dst;
        my $len;
        my $tos;
        my $ttl;
        my $id;
        my $proto;
        my $sp;
        my $dp;
        my $win;
        my $type;
        my $code;
        my $seq;
        my $chain = '';
        my $intf = '';
        my $flags;
        my $sid = 0;
        my $dshield_str = '';

        print STDOUT $pkt, "\n" if $debug;

        unless ($no_snort_sids) {
            if ($pkt =~ /$config{'SNORT_SID_STR'}(\d+)\s+IN/) {
                $sid = $1;
            }
        }

        ### get the in/out interface and iptables chain
        if ($pkt =~ /IN=(\S+)\s+OUT=\s/) {
            $intf = $1;
            $chain = 'input';
        } elsif ($pkt =~ /IN=(\S+)\s+OUT=\S/) {
            $intf = $1;
            $chain = 'forward';
        } elsif ($pkt =~ /IN=\s+OUT=(\S+)/) {
            $intf = $1;
            $chain = 'output';
        }

        unless ($intf and $chain) {
            print " ** err packet: could not determine interface and chain.\n"
                if $debug;
            push @err_pkts, $pkt;
            next PKT;
        }

        ### May 18 22:21:26 orthanc kernel: DROP IN=eth2 OUT=
        ### MAC=00:60:1d:23:d0:01:00:60:1d:23:d3:0e:08:00 SRC=192.168.20.25
        ### DST=192.168.20.1 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=47300 DF
        ### PROTO=TCP SPT=34111 DPT=6345 WINDOW=5840 RES=0x00 SYN URGP=0
        if ($pkt =~ /SRC=(\S+)\s+DST=(\S+)\s+LEN=(\d+)\s+TOS=(\S+)
                    \s*.*\s+TTL=(\d+)\s+ID=(\d+)\s*.*\s+PROTO=TCP\s+
                    SPT=(\d+)\s+DPT=(\d+)\s+WINDOW=(\d+)\s+
                    RES=\S+\s*(.*)\s+URGP=/x) {
            ($src, $dst, $len, $tos, $ttl, $id, $sp, $dp, $win, $flags) =
                ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
            $proto = 'tcp';
            $flags = 'NULL' unless $flags;  ### default to NULL
            if (!$sid && $config{'IGNORE_CONNTRACK_BUG_PKTS'} eq 'Y' &&
                    ($flags =~ /ACK/ || $flags =~ /RST/)) {
#                    $dp > 1024 && ($flags =~ /ACK/ ||
                ### XXX ignore TCP packets that have the ACK or RST
                ### bits set (unless we matched a snort sid) since
                ### _usually_ we see these packets as a result of the
                ### iptables connection tracking bug.  Also, note that
                ### no signatures make use of the RST flag and very
                ### few that use the ACK flag (need to add code back
                ### in for these signatures).
                print " ** err packet: matched ACK or RST flag.\n" if $debug;
                next PKT;
            }
            ### per page 595 of the Camel book, "if /blah1|blah2/"
            ### can be slower than "if /blah1/ || /blah2/
            unless ($flags !~ /WIN/ &&
                    $flags =~ /ACK/ ||
                    $flags =~ /SYN/ ||
                    $flags =~ /RST/ ||
                    $flags =~ /URG/ ||
                    $flags =~ /PSH/ ||
                    $flags =~ /FIN/ ||
                    $flags eq 'NULL') {
                print " ** err packet: bad tcp flags.\n" if $debug;
                push @err_pkts, $pkt;
                next PKT;
            }
            if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
                my $dflags = $flags;
                $dflags =~ s/\s/,/g;
                $dshield_str = "$src\t$sp\t$dst\t$dp\t$proto\t$dflags";
            }
            $tcp_ctr++;
        ### May 18 22:21:26 orthanc kernel: DROP IN=eth2 OUT=
        ### MAC=00:60:1d:23:d0:01:00:60:1d:23:d3:0e:08:00
        ### SRC=192.168.20.25 DST=192.168.20.1 LEN=28 TOS=0x00 PREC=0x00
        ### TTL=40 ID=47523 PROTO=UDP SPT=57339 DPT=305 LEN=8
        } elsif ($pkt =~ /SRC=(\S+)\s+DST=(\S+)\s+LEN=(\d+)\s+TOS=(\S+)
                          \s.*TTL=(\d+)\s+ID=(\d+)\s*.*\s+PROTO=UDP\s+
                          SPT=(\d+)\s+DPT=(\d+)/x) {
            ($src, $dst, $len, $tos, $ttl, $id, $sp, $dp) =
                ($1,$2,$3,$4,$5,$6,$7,$8);
            $proto = 'udp';
            if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
                $dshield_str = "$src\t$sp\t$dst\t$dp\t$proto";
            }
            $udp_ctr++;
        } elsif ($pkt =~ /SRC=(\S+)\s+DST=(\S+)\s+LEN=(\d+).*
                          TTL=(\d+).*PROTO=ICMP\s+TYPE=(\d+)\s+
                          CODE=(\d+)\s+ID=(\d+)\s+SEQ=(\d+)/x) {
            ($src, $dst, $len, $ttl, $type, $code, $id, $seq) =
                ($1,$2,$3,$4,$5,$6,$7,$8);
            $proto = 'icmp';
            $icmp_ctr++;
            if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
                $dshield_str = "$src\t$type\t$dst\t$code\t$proto";
            }
        } else {
            ### Sometimes the iptables log entry gets messed up due to
            ### buffering issues so we write it to the error log.
            print " ** err packet: no regex match.\n" if $debug;
            push @err_pkts, $pkt;
            next PKT;
        }

        ### If we made it here then we correctly matched packets
        ### that the firewall logged.
        print " .. valid packet: $src -> $dst $proto\n" if $debug;

        ### initialize the danger level to 0 if it is not already defined
        ### (note the same source address might have already scanned a
        ### different destination ip, so the danger level represents the
        ### aggregate danger level).
        unless (defined $scan_dl{$src}) {
            $scan_dl{$src} = 0;
            $scan{$src}{$dst}{'alerted'} = 0
                if ($config{'ALERT_ALL'} eq 'N');
        }

        if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
            if ($pkt =~ /^\s*(\w+)\s+(\d+)\s+(\S+)/) {
                my $month   = Decode_Month($1);
                my $day     = sprintf("%.2d", $2);
                my $time_24 = $3;
                push @dshield_data, "$year-$month-$day $time_24 " .
                    "$timezone\t$config{'DSHIELD_USER_ID'}\t1" .
                    "\t$dshield_str\n";
            }
        }

        ### see if we need to timeout any old scans
        if ($config{'ENABLE_PERSISTENCE'} eq 'N') {
            if (defined $scan{$src}{$dst}{'s_time'}) {
                if ((time() - $scan{$src}{$dst}{'s_time'})
                        >= $config{'SCAN_TIMEOUT'}) {
                    delete $scan{$src}{$dst};
                }
            }
        }

        if ($config{'ENABLE_AUTO_IDS'} eq 'Y') {
            if (not defined $auto_blocked_ips{$src}) {
                ### $auto_block_ips{$src} may be zero if $src has been
                ### timed out
                $auto_blocked_ips{$src} = 0;
            } elsif ((time() - $auto_blocked_ips{$src})
                    > $config{'AUTO_BLOCK_TIMEOUT'}) {
                ### the timeout for $src has expired, but we have seen
                ### new packets from the ip so setup to renew the
                ### block
                $auto_blocked_ips{$src} = 0;
            }
        }

        ### record the absolute starting time of the scan
        unless (defined $scan{$src}{$dst}{'s_time'}) {
            $scan{$src}{$dst}{'s_time'} = time();
        }

        ### increment hash values
        $scan{$src}{$dst}{'absnum'}++;
        $scan{$src}{$dst}{'chain'}{$chain}{$intf}{$proto}++;
        $current_scan{$src}{$dst}{$proto}{'pkts'}++;
        $current_scan{$src}{$dst}{$proto}{'flags'}{$flags}++
            if $flags;

        unless ($proto eq 'icmp') {
            ### initialize the start and end port for the scanned port range
            if (not defined $current_scan{$src}{$dst}{$proto}{'sp'}) {
                ### make sure the initial start port is not too low
                $current_scan{$src}{$dst}{$proto}{'sp'} = 65535;
                ### make sure the initial end port is not too high
                $current_scan{$src}{$dst}{$proto}{'ep'} = 0;
            }
            if (not defined $scan{$src}{$dst}{$proto}{'abs_sp'}) {
                ### This is the absolute starting port since the
                ### first packet was detected.  Make sure the initial
                ### start port is not too low
                $scan{$src}{$dst}{$proto}{'abs_sp'} = 65535;
                ### make sure the initial end port is not too high
                $scan{$src}{$dst}{$proto}{'abs_ep'} = 0;
            }

            ### see if the destination port lies outside our current range
            ### and change if needed
            ($current_scan{$src}{$dst}{$proto}{'sp'},
                    $current_scan{$src}{$dst}{$proto}{'ep'}) =
                &check_range($dp,
                    $current_scan{$src}{$dst}{$proto}{'sp'},
                    $current_scan{$src}{$dst}{$proto}{'ep'});
            ($scan{$src}{$dst}{$proto}{'abs_sp'},
                    $scan{$src}{$dst}{$proto}{'abs_ep'}) =
                &check_range($dp,
                    $scan{$src}{$dst}{$proto}{'abs_sp'},
                    $scan{$src}{$dst}{$proto}{'abs_ep'});
        }

        print STDOUT Dumper $scan{$src}{$dst} if $debug;

        ### attempt to passively guess the remote operating
        ### system based on the ttl, id, len, window, and tos
        ### fields in tcp syn packets (this technique is based
        ### on the paper "Passive OS Fingerprinting: Details
        ### and Techniques" by Toby Miller).
        unless ($no_posf) {
            &posf($src, $len, $tos, $ttl, $id, $win)
                if ($proto eq 'tcp' && $flags =~ /SYN/);
        }

        if ($sid and ! $no_snort_sids) {
            ### found a snort sid in the packet log message
            &add_snort_sid($src, $dst, $chain, $proto, $sid);
        } else {
            ### attempt to match any tcp/udp/icmp signatures in the
            ### %sigs_fast hash
            &match_fastsigs($src, $dst, $chain, $sp, $dp, $proto,
                $flags, $len, $ttl);

            ### attempt to match any tcp/udp/icmp signatures in the
            ### main signatures hash
            &match_sigs($src, $dst, $chain, $sp, $dp, $proto,
                $flags, $len, $ttl, $type, $code, $id, $seq);
        }
    }

    ### write bogus packets to the error log.
    &collect_errors(\@err_pkts) unless $no_ipt_errors;

    ### Assign a danger level to the scan
    &assign_danger_level(\%current_scan);

    ### Log and send email and syslog alerts
    &scan_logr(\%current_scan);

    ### Don't manage the firewall or tcpwrapper rules if
    ### psad is running on a syslog server
    if ($config{'ENABLE_AUTO_IDS'} eq 'Y' and
            ! $syslog_server) {
        &auto_psad_response(\%current_scan);
    }
    return;
}

sub match_fastsigs() {
    my ($src, $dst, $chain, $sp, $dp, $proto,
        $flags, $len, $ttl) = @_;
    print "match_fastsigs() call\n" if $debug;
    if (defined $sigs_fast{$proto}{$dp}{$sp}{$flags}) {
        for my $sig_id (keys
                %{$sigs_fast{$proto}{$dp}{$sp}{$flags}}) {
            print "match_fastsigs(): matched: $dp,$sp,$flags, ",
                "sig_id: $sig_id\n" if $debug;
            unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                $scan{$src}{$dst}{'alerted'} = 0
                    if ($config{'ALERT_ALL'} eq 'N');
            }
            $scan{$src}{$dst}{$proto}{'curr_sig'}
                {$sig_id}{$chain}{'dp'}{$dp}++;
            if ($proto eq 'tcp') {
                $scan{$src}{$dst}{$proto}{'curr_sig'}
                    {$sig_id}{$chain}{'flags'}{$dp} = $flags;
            }
        }
    }
    if (defined $sigs_fast{$proto}{$dp}{'any_sp'}{$flags}) {
        for my $sig_id (keys
                %{$sigs_fast{$proto}{$dp}{'any_sp'}{$flags}}) {
            print "matched $dp,any_sp,$flags, ",
                "sig_id: $sig_id\n" if $debug;
            unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                $scan{$src}{$dst}{'alerted'} = 0
                    if ($config{'ALERT_ALL'} eq 'N');
            }
            $scan{$src}{$dst}{$proto}{'curr_sig'}
                {$sig_id}{$chain}{'dp'}{$dp}++;
            if ($proto eq 'tcp') {
                $scan{$src}{$dst}{$proto}{'curr_sig'}
                    {$sig_id}{$chain}{'flags'}{$dp} = $flags;
            }
        }
    }
    if (defined $sigs_fast{$proto}{'any_dp'}{$sp}{$flags}) {
        for my $sig_id (keys
                %{$sigs_fast{$proto}{'any_dp'}{$sp}{$flags}}) {
            print "matched any_dp,$sp,$flags, ",
                "sig_id: $sig_id\n" if $debug;
            unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                $scan{$src}{$dst}{'alerted'} = 0
                    if ($config{'ALERT_ALL'} eq 'N');
            }
            $scan{$src}{$dst}{$proto}{'curr_sig'}
                {$sig_id}{$chain}{'dp'}{$dp}++;
            if ($proto eq 'tcp') {
                $scan{$src}{$dst}{$proto}{'curr_sig'}
                    {$sig_id}{$chain}{'flags'}{$dp} = $flags;
            }
        }
    }
    if (defined $sigs_fast{$proto}{'any_dp'}{'any_sp'}{$flags}) {
        for my $sig_id (keys
                %{$sigs_fast{$proto}{'any_dp'}{'any_sp'}{$flags}}) {
            print "matched any_dp,any_sp,$flags, ",
                "sig_id: $sig_id\n" if $debug;
            unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                $scan{$src}{$dst}{'alerted'} = 0
                    if ($config{'ALERT_ALL'} eq 'N');
            }
            $scan{$src}{$dst}{$proto}{'curr_sig'}
                {$sig_id}{$chain}{'dp'}{$dp}++;
            if ($proto eq 'tcp') {
                $scan{$src}{$dst}{$proto}{'curr_sig'}
                    {$sig_id}{$chain}{'flags'}{$dp} = $flags;
            }
        }
    }
    return;
}

sub match_sigs() {
    my ($src, $dst, $chain, $sp, $dp, $proto,
        $flags, $len, $ttl, $type, $code, $id, $seq) = @_;
    print "match_sigs() call\n" if $debug;
    for my $sig_id (keys %{$sigs{$proto}}) {
        ### need to iterate through all signatures
        ### since a packet may match several
        if ($proto eq 'tcp') {
            if ($flags eq $sigs{'tcp'}{$sig_id}{'flags'}
                    && &check_port_range($sig_id, $sp,
                $dp, $proto)) {  ### tripped a tcp signature
                ### future
#               && &check_misc_fields($sig_id, $proto, $len, $ttl)) {
                print "main sigs matched $dp,$sp,$flags, ",
                    "sig_id: $sig_id\n" if $debug;
                unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'alerted'} = 0
                        if ($config{'ALERT_ALL'} eq 'N');
                }
                $scan{$src}{$dst}{$proto}{'curr_sig'}
                    {$sig_id}{$chain}{'dp'}{$dp}++;
                $scan{$src}{$dst}{$proto}{'curr_sig'}
                    {$sig_id}{$chain}{'flags'}{$dp} = $flags;
            }
        } elsif ($proto eq 'udp') {
            if (&check_port_range($sig_id, $sp, $dp, $proto)) {
#               && &check_misc_fields($sig_id, $proto, $len, $ttl)) {
                ### tripped a udp signature
                unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'alerted'} = 0
                        if ($config{'ALERT_ALL'} eq 'N');
                }
                $scan{$src}{$dst}{$proto}{'curr_sig'}
                    {$sig_id}{$chain}{'dp'}{$dp}++;
            }
        } elsif ($proto eq 'icmp') {
            if (&check_icmp_sigs($sig_id, $ttl, $type, $code, $id, $seq)) {
                unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'alerted'} = 0
                        if ($config{'ALERT_ALL'} eq 'N');
                }
                $scan{$src}{$dst}{'icmp'}{'curr_sig'}
                    {$sig_id}{$chain}{'pkts'}++;
            }
        }
    }
    return;
}

sub posf() {
    my ($src, $len, $tos, $ttl, $id, $win) = @_;
    print STDOUT " .. posf():  $src  LEN: $len, TOS: $tos, TTL: $ttl, ",
        "ID: $id, WIN: $win\n" if $debug;
    return if defined $posf{$src}{'guess'};  ### we already guessed the OS
    $posf{$src}{'len'}{$len}++;
    $posf{$src}{'tos'}{$tos}++;
    $posf{$src}{'ttl'}{$ttl}++;
    push @{$posf{$src}{'id'}}, $id;  ### need to maintain ordering
    $posf{$src}{'win'}{$win}++;
    $posf{$src}{'ctr'}++;

    my $id_incr_rv = -1;
    my $id_str = 'RANDOM';
    my $min_ttl;
    my $max_ttl;
    for my $os (keys %posf_sigs) {
        if ($posf{$src}{'ctr'} >= $posf_sigs{$os}{'numpkts'}
                && $id_incr_rv < 0) {
            $id_incr_rv = &id_incr(\@{$posf{$src}{'id'}});
            $id_str = 'SMALLINCR' if $id_incr_rv;
            ($min_ttl, $max_ttl) = &ttl_range($posf{$src}{'ttl'});
        }
        if ($posf{$src}{'ctr'} >= $posf_sigs{$os}{'numpkts'}
                && defined $posf{$src}{'win'}{$posf_sigs{$os}{'win'}}
                && defined $posf{$src}{'tos'}{$posf_sigs{$os}{'tos'}}
                && defined $posf{$src}{'len'}{$posf_sigs{$os}{'len'}}
                && ($min_ttl > ($posf_sigs{$os}{'ttl'}-$max_hops))
                && ($max_ttl <= $posf_sigs{$os}{'ttl'})
                && $id_str eq $posf_sigs{$os}{'id'}) {
            $posf{$src}{'guess'} = $os;
        }
    }
    return;
}

sub id_incr() {
    my $aref = shift;
    my $rv = 1;  ### 1 => small increments, 2 => random
    for (my $i=0; $i<$#$aref; $i++) {
        $rv = 0 unless ($aref->[$i] < $aref->[$i+1]
            && ($aref->[$i+1] - $aref->[$i]) < 1000);
    }
    return $rv;
}

sub ttl_range() {
    my $href = shift;
    my $min_ttl = 256;
    my $max_ttl = 0;
    for my $ttl (keys %$href) {
        $min_ttl = $ttl if $ttl < $min_ttl;
        $max_ttl = $ttl if $ttl > $max_ttl;
    }
    return $min_ttl, $max_ttl;
}

sub add_snort_sid() {
    my ($src, $dst, $chain, $proto, $sid) = @_;
    if (defined $snort_msgs{$sid}) {
        unless ($scan_dl{$src} >= 2) {
            ### FIXME: for now hardcode snort sid matches at
            ### a danger level of two
            $scan_dl{$src} = 2;
            $scan{$src}{$dst}{'alerted'} = 0
                if ($config{'ALERT_ALL'} eq 'N');
        }
        $scan{$src}{$dst}{$proto}{'snort_sid'}{$sid}{$chain}++;
    }
    return;
}

sub dshield_email_log() {
    ### dshield alert interval is in hours.  Check to see if there are more
    ### than 10,000 lines of log data (and if the last alert was sent more than
    ### two hours later than the previous alert), and if yes send the alert
    ### email.
    if (@dshield_data && ((time() - $last_dshield_alert)
            >= 3600*$config{'DSHIELD_ALERT_INTERVAL'})
            || (($#dshield_data > 10000)
            && ((time() - $last_dshield_alert) >= 2*3600))) {
        my $subject = "FORMAT DSHIELD USERID $config{'DSHIELD_USER_ID'} " .
            "TZ $timezone psad Version 1.2";
        if ($config{'DSHIELD_USER_EMAIL'} eq 'NONE') {
            open MAIL, qq(| $cmds{'mail'} -s "$subject" ) .
                $config{'DSHIELD_ALERT_EMAIL'} or die ' ** Could not send ',
                'dshield alert email.';
            print MAIL for @dshield_data;
            close MAIL;
        } else {
            open MAIL, "| $cmds{'sendmail'} -oi -t" or die ' ** Could not ',
                'send dshield alert email.';
            print MAIL "From: $config{'DSHIELD_USER_EMAIL'}\n",
                "To: $config{'DSHIELD_ALERT_EMAIL'}\n",
                "Subject: $subject\n";
            print MAIL for @dshield_data;
            close MAIL;
        }

        &Psad::psyslog('psad', ".. sent $#dshield_data lines of log data to " .
            $config{'DSHIELD_ALERT_EMAIL'});

        ### store the current time
        $last_dshield_alert = time();

        ### clear the dshield data array so we don't re-send
        ### any old data.
        @dshield_data = ();
    }
    return;
}

sub chk_local_port() {
    my ($src, $dst, $proto, $dp, $flags, $sig_id) = @_;
    ### check to see if the scan destination ip is directed
    ### at the firewall.  If yes, then check to see if a
    ### server is listening on the DSTPORT by parsing
    ### netstat output.  If not, psad would have to connect
    ### to the destination port on the remote machine, but
    ### of course it should not do this so it is not
    ### implemented. :)
    if (defined $local_ips{$dst}) {
        if (defined $local_ports{$proto}{$dp}) {
            $scan{$src}{$dst}{$proto}{'curr_sig'}
            {$sig_id}{'listen'}{$dp}{'pkts'}++;
            if ($flags) {
                $scan{$src}{$dst}{$proto}{'curr_sig'}
                {$sig_id}{'listen'}{$dp}{'flags'}
                    = $flags;
            }
        } else {
            $scan{$src}{$dst}{$proto}{'curr_sig'}
            {$sig_id}{'no_listen'}{$dp}{'pkts'}++;
            if ($flags) {
                $scan{$src}{$dst}{$proto}{'curr_sig'}
                {$sig_id}{'no_listen'}{$dp}{'flags'}
                    = $flags;
            }
        }
    }
    return;
}

sub check_port_range() {
    my ($sig_id, $sp, $dp, $proto) = @_;
    ### check dst port first
    if (defined $sigs{$proto}{$sig_id}{'dp'}{'uniq_or_any'}) {
        unless ($sigs{$proto}{$sig_id}{'dp'}{'uniq_or_any'} eq 'any') {
            if ($dp != $sigs{$proto}{$sig_id}{'dp'}{'uniq_or_any'}) {
                return 0;
            }
        }
    }
    if (defined $sigs{$proto}{$sig_id}{'dp'}{'start'}) {
        my $start = $sigs{$proto}{$sig_id}{'dp'}{'start'};
        my $end = $sigs{$proto}{$sig_id}{'dp'}{'end'};
        return 0 if ($dp < $start || $dp > $end);
    }
    if (defined $sigs{$proto}{$sig_id}{'dp'}{'not'}) {
        return 0 if ($dp == $sigs{$proto}{$sig_id}{'dp'}{'not'});
    }
    if (defined $sigs{$proto}{$sig_id}{'dp'}{'negstart'}) {
        my $start = $sigs{$proto}{$sig_id}{'dp'}{'negstart'};
        my $end = $sigs{$proto}{$sig_id}{'dp'}{'negend'};
        return 0 if ($dp > $start || $dp < $end);
    }

    ### check src port
    if (defined $sigs{$proto}{$sig_id}{'sp'}{'uniq_or_any'}) {
        unless ($sigs{$proto}{$sig_id}{'sp'}{'uniq_or_any'} eq 'any') {
            if ($dp != $sigs{$proto}{$sig_id}{'sp'}{'uniq_or_any'}) {
                return 0;
            }
        }
    }
    if (defined $sigs{$proto}{$sig_id}{'sp'}{'start'}) {
        my $start = $sigs{$proto}{$sig_id}{'sp'}{'start'};
        my $end = $sigs{$proto}{$sig_id}{'sp'}{'end'};
        return 0 if ($sp < $start || $sp > $end);
    }
    if (defined $sigs{$proto}{$sig_id}{'sp'}{'not'}) {
        return 0 if ($sp == $sigs{$proto}{$sig_id}{'sp'}{'not'});
    }
    if (defined $sigs{$proto}{$sig_id}{'sp'}{'negstart'}) {
        my $start = $sigs{$proto}{$sig_id}{'sp'}{'negstart'};
        my $end   = $sigs{$proto}{$sig_id}{'sp'}{'negend'};
        return 0 if ($sp > $start || $sp < $end);
    }
    ### if we made it to here, then we matched both
    ### the src and dst port criteria
    return 1;
}

sub check_icmp_sigs() {
    my ($sig_id, $ttl, $type, $code, $icmp_id, $icmp_seq) = @_;
    ### check icmp type first
    if (defined $sigs{'icmp'}{$sig_id}{'type'}) {
        return 0 if ($sigs{'icmp'}{$sig_id}{'type'} != $type);
    }
    if (defined $sigs{'icmp'}{$sig_id}{'ttl'}) {
        return 0 if ($sigs{'icmp'}{$sig_id}{'ttl'} != $ttl);
    }
    if (defined $sigs{'icmp'}{$sig_id}{'code'}) {
        return 0 if ($sigs{'icmp'}{$sig_id}{'code'} != $code);
    }
    if (defined $sigs{'icmp'}{$sig_id}{'icmp_id'}) {
        return 0 if ($sigs{'icmp'}{$sig_id}{'icmp_id'} != $icmp_id);
    }
    if (defined $sigs{'icmp'}{$sig_id}{'seq'}) {
        return 0 if ($sigs{'icmp'}{$sig_id}{'icmp_seq'} != $icmp_seq);
    }
    return 1;  ### if we got to this point, then we matched the signature
}

sub check_misc_fields() {
    my ($msg, $proto, $len, $ttl) = @_;
    if (defined $sigs{$proto}{$msg}{'LEN'}) {
        return 0 if ($sigs{$proto}{$msg}{'LEN'} != $len);
    }
    if (defined $sigs{$proto}{$msg}{'TTL'}) {
        return 0 if ($sigs{$proto}{$msg}{'TTL'} != $ttl);
    }
    return 1;
}

sub import_configs() {

    ### import psad.conf
    &Psad::buildconf(\%config, \%cmds, $config_file);

    ### make sure all necessary configuration variables
    ### are defined
    &required_vars();

    ### make sure the values in the config file make sense
    &validate_config();

    ### check to make sure the commands specified in the config section
    ### are in the right place, and attempt to correct automatically if not.
    &Psad::check_commands(\%cmds);

    ### set some config variables based on command line input
    &handle_cmdline();

    ### make sure PSAD_DIR, FW_DATA_FILE, and /var/lib/psad/psadfifo, etc.
    ### actually exist
    &setup();

    ### dump configuration to STDOUT
    exit &dump_conf() if $dump_conf;

    ### The --Kill command line switch was given.
    exit &stop_psad() if $kill;

    ### The --Flush command line switch was given.
    exit &flush_auto_blocked_ips() if $flush_fw;

    ### The --USR1 command line switch was given.
    exit &usr1() if $usr1;

    ### The --HUP command line switch was given.
    exit &hup() if $hup;

    ### the --Status command line switch was given
    exit &status() if $status;

    ### the --Restart command line switch was given
    exit &restart() if $restart;

    &Psad::psyslog('psad', '.. starting psad ..');

    ### import psad signatures (XXX: these should be taken directly
    ### from the snort signatures instead)
    &import_signatures() unless $no_signatures;

    ### import passive OS fingerprinting signatures
    &import_posf_sigs() unless $no_posf;

    ### import psad_auto_ips file for automatic ip/network danger
    ### level assignment
    &import_auto_ips() unless $no_auto_ips;

    ### parse snort rules if we enable psad to match on iptables log
    ### messages that include snort SID's (see "fwsnort":
    ### http://www.cipherdyne.org/fwsnort).
    &import_snort_rules() unless $no_snort_sids;

    return;
}

sub validate_config() {
    die ' ** PORT_RANGE_SCAN_THRESHOLD must be between 1 and 65535 '
        unless (&is_digit($config{'PORT_RANGE_SCAN_THRESHOLD'})
            && 0 < $config{'PORT_RANGE_SCAN_THRESHOLD'}
            && $config{'PORT_RANGE_SCAN_THRESHOLD'} < 65535);

    die qq( ** Invalid EMAIL_ADDRESSES value: "$config{'EMAIL_ADDRESSES'}")
        unless $config{'EMAIL_ADDRESSES'} =~ /\S+\@\S+/;
    die ' ** DSHIELD_ALERT_INTERVAL must be between 1 and 24 '
        unless (&is_digit($config{'DSHIELD_ALERT_INTERVAL'})
            && 0 < $config{'DSHIELD_ALERT_INTERVAL'}
            && $config{'DSHIELD_ALERT_INTERVAL'} < 24);
    return;
}

sub is_digit() {
    my $str = shift;
    return 1 if $str =~ m|^\d+$|;
    return 0;
}

sub import_snort_rules() {
    opendir D, $config{'SNORT_RULES_DIR'}
        or die " ** Could not open $config{'SNORT_RULES_DIR'}";
    my @rfiles = readdir D;
    closedir D;
    shift @rfiles; shift @rfiles;

    FILE: for my $rfile (@rfiles) {
        next FILE unless $rfile =~ /\.rules$/;
        if ($srules_type) {
            next FILE unless $rfile =~ /^${srules_type}\.rules$/;
        }
        my ($type) = ($rfile =~ /(\w+)\.rules/);
#        printf("%-30s", " .. $rfile");
#        &logr(" .. Parsing $rfile\n", $logfile);
        open R, "< ${config{'SNORT_RULES_DIR'}}/${rfile}" or
            die " ** Could not open: ${srules_type}/${rfile}";
        my @lines = <R>;
        close R;
        RULE: for my $line (@lines) {
            next RULE unless $line =~ /^alert/;
            chomp $line;
            my $msg;
            my $sid;
            my $classtype;
            my $content;

            ### can't handle multiple content fields
            next RULE if ($line =~ /content:.*content:/);
            next RULE if ($line =~ /content-list:/);

            $msg = $1 if $line =~ /msg:\s*\"(.*?)\"\s*;/;
            $sid = $1 if $line =~ /[\s;]sid:\s*(\d+)\s*;/;
            $classtype = $1 if $line =~ /[\s;]classtype:\s*(.*?)\s*;/;
            $content = $1 if $line =~ /[\s;]uricontent:\s*\"(.*?)\"\s*;/;
            $content = $1 if $line =~ /[\s;]content:\s*\"(.*?)\"\s*;/;
            if ($msg && $sid && $classtype) {
                $snort_msgs{$sid}{'classtype'} = $classtype;
                $snort_msgs{$sid}{'msg'}       = $msg;
                if ($content) {
                    $snort_msgs{$sid}{'content'} = $content;
                }
            }
        }
    }
    print Dumper %snort_msgs if $debug;
    &Psad::psyslog('psad', '.. imported Snort-2.0 signatures');
    return;
}

sub import_signatures() {
    %sigs = ();  ### undef %sigs so don't leave old signatures around
    open SIGS, "< $config{'PSAD_SIGS_FILE'}" or die
        " ** Could not open the signatures file $config{'PSAD_SIGS_FILE'}: $!";
    my @lines = <SIGS>;
    close SIGS;
    SIG: for my $line (@lines) {
        chomp $line;
        next SIG unless $line;
        next SIG if $line =~ /^\s*#/;
        if ($line =~ /^psad:(\d+);\s*(tcp|udp);\s*(\S+)\s*\-\>\s*(\S+);\s*
                       msg:\s*\"(.*)\";\s*(.*)\s*dlevel:\s*(\d);$/x) {
            my $sig_id  = $1;
            my $proto   = $2;
            my $sp      = $3;
            my $dp      = $4;
            my $msg_str = $5;
            my $options = $6;
            my $dlevel  = $7;

            ### add the signature message string to the %sig_attr cache
            $sigs_attr{$sig_id}{'dlevel'} = $dlevel;
            $sigs_attr{$sig_id}{'msg'}    = $msg_str;

            my $sig_flags = '';
            my $flags     = '';

            if ($options =~ /flags:\s*(\w+)/i) {
                $sig_flags = $1;
                ### make flags identical to what iptables log messages
                ### would report (check in iptables flag reporting order).
                $flags .= 'URG ' if $sig_flags =~ /U/;
                $flags .= 'ACK ' if $sig_flags =~ /A/;
                $flags .= 'PSH ' if $sig_flags =~ /P/;
                $flags .= 'RST ' if $sig_flags =~ /R/;
                $flags .= 'SYN ' if $sig_flags =~ /S/;
                $flags .= 'FIN ' if $sig_flags =~ /F/;

                ### iptables simply reports no flags set at all instead
                ### of reporting "NULL", so put NULL anyway.
                $flags .= 'NULL ' if $sig_flags =~ /N/;
                $flags =~ s/\s*$//;
            }
            ### future
#            my $ttl   = '';
#            if ($options =~ /ttl:\s*(\d+)/i) {
#                $sigs{$proto}{$sig_id}{'TTL'} = $1;
#            }

            ### assign the source and destination port ranges
            &build_tcp_udp_sigs($sig_id, $proto,
                $sp, $dp, $flags);

        } elsif ($line =~ /^psad:(\d+);\s*icmp;\s*
                            msg:\s*\"(.*)\";\s*(.*)\s*dlevel:\s*(\d);$/x) {
            my $sig_id  = $1;
            my $msg_str = $2;
            my $options = $3;
            my $dlevel  = $4;

            ### add the signature message string to the %sig_attr cache
            $sigs_attr{$sig_id}{'dlevel'} = $dlevel;
            $sigs_attr{$sig_id}{'msg'}    = $msg_str;

            if ($options =~ /ttl:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'ttl'} = $1;
            }
            if ($options =~ /itype:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'type'} = $1;
            }
            if ($options =~ /icode:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'code'} = $1;
            }
            if ($options =~ /icmp_seq:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'icmp_seq'} = $1;
            }
            if ($options =~ /icmp_id:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'icmp_id'} = $1;
            }
        } else {  ### the signature line could not be recognized
            warn " ** Bad signature in $config{'PSAD_SIGS_FILE'}: $line\n";
            next SIG;
        }
    }
    if ($debug) {
        print STDOUT " ** main signatures hash:\n";
        print STDOUT Dumper %sigs;
        print STDOUT " ** fast lookup hash:\n";
        print STDOUT Dumper %sigs_fast;
        print STDOUT Dumper " ** signature attributes hash:\n";
        print STDOUT Dumper %sigs_attr;
    }
    &Psad::psyslog('psad', '.. imported psad-1.2 signatures');
    return;
}

sub build_tcp_udp_sigs() {
    my ($sig_id, $proto, $sp, $dp, $flags) = @_;

    if (&is_range($dp) || &is_range($sp)) {
        ### if we make it here then we have a range of ports so insert
        ### the signature into the %sigs hash
        if ($proto eq 'tcp' && $flags) {
            $sigs{$proto}{$sig_id}{'flags'} = $flags;
        }
        ### deal with source port ranges
        if ($sp =~ /:/ && $sp !~ /!/) {
            my ($start, $end) = split /:/, $sp;
            $start = 1 unless $start;
            $end = 65535 unless $end;
            $sigs{$proto}{$sig_id}{'sp'}{'start'} = $start;
            $sigs{$proto}{$sig_id}{'sp'}{'end'}   = $end;
        } elsif ($sp =~ /!/ && $sp !~ /:/) {
            $sp =~ s/!//;
            $sigs{$proto}{$sig_id}{'sp'}{'not'} = $sp;
        } elsif ($sp =~ /:/ && $sp =~ /!/) {
            my ($start, $end) = split /:/, $sp;
            $start = 1 unless $start;
            $end = 65535 unless $end;
            $sigs{$proto}{$sig_id}{'sp'}{'negstart'} = $start;
            $sigs{$proto}{$sig_id}{'sp'}{'negend'}   = $end;
        } else {
            $sigs{$proto}{$sig_id}{'sp'}{'uniq_or_any'}
                = $sp;
        }

        ### deal with destination port ranges
        if ($dp =~ /:/ && $dp !~ /!/) {
            my ($start, $end) = split /:/, $dp;
            $start = 1 unless $start;
            $end = 65535 unless $end;
            $sigs{$proto}{$sig_id}{'dp'}{'start'} = $start;
            $sigs{$proto}{$sig_id}{'dp'}{'end'}   = $end;
        } elsif ($dp =~ /!/ && $dp !~ /:/) {
            $dp =~ s/!//;
            $sigs{$proto}{$sig_id}{'dp'}{'not'} = $dp;
        } elsif ($dp =~ /:/ && $dp =~ /!/) {
            my ($start, $end) = split /:/, $dp;
            $start = 1 unless $start;
            $end = 65535 unless $end;
            $sigs{$proto}{$sig_id}{'dp'}{'negstart'} = $start;
            $sigs{$proto}{$sig_id}{'dp'}{'negend'}   = $end;
        } else {
            $sigs{$proto}{$sig_id}{'dp'}{'uniq_or_any'} = $dp;
        }
    } else {
        ### build up the %sigs_fast lookup cache
        if ($dp !~ /\D/) {
            if ($sp !~ /\D/) {
                if ($proto eq 'tcp') {
                    $sigs_fast{$proto}{$dp}
                        {$sp}{$flags}{$sig_id} = '';
                } elsif ($proto eq 'udp') {
                    $sigs_fast{$proto}{$dp}
                        {$sp}{$sig_id} = '';
                }
            } elsif ($sp =~ /any/i) {
                if ($proto eq 'tcp') {
                    $sigs_fast{$proto}{$dp}
                        {'any_sp'}{$flags}{$sig_id} = '';
                } elsif ($proto eq 'udp') {
                    $sigs_fast{$proto}{$dp}
                        {'any_sp'}{$sig_id} = '';
                }
            }
        } elsif ($dp =~ /any/i) {
            if ($sp !~ /\D/) {
                if ($proto eq 'tcp') {
                    $sigs_fast{$proto}{'any_dp'}
                        {$sp}{$flags}{$sig_id} = '';
                } elsif ($proto eq 'udp') {
                    $sigs_fast{$proto}{'any_dp'}
                        {$sp}{$sig_id} = '';
                }
            } elsif ($sp =~ /any/i) {
                if ($proto eq 'tcp') {
                    $sigs_fast{$proto}{'any_dp'}
                        {'any_sp'}{$flags}{$sig_id} = '';
                } elsif ($proto eq 'udp') {
                    $sigs_fast{$proto}{'any_dp'}
                        {'any_sp'}{$sig_id} = '';
                }
            }
        }
    }
    return;
}

sub is_range() {
    my $port = shift;
    return 1 if $port =~ /:/;
    return 1 if $port =~ /!/;
    return 0;
}

sub import_auto_ips() {
    %auto_ips = ();  ### undef so we don't leave old ips in %auto_ips
    open A, "< $config{'PSAD_AUTO_IPS_FILE'}" or die ' ** Could not open ',
        "$config{'PSAD_AUTO_IPS_FILE'}: $!";
    my @lines = <A>;
    close A;
    my $i = 1;
    for my $line (@lines) {
        $i++;
        next if ($line =~ /^\s*#/);
        next unless ($line =~ /\S/);
        if ($line =~ m|^\s*($ip_re)\s+([0-5]);|) {
            $auto_ips{'ip'}{$1} = $2;
        } elsif ($line =~ m|^\s*($ip_re/\d+)\s+([0-5]);|) {
            $auto_ips{'net'}{$1} = $2;
        } else {
            my $subject = " ** psad import warning: " .
                "$config{'PSAD_AUTO_IPS_FILE'} error on line: $i";
            &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'},
                $cmds{'mail'});
        }
    }
    &Psad::psyslog('psad', '.. imported psad_auto_ips');
    return;
}

sub import_posf_sigs() {
    %posf_sigs = ();
    my $posf_file = $config{'PSAD_POSF_FILE'};
    open P, "< $posf_file" or die ' ** Could not open ',
        "$posf_file: $!";
    my @lines = <P>;
    close P;
    my $os = '';
    for my $line (@lines) {
        chomp $line;
        next if ($line =~ /^\s*#/);
        next unless ($line =~ /\S/);
        if ($line =~ /^\s*OS\s+(.*);/) {
            $os = $1;
        } elsif ($line =~ /^\s*NUMPKTS\s+(\d+);/) {
            $posf_sigs{$os}{'numpkts'} = $1;
        } elsif ($line =~ /^\s*TOS\s+(\w+);/) {
            $posf_sigs{$os}{'tos'} = $1;
        } elsif ($line =~ /^\s*LEN\s+(\d+);/) {
            $posf_sigs{$os}{'len'} = $1;
        } elsif ($line =~ /^\s*TTL\s+(\d+);/) {
            $posf_sigs{$os}{'ttl'} = $1;
        } elsif ($line =~ /^\s*ID\s+(\w+);/) {
            $posf_sigs{$os}{'id'} = $1;
        } elsif ($line =~ /^\s*WINDOW\s+(\d+);/) {
            $posf_sigs{$os}{'win'} = $1;
        }
    }
    ### make sure each of the os signatures has all fields defined
    OS: for my $os (keys %posf_sigs) {
        unless (defined $posf_sigs{$os}{'numpkts'}) {
            &Psad::psyslog('psad', "** $posf_file: missing " .
                "NUMPKTS for os: $os");
            delete $posf_sigs{$os};
            next OS;
        }
        unless (defined $posf_sigs{$os}{'tos'}) {
            &Psad::psyslog('psad', "** $posf_file: missing " .
                "TOS for os: $os");
            delete $posf_sigs{$os};
            next OS;
        }
        unless (defined $posf_sigs{$os}{'len'}) {
            &Psad::psyslog('psad', "** $posf_file: missing " .
                "LEN for os: $os");
            delete $posf_sigs{$os};
            next OS;
        }
        unless (defined $posf_sigs{$os}{'ttl'}) {
            &Psad::psyslog('psad', "** $posf_file: missing " .
                "TTL for os: $os");
            delete $posf_sigs{$os};
            next OS;
        }
        unless (defined $posf_sigs{$os}{'id'}) {
            &Psad::psyslog('psad', "** $posf_file: missing " .
                "ID for os: $os");
            delete $posf_sigs{$os};
            next OS;
        } else {
            unless ($posf_sigs{$os}{'id'} eq 'SMALLINCR'
                    || $posf_sigs{$os}{'id'} eq 'RANDOM') {
                &Psad::psyslog('psad', "** $posf_file: ID must " .
                    "be either SMALLINCR or RANDOM for os: $os");
                delete $posf_sigs{$os};
                next OS;
            }
        }
        unless (defined $posf_sigs{$os}{'win'}) {
            &Psad::psyslog('psad', "** $posf_file: missing " .
                "WINDOW for os: $os");
            delete $posf_sigs{$os};
            next OS;
        }
    }
    print Dumper %posf_sigs if $debug;
    &Psad::psyslog('psad',
        '.. imported passive OS fingerprinting signatures');
    return;
}

sub check_range() {
    my ($port, $start, $end) = @_;
    $start = $port if ($port < $start);
    $end   = $port if ($port > $end);
    return $start, $end;
}

### assign a danger level to a scan.  Note that match_fastsigs()
### and match_sigs() may also assign a danger level.
sub assign_danger_level() {
    my $current_scan_href = shift;

    SRC: for my $src (keys %$current_scan_href) {
        print "assign_danger_level(): source ip: $src\n" if $debug;
        if (%auto_ips) {
            if (defined $auto_ips{'ip'}{$src}) {
                $scan_dl{$src} = $auto_ips{'ip'}{$src};
                for my $dst (keys %{$scan{$src}}) {
                    $scan{$src}{$dst}{'alerted'} = 0
                        if ($config{'ALERT_ALL'} eq 'N');
                }
                ### ignore $src if the auto danger level is zero
                next SRC if $auto_ips{'ip'}{$src} == 0;
            } else {
                for my $net (keys %{$auto_ips{'net'}}) {
                    if (ipv4_in_network($net, $src)) {
                        $scan_dl{$src} = $auto_ips{'net'}{$net};
                        for my $dst (keys %{$scan{$src}}) {
                            $scan{$src}{$dst}{'alerted'} = 0
                                if ($config{'ALERT_ALL'} eq 'N');
                        }
                        ### ignore $src if the auto danger level is zero
                        next SRC if $auto_ips{'net'}{$net} == 0;
                    }
                }
            }
        }
        DST: for my $dst (keys %{$current_scan_href->{$src}}) {
            my $absnum = $scan{$src}{$dst}{'absnum'};
            my $range;
            my $s_port = 65535;
            my $e_port = 0;

            ### calculate the range over _both_ tcp and udp
            for my $proto qw(tcp udp) {
                next unless defined $scan{$src}{$dst}{$proto}{'abs_sp'};
                if ($s_port > $scan{$src}{$dst}{$proto}{'abs_sp'}) {
                    $s_port = $scan{$src}{$dst}{$proto}{'abs_sp'};
                }
                if ($e_port < $scan{$src}{$dst}{$proto}{'abs_ep'}) {
                    $e_port = $scan{$src}{$dst}{$proto}{'abs_ep'};
                }
            }
            if ($e_port) {
                $range = $e_port - $s_port;
            } else {  ### for icmp
                $range = $absnum;
            }

            ### if PORT_RANGE_SCAN_THRESHOLD is >= 1, then psad will not assign
            ### a danger level to repeated packets to the same port
            if ($absnum < $config{'DANGER_LEVEL1'}) {
                ### don't have enough packets to even reach danger level 1 yet.
                next DST;
            }
            if ($range >= $config{'PORT_RANGE_SCAN_THRESHOLD'}) {
                if ($absnum < $config{'DANGER_LEVEL2'}) {
                    if ($scan_dl{$src} < 1) {
                        $scan{$src}{$dst}{'alerted'} = 0
                            if ($config{'ALERT_ALL'} eq 'N');
                        $scan_dl{$src} = 1;
                    }
                } elsif ($absnum < $config{'DANGER_LEVEL3'}) {
                    if ($scan_dl{$src} < 2) {
                        $scan{$src}{$dst}{'alerted'} = 0
                            if ($config{'ALERT_ALL'} eq 'N');
                        $scan_dl{$src} = 2;
                    }
                } elsif ($absnum < $config{'DANGER_LEVEL4'}) {
                    if ($scan_dl{$src} < 3) {
                        $scan{$src}{$dst}{'alerted'} = 0
                            if ($config{'ALERT_ALL'} eq 'N');
                        $scan_dl{$src} = 3;
                    }
                } elsif ($absnum < $config{'DANGER_LEVEL5'}) {
                    if ($scan_dl{$src} < 4) {
                        $scan{$src}{$dst}{'alerted'} = 0
                            if ($config{'ALERT_ALL'} eq 'N');
                        $scan_dl{$src} = 4;
                    }
                } elsif ($scan_dl{$src} < 5) {
                    $scan{$src}{$dst}{'alerted'} = 0
                            if ($config{'ALERT_ALL'} eq 'N');
                    $scan_dl{$src} = 5;
                }
            }
            print 'assign_danger_level(): DL (after assignment) = ',
                "$scan_dl{$src}\n" if $debug;
        }
    }
    return;
}

sub write_global_packet_counters() {
    open P, "> $config{'PACKET_COUNTER_FILE'}" or
        die " ** Could not open $config{'PACKET_COUNTER_FILE'}: $!";
    print P "tcp:  $tcp_ctr\n";
    print P "udp:  $udp_ctr\n";
    print P "icmp: $icmp_ctr\n";
    close P;
    return;
}

sub write_src_packet_counters() {
    my ($hr, $file) = @_;
    open P, "> $file" or
        die " ** Could not open $file: $!";
    for my $chain (keys %$hr) {
        for my $intf (keys %{$hr->{$chain}}) {
            for my $proto qw(tcp udp icmp) {
            next unless defined $hr->{$chain}->{$intf}->{$proto};
                print P "${chain}_${intf}_${proto}:  ",
                    "$hr->{$chain}->{$intf}->{$proto}\n";
            }
        }
    }
    close P;
    return;
}

sub collect_errors() {
    my ($bad_packets_aref) = @_;
    open ERR, ">> $config{'FW_ERROR_LOG'}" or die ' ** Could not open ',
        "$config{'FW_ERROR_LOG'}: $!";
    for my $line (@$bad_packets_aref) {
        print ERR $line;
    }
    close ERR;
}

sub scan_logr() {
    my $current_scan_href = shift;

    for my $src (keys %$current_scan_href) {
        print STDOUT "scan_logr(): source ip: $src\n" if $debug;
        DST: for my $dst (keys %{$current_scan_href->{$src}}) {

            ### see if we have already sent an alert for $src
            ### (against $dst) for this danger level.
            if ($config{'ALERT_ALL'} eq 'N') {
                next DST if $scan{$src}{$dst}{'alerted'};
            }

            ### only send alerts for scans that are at least at
            ### danger level 1 or above.
            next DST unless $scan_dl{$src} >= 1;
            my $syslog_flags = '';
            my $dns_str      = '';
            my $rdns         = '';
            my $syslog_range = '';
            my $tcp_newrange = '';
            my $tcp_absrange = '';
            my $udp_newrange = '';
            my $udp_absrange = '';
            my $tcp_newpkts  = 0;
            my $udp_newpkts  = 0;
            my $icmp_newpkts = 0;
            my $tcp_f  = 0;
            my $udp_f  = 0;
            my $icmp_f = 0;
            my $whois_info_aref;

            ### get the current danger level and the absolute number
            ### of packets used in the scan so far
            my $curr_dl = $scan_dl{$src};

            unless (defined $scan{$src}{$dst}{'email_ctr'}) {
                $scan{$src}{$dst}{'email_ctr'} = 0;
            } elsif ($config{'PSAD_EMAIL_LIMIT'} > 0
                    and $scan{$src}{$dst}{'email_ctr'}
                    > $config{'PSAD_EMAIL_LIMIT'}) {
                ### ignore PSAD_EMAIL_LIMIT if it is zero
                unless (defined $scan{$src}{$dst}{'stop_email'}) {
                    &email_limit_reached($src, $dst);
                }
                next DST;
            }
            print STDOUT "scan_logr(): dst ip: $dst\n" if $debug;

            ### make $src directory here in /var/log/psad
            ### unless it already exists
            mkdir "$config{'PSAD_DIR'}/${src}", 0500 unless
                -d "$config{'PSAD_DIR'}/${src}";
            my $ecount_file  = "$config{'PSAD_DIR'}/${src}/email_count";
            my $dl_file      = "$config{'PSAD_DIR'}/${src}/danger_level";
            my $whois_file   = "$config{'PSAD_DIR'}/${src}/whois";
            my $email_file   = "$config{'PSAD_DIR'}/${src}/${dst}_email_alert";
            my $log_sigs     = "$config{'PSAD_DIR'}/${src}/${dst}_signatures";
            my $pkt_ctr_file = "$config{'PSAD_DIR'}/${src}/${dst}_packet_ctr";

            ### print the current danger level to the danger_level file
            &Psad::logr("$curr_dl\n", {$dl_file => 0});

            ### write out the overall packet counters for $src
            &write_src_packet_counters($scan{$src}{$dst}{'chain'},
                $pkt_ctr_file);

            if (defined $scan{$src}{$dst}{'tcp'}{'abs_sp'}) {
                my $tcp_s_port
                    = $scan{$src}{$dst}{'tcp'}{'abs_sp'};
                my $tcp_e_port
                    = $scan{$src}{$dst}{'tcp'}{'abs_ep'};
                if ($tcp_s_port == $tcp_e_port) {
                    $tcp_absrange = $tcp_s_port;
                } else {
                    $tcp_absrange = "$tcp_s_port-$tcp_e_port";
                }
            }
            if (defined $current_scan_href->{$src}->{$dst}->{'tcp'}->{'sp'}) {
                $tcp_f = 1;
                my $tcp_s_port
                    = $current_scan_href->{$src}->{$dst}->{'tcp'}->{'sp'};
                my $tcp_e_port
                    = $current_scan_href->{$src}->{$dst}->{'tcp'}->{'ep'};
                if ($tcp_s_port == $tcp_e_port) {
                    $tcp_newrange = $tcp_s_port;
                } else {
                    $tcp_newrange = "$tcp_s_port-$tcp_e_port";
                }
                $tcp_newpkts =
                    $current_scan_href->{$src}->{$dst}->{'tcp'}->{'pkts'};
            }
            if (defined $scan{$src}{$dst}{'udp'}{'abs_sp'}) {
                my $udp_s_port
                    = $scan{$src}{$dst}{'udp'}{'abs_sp'};
                my $udp_e_port
                    = $scan{$src}{$dst}{'udp'}{'abs_ep'};
                if ($udp_s_port == $udp_e_port) {
                    $udp_absrange = $udp_s_port;
                } else {
                    $udp_absrange = "$udp_s_port-$udp_e_port";
                }
            }
            if (defined $current_scan_href->{$src}->{$dst}->{'udp'}->{'sp'}) {
                $udp_f = 1;
                my $udp_s_port
                    = $current_scan_href->{$src}->{$dst}->{'udp'}->{'sp'};
                my $udp_e_port
                    = $current_scan_href->{$src}->{$dst}->{'udp'}->{'ep'};
                if ($udp_s_port == $udp_e_port) {
                    $udp_newrange = $udp_s_port;
                } else {
                    $udp_newrange = "$udp_s_port-$udp_e_port";
                }
                $udp_newpkts = $current_scan_href->{$src}->{$dst}->{'udp'}->{'pkts'};
            }
            if (defined $current_scan_href->{$src}->{$dst}->{'icmp'}) {
                $icmp_f = 1;
                $icmp_newpkts =
                    $current_scan_href->{$src}->{$dst}->{'icmp'}->{'pkts'};
            }

            ### get reverse dns info
            unless ($no_rdns) {
                if ($src =~ /$ip_re/) {
                    my $ipaddr = gethostbyname $src;
                    ### my $rdns = gethostbyaddr($ipaddr, AF_INET);
                    if ($rdns = gethostbyaddr $ipaddr, 2) {
                        $dns_str = $rdns;
                    } else {
                        $dns_str = '[No reverse dns info available]';
                    }
                } else {
                    ### $ipaddr was already reported as
                    ### a host name by iptables (does this actually
                    ### happen?)
                    $dns_str = $src;
                }
            }

            ### get whois info
            unless ($no_whois) {
                $whois_info_aref = &get_whois_data($src, $whois_file);
            }
            print STDOUT "scan_logr():  generating email.....\n" if $debug;

            ### get the absolute starting time for the scan and the
            ### current time
            my $abs_s_time = scalar localtime $scan{$src}{$dst}{'s_time'};
            my $s_time;
            if (time() - $config{'PSAD_CHECK_INTERVAL'} <
                $scan{$src}{$dst}{'s_time'}) {
                $s_time = $abs_s_time;
            } else {
                $s_time = scalar localtime((time()
                    - $config{'PSAD_CHECK_INTERVAL'}));
            }
            my $time = scalar localtime();

            ### open the email alert file
            open E, "> $email_file" or
                die " ** Could not open $email_file: $!";

            print E "=-=-=-=-=-=-=-=-=-=-=-= $time =-=-=-=-=-=-=-=",
                "-=-=-=-=\n";
            print E " ** psad: Suspicious traffic detected against ",
                "$config{'HOSTNAME'} ($dst).\n\n\n";
            printf E "%${log_len}s%s", 'Source: ', "$src\n";
            printf E "%${log_len}s%s", 'Source DNS: ', "$dns_str\n"
                unless $no_rdns;
            if (!$no_posf && defined $posf{$src}{'guess'}) {
                printf E "%${log_len}s%s", 'Source OS guess: ',
                    "$posf{$src}{'guess'}\n\n";
            }
            printf E "%${log_len}s%s", 'Destination: ', "$dst\n";
            printf E "%${log_len}s%s", 'Danger level: ',
                "[$scan_dl{$src}] (out of 5)\n\n";
            printf E "%${log_len}s%s", 'Current interval: ',
                "$s_time (start)\n";
            printf E "%${log_len}s%s", '', "$time (end)\n";
            if ($tcp_f) {
                printf E "%${log_len}s%s", 'Scanned tcp ports: ',
                    "[$tcp_newrange: $tcp_newpkts packets]\n";
                my $prefix = 'tcp flags: ';
                for my $flags (keys %{$current_scan_href->{$src}->
                        {$dst}->{'tcp'}->{'flags'}}) {
                    my $nmap_opts;
                    $syslog_flags .= "$flags ";
                    my $n_pkts = $current_scan_href->{$src}->{$dst}->
                        {'tcp'}->{'flags'}->{$flags};
                    ### FUTURE: replace this with a simple hash lookup
                    if ($flags eq 'SYN') {
                        $nmap_opts = '-sT or -sS';
                    } elsif ($flags eq 'FIN') {
                        $nmap_opts = '-sF';
                    } elsif ($flags eq 'URG PSH FIN') {
                        $nmap_opts = '-sX';
                    } elsif ($flags eq 'NULL') {
                        $nmap_opts = '-sN';
                    } elsif ($flags eq 'URG PSH SYN FIN') {
                        $nmap_opts = '-O';
                    }
                    if ($nmap_opts) {
                        printf E "%${log_len}s%s", $prefix,
                            "[$flags: $n_pkts pkts, Nmap: $nmap_opts]\n";
                    } else {
                        printf E "%${log_len}s%s", $prefix,
                            "[$flags: $n_pkts pkts]\n";
                    }
                    $prefix = '';
                }
                $syslog_flags =~ s/\s*$//;
                $syslog_range .= "tcp=[$tcp_newrange] $syslog_flags";
            }
            if ($udp_f) {
                printf E "%${log_len}s%s", 'Scanned udp ports: ',
                    "[$udp_newrange: $udp_newpkts pkts, Nmap: -sU]\n";
            }
            if ($icmp_f) {
                printf E "%${log_len}s%s", 'icmp packets: ',
                    "[$icmp_newpkts]\n";
            }
            print E "\n";

            ### print the overall stats since the scan began
            printf E "%${log_len}s%s", 'Overall stats since: ',
                "$abs_s_time\n";
            if ($tcp_absrange) {
                printf E "%${log_len}s%s", 'Complete tcp range: ',
                    "[$tcp_absrange]\n";
            }
            if ($udp_absrange) {
                printf E "%${log_len}s%s", 'Complete udp range: ',
                    "[$udp_absrange]\n";
            }
            print E "\n";
            printf E "    %-9s%-13s%-7s%-7s%-7s\n", 'chain:', 'interface:',
                'tcp:', 'udp:', 'icmp:';
            for my $chain (keys %{$scan{$src}{$dst}{'chain'}}) {
                for my $intf (keys %{$scan{$src}{$dst}{'chain'}{$chain}}) {
                    my $tot_tcp  = 0;
                    my $tot_udp  = 0;
                    my $tot_icmp = 0;
                    $tot_tcp = $scan{$src}{$dst}{'chain'}{$chain}{$intf}{'tcp'}
                        if defined $scan{$src}{$dst}{'chain'}{$chain}{$intf}{'tcp'};
                    $tot_udp = $scan{$src}{$dst}{'chain'}{$chain}{$intf}{'udp'}
                        if defined $scan{$src}{$dst}{'chain'}{$chain}{$intf}{'udp'};
                    $tot_icmp = $scan{$src}{$dst}{'chain'}{$chain}{$intf}{'icmp'}
                        if defined $scan{$src}{$dst}{'chain'}{$chain}{$intf}{'icmp'};
                    printf E "    %-9s%-13s%-7s%-7s%-7s\n", $chain,
                        $intf, $tot_tcp, $tot_udp, $tot_icmp;
                }
            }
            ### print out any matched signatures to the email
            ### alert file and also to the signature log
            &scan_logr_signatures($src, $dst, *E, $log_sigs);

            ### write a scan message to syslog
            &Psad::psyslog('psad', ".. scan detected: $src -> $dst " .
                "$syslog_range tcp=$tcp_newpkts udp=$udp_newpkts " .
                "icmp=$icmp_newpkts dangerlevel: $curr_dl");

            unless ($no_whois) {
                print E  "\n\nWhois Information: ----\n";
                for my $line (@$whois_info_aref) {
                    print E $line;
                }
                print E "\n";
            }
            print E "=-=-=-=-=-=-=-=-=-=-=-= $time =-=-=-=-=-=-=-=",
                "-=-=-=-=\n";
            close E;
            if ($curr_dl >= $config{'EMAIL_ALERT_DANGER_LEVEL'}) {
                my $subject;
                if ($rdns) {
                    if ($benchmark) {
                        $subject = " ** psad: BENCHMARK SCAN from: $rdns";
                    } else {
                        $subject
                            = " ** psad: [DL$curr_dl] SCAN from: $rdns";
                    }
                } else {
                    if ($benchmark) {
                        $subject = " ** psad: BENCHMARK SCAN from: $src";
                    } else {
                        $subject
                            = " ** psad: [DL$curr_dl] SCAN from: $src";
                    }
                }
                &Psad::psyslog('psad', ".. sending email alert to: " .
                    "$config{'EMAIL_ADDRESSES'}\n");
                &Psad::sendmail($subject, $email_file,
                    $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
                $scan{$src}{$dst}{'email_ctr'}++;

                ### print the number of email alerts we have sent
                &Psad::logr("$scan{$src}{$dst}{'email_ctr'}\n",
                    {$ecount_file => 0});

                if ($config{'ENABLE_EXT_SCRIPT_EXEC'} eq 'Y') {
                    if ($config{'EXEC_EXT_SCRIPT_PER_ALERT'} eq 'Y') {
                        &exec_external_script($src);
                    } else {
                        &exec_external_script($src) unless
                            defined $scan_ext_exec{$src};
                    }
                }
            }

            ### we have sent an alert for $dst
            if ($config{'ALERT_ALL'} eq 'N') {
                $scan{$src}{$dst}{'alerted'} = 1;
            }
        }
    }
    return;
}

sub scan_logr_signatures() {
    my ($src, $dst, $email_fh, $log_sigs) = @_;
    my $dst_ip_is_local = 0;
    $dst_ip_is_local = 1 if defined $local_ips{$dst};
    open LS, ">> $log_sigs" or die " ** Could not open $log_sigs: $!";
    for my $proto qw(tcp udp icmp) {
        next unless (defined $scan{$src}{$dst}{$proto}{'curr_sig'}
            || defined $scan{$src}{$dst}{$proto}{'snort_sid'});
        print $email_fh "\n";
        print LS "\n";
        print $email_fh "---- $proto scan signatures ----\n";
        print LS "---- $proto scan signatures ----\n";
        print "scan_logr_signatures(): src: $src dst: $dst proto: $proto\n"
            if $debug;
        for my $sid (keys %{$scan{$src}{$dst}{$proto}{'snort_sid'}}) {
            for my $chain (keys %{$scan{$src}{$dst}{$proto}{'snort_sid'}{$sid}}) {
                my $msg = $snort_msgs{$sid}{'msg'};
                my $classtype = $snort_msgs{$sid}{'classtype'};
                my $pkts = $scan{$src}{$dst}{$proto}{'snort_sid'}{$sid}{$chain};
                my $content;
                if (defined $snort_msgs{$sid}{'content'}) {
                    $content = $snort_msgs{$sid}{'content'};
                }
                print $email_fh qq("$msg"\n);
                print LS qq("$msg"\n);
                print $email_fh "       classtype: $classtype\n";
                print LS "       classtype: $classtype\n";
                print $email_fh "       sid:       $sid\n";
                print LS "       sid:       $sid\n";
                if ($content) {
                    print $email_fh qq(       content:   "$content"\n);
                    print LS qq(       content:   "$content"\n);
                }
                print $email_fh "       chain:   $chain\n";
                print LS "       chain:   $chain\n";
                print $email_fh "       packets:   $pkts\n\n";
                print LS "       packets:   $pkts\n\n";
            }
        }
        for my $sig_id (keys %{$scan{$src}{$dst}{$proto}{'curr_sig'}}) {
            my $msg = $sigs_attr{$sig_id}{'msg'};

            for my $chain (keys %{$scan{$src}{$dst}{$proto}{'curr_sig'}{$sig_id}}) {
                if ($proto eq 'tcp' or $proto eq 'udp') {
                    for my $dp (keys %{$scan{$src}{$dst}{$proto}{'curr_sig'}
                            {$sig_id}{$chain}{'dp'}}) {
                        my $flags = '';
                        my $pkts = $scan{$src}{$dst}{$proto}{'curr_sig'}
                            {$sig_id}{$chain}{'dp'}{$dp};
                        if (defined $scan{$src}{$dst}{$proto}{'curr_sig'}
                                {$sig_id}{$chain}{'flags'} and defined $scan{$src}{$dst}
                                    {$proto}{'curr_sig'}{$sig_id}{$chain}{'flags'}{$dp}) {
                            $flags = $scan{$src}{$dst}{$proto}{'curr_sig'}
                                        {$sig_id}{$chain}{'flags'}{$dp};
                        }

                        if ($dst_ip_is_local) {
                            ### check local ports here since we know the
                            ### destination is a local ip address
                            if (defined $local_ports{$proto}{$dp}) {
                                if ($flags) {
                                    print $email_fh "\"$msg\"\n",
                                        "     chain=$chain packets=$pkts dp=$dp flags=[$flags] ",
                                        "** Your machine is listening on $proto port: $dp!\n";
                                    print LS "\"$msg\"\n",
                                        "     chain=$chain packets=$pkts dp=$dp flags=[$flags] ",
                                        "** Your machine is listening on $proto port: $dp!\n";
                                } else {
                                    print $email_fh "\"$msg\"\n",
                                        "     chain=$chain packets=$pkts dp=$dp ",
                                        "** Your machine is listening on $proto port: $dp!\n";
                                    print LS "\"$msg\"\n",
                                        "     chain=$chain packets=$pkts dp=$dp ",
                                        "** Your machine is listening on $proto port: $dp!\n";
                                }
                            } else {
                                if ($flags) {
                                    print $email_fh "\"$msg\"\n",
                                        "     chain=$chain packets=$pkts dp=$dp flags=[$flags] ",
                                        "No local server on $proto/$dp\n";
                                    print LS "\"$msg\"\n",
                                        "     chain=$chain packets=$pkts dp=$dp flags=[$flags] ",
                                        "No local server on $proto/$dp\n";
                                } else {
                                    print $email_fh "\"$msg\"\n",
                                        "     chain=$chain packets=$pkts dp=$dp No local ",
                                        "server on $proto/$dp\n";
                                    print LS "\"$msg\"\n",
                                        "     chain=$chain packets=$pkts dp=$dp No local ",
                                        "server on $proto/$dp\n";
                                }
                            }
                        } else {
                            if ($flags) {
                                print $email_fh "\"$msg\"\n",
                                    "    chain=$chain packets=$pkts dp=$dp flags=[$flags]\n";
                                print LS "\"$msg\"\n",
                                    "    chain=$chain packets=$pkts dp=$dp flags=[$flags]\n";
                            } else {
                                print $email_fh "\"$msg\"\n",
                                    "    chain=$chain packets=$pkts dp=$dp\n";
                                print LS "\"$msg\"\n",
                                    "    chain=$chain packets=$pkts dp=$dp\n";
                            }
                        }
                    }
                } else {
                    my $pkts = $scan{$src}{$dst}{'icmp'}
                        {'curr_sig'}{$sig_id}{$chain}{'pkts'};
                    print $email_fh qq("$msg" chain=$chain packets=$pkts\n);
                    print LS qq("$msg" chain=$chain packets=$pkts\n);
                }
                ### signature logging with syslog is not yet supported
                ### (requires a message for each matched signature).
#            if ($sigmatch =~ /^(\".*\")/) {
#                $syslog_sig_title = "signature=$1";
#            }
            }
        }
        ### need to delete the current signature so it
        ### won't show up in the next alert
        delete $scan{$src}{$dst}{$proto}{'curr_sig'}
            unless $config{'SHOW_ALL_SIGNATURES'} eq 'Y';
        delete $scan{$src}{$dst}{$proto}{'snort_sid'}
            unless $config{'SHOW_ALL_SIGNATURES'} eq 'Y';
    }
    close LS;
    return;
}

sub exec_external_script() {
    my $src = shift;
    $scan_ext_exec{$src} = '';
    my $cmd = $config{'EXTERNAL_SCRIPT'};
    $cmd =~ s/SRCIP/$src/;
    my $pid;
    if ($pid = fork()) {
        local $SIG{'ALRM'} = sub {die " ** External script timeout.\n"};
        alarm 30;  ### the external script should be finished in 30 secs.
        eval {
            waitpid($pid, 0);
        };
        alarm 0;
        if ($@) {
            kill 9, $pid;
        }
    } else {
        die " ** Could not fork for external script: $!" unless defined $pid;
        exec qq{$cmd};
    }
    return;
}

sub renew_auto_blocked_ips() {
    my $timeout_str = '.';
    if ($config{'AUTO_BLOCK_TIMEOUT'} > 0) {
        $timeout_str = " for $config{'AUTO_BLOCK_TIMEOUT'} seconds.";
    }
    if ($config{'IPTABLES_BLOCK_METHOD'} eq 'Y'
            && -e $config{'AUTO_BLOCK_IPT_FILE'}) {
        open B, "< $config{'AUTO_BLOCK_IPT_FILE'}" or
            die " ** Could not open $config{'AUTO_BLOCK_IPT_FILE'}: $!";
        my @lines = <B>;
        close B;
        for my $line (@lines) {
            if ($line =~ /($ip_re)/) {
                my $ip = $1;
                ### add block rule for $ip unless it is already blocked
                unless (&ipt_test_block($ip)) {
                    &ipt_block($ip);
                    &Psad::sendmail(" ** psad: RENEWED iptables BLOCK against $ip" .
                        $timeout_str, '', $config{'EMAIL_ADDRESSES'},
                        $cmds{'mail'});
                }
                ### set the auto-block start time here since
                ### renew_auto_blocked_ips() is only called
                ### at startup.
                $auto_blocked_ips{$ip} = time();
            }
        }
    }
    if ($config{'TCPWRAPPERS_BLOCK_METHOD'} eq 'Y'
            && -e $config{'ETC_HOSTS_DENY'}) {
        open B, "< $config{'ETC_HOSTS_DENY'}" or
            die " ** Could not open $config{'AUTO_BLOCK_IPT_FILE'}: $!";
        my @lines = <B>;
        close B;
        for my $line (@lines) {
            if ($line =~ /($ip_re)/) {
                my $ip = $1;
                unless (&tcpwr_test_block($ip)) {
                    &tcpwr_block($ip);
                    &Psad::sendmail(" ** psad: RENEWED tcpwrappers BLOCK against $ip" .
                        $timeout_str, '', $config{'EMAIL_ADDRESSES'},
                        $cmds{'mail'});
                }
                $auto_blocked_ips{$ip} = time();
            }
        }
    }
    return;
}

sub flush_auto_blocked_ips() {
    my $found_blocked = 0;
    if (-e $config{'AUTO_BLOCK_IPT_FILE'}) {
        print " .. Removing iptables auto-generated block rules.\n";
        open B, "< $config{'AUTO_BLOCK_IPT_FILE'}" or
            die " ** Could not open $config{'AUTO_BLOCK_IPT_FILE'}: $!";
        my @lines = <B>;
        close B;
        for my $line (@lines) {
            if ($line =~ /($ip_re)/) {
                my $ip = $1;
                ### remove block rules for $ip if it has been blocked
                &ipt_remove_block($ip) if &ipt_test_block($ip);
            }
        }
        ### we have removed the iptables block rules, so truncate
        ### the cache file.
        open T, "> $config{'AUTO_BLOCK_IPT_FILE'}" or
            die " ** Could not truncate $config{'AUTO_BLOCK_IPT_FILE'}: $!";
        close T;
        $found_blocked = 1;
    }
    if (-e $config{'AUTO_BLOCK_TCPWR_FILE'}) {
        print " .. Removing tcpwrapper auto-generated block rules.\n";
        open B, "< $config{'AUTO_BLOCK_TCPWR_FILE'}" or
            die " ** Could not open $config{'AUTO_BLOCK_TCPWR_FILE'}: $!";
        my @lines = <B>;
        close B;
        for my $line (@lines) {
            if ($line =~ /($ip_re)/) {
                my $ip = $1;
                ### remove block rules for $ip if it has been blocked
                &tcpwr_remove_block($ip) if &tcpwr_test_block($ip);
            }
        }
        ### we have removed the tcpwrapper block rules, so truncate
        ### the cache file.
        open T, "> $config{'AUTO_BLOCK_TCPWR_FILE'}" or
            die " ** Could not truncate $config{'AUTO_BLOCK_TCPWR_FILE'}: $!";
        close T;
        $found_blocked = 1;
    }
    unless ($found_blocked) {
        print " ** Currently there are no auto-generated ".
            "block rules in effect.\n";
    }
    exit $found_blocked;
}

sub ipt_test_block() {
    my $ip = shift;

    ### get the active iptables chains
    &get_iptables_chains() unless $chk_ipt_chains;

    for my $table (keys %ipt_chains) {
        for my $chain (keys %{$ipt_chains{$table}}) {
            my @rules = `$cmds{'iptables'} -t $table -nL $chain`;
            RULE: for my $rule (@rules) {
                chomp $rule;
                next RULE if $rule =~ /^\s*Chain\s/;
                next RULE if $rule =~ /^\s*target\s/;
                ### DROP       all  --  1.1.1.1        0.0.0.0/0
                if ($rule =~ /^DROP\s+all.*?$ip\s+0\.0\.0\.0\/0/) {
                    return 1;
                }
            }
        }
    }
    ### did not find the ip
    return 0;
}

sub ipt_block() {
    my $src = shift;
    for my $table (keys %ipt_chains) {
        for my $chain (keys %{$ipt_chains{$table}}) {
            system "$cmds{'iptables'} -t $table -I $chain " .
                "$config{'IPTABLES_AUTO_RULENUM'} -s $src -j " .
                "DROP 2> /dev/null 1>&2";
        }
    }
    ### write the ip out to the auto blocked file
    &write_blocked_ip($src, $config{'AUTO_BLOCK_IPT_FILE'});
    return;
}

sub ipt_remove_block() {
    my $src = shift;

    ### get the active iptables chains
    &get_iptables_chains() unless $chk_ipt_chains;

    my $rm_block = 0;
    for my $table (keys %ipt_chains) {
        for my $chain (keys %{$ipt_chains{$table}}) {
            my @rules = `$cmds{'iptables'} -t $table -nL $chain`;
            my $rulenum = 1;
            RULE: for my $rule (@rules) {
                chomp $rule;
                next RULE if $rule =~ /^\s*Chain\s/;
                next RULE if $rule =~ /^\s*target\s/;
                ### DROP       all  --  1.1.1.1        0.0.0.0/0
                if ($rule =~ /^DROP\s+all.*?$src\s+0\.0\.0\.0\/0/) {
                    if ($flush_fw) {
                        print " .. Deleting rule $rulenum for $src, $table ",
                            "table $chain chain:\n";
                        print "        $rule\n";
                    }
                    system "$cmds{'iptables'} -t $table -D $chain $rulenum";
                    $rm_block = 1;
                    last RULE;  ### there should only be one auto-blocked rule
                }
                $rulenum++;
            }
        }
    }
    if ($rm_block) {
        &rm_blocked_ip($src, $config{'AUTO_BLOCK_IPT_FILE'});
    } else {
        &Psad::psyslog('psad', "** could not locate iptables block rule for $src.")
            if $flush_fw;
    }
    return $rm_block;
}

sub tcpwr_test_block() {
    my $ip = shift;
    open T, "< $config{'ETC_HOSTS_DENY'}" or die " ** Could not open ",
        "$config{'ETC_HOSTS_DENY'}: $!";
    my @lines = <T>;
    close T;
    for my $line (@lines) {
        chomp $line;
        return 1 if $line =~ /ALL:\s+$ip$/;
    }
    return 0;
}

sub tcpwr_block() {
    my $ip = shift;
    open T, ">> $config{'ETC_HOSTS_DENY'}" or die " ** Could not open ",
        "$config{'ETC_HOSTS_DENY'}: $!";
    print T "ALL: $ip\n";
    close T;
    return;
}

sub tcpwr_remove_block() {
    my $ip = shift;
    my $removed = 0;
    open T, "< $config{'ETC_HOSTS_DENY'}" or die ' ** Could not open ',
        "$config{'ETC_HOSTS_DENY'}: $!";
    my @lines = <T>;
    close T;
    open T, "> $config{'ETC_HOSTS_DENY'}.tmp" or die ' ** Could not open ',
        "$config{'ETC_HOSTS_DENY'}.tmp: $!";
    for my $line (@lines) {
        chomp $line;
        if ($line =~ /ALL:\s+$ip$/) {
            $removed = 1;
            &rm_blocked_ip($ip, $config{'AUTO_BLOCK_TCPWR_FILE'});
        } else {
            print T "$line\n";
        }
    }
    close T;
    move "$config{'ETC_HOSTS_DENY'}.tmp", $config{'ETC_HOSTS_DENY'};
    return $removed;
}

sub auto_psad_response() {
    if (not $chk_ipt_chains) {
        ### determine whether or not the NAT or mangle code has
        ### been compiled into iptables
        &get_iptables_chains();
    }
    for my $src (keys %scan) {

        ### make sure we are not attempting to block 0.0.0.0
        ### or 127.0.0.1 or any of the interface ips.
        if (&auto_block_ignore_ip($src)) {
            &Psad::psyslog('psad', ".. ignoring $src ip for auto block");
            next;
        }

        my $dl = $scan_dl{$src};
        ### We only want to block the IP once.  Currently this will block
        ### all traffic from the host to _all_ destinations that are
        ### protected by the firewall if the ip trips the $auto_psad_level
        ### threshold for _any_ destination.
        if ($dl >= $config{'AUTO_IDS_DANGER_LEVEL'}
                && not $auto_blocked_ips{$src}) {
            my $timeout_str = '.';
            if ($config{'AUTO_BLOCK_TIMEOUT'} > 0) {
                $timeout_str = " for $config{'AUTO_BLOCK_TIMEOUT'} seconds.";
            }
            ### we have seen at least one packet logged by the firewall
            ### at this point
            if ($config{'IPTABLES_BLOCK_METHOD'} eq 'Y') {
                &ipt_block($src);
                &Psad::sendmail(" ** psad: iptables AUTO-BLOCK against $src" .
                    $timeout_str, '', $config{'EMAIL_ADDRESSES'},
                    $cmds{'mail'});
            }
            if ($config{'TCPWRAPPERS_BLOCK_METHOD'} eq 'Y') {
                &Psad::sendmail(" ** psad: tcpwrappers AUTO-BLOCK against $src" .
                    $timeout_str, '', $config{'EMAIL_ADDRESSES'},
                    $cmds{'mail'});
                my $found = 0;
                open H, "< $config{'ETC_HOSTS_DENY'}" or die
                    "Could not open $config{'ETC_HOSTS_DENY'}: $!";
                my @lines = <H>;
                close H;
                for my $line (@lines) {
                    chomp $line;
                    $found = 1 if $line =~ /ALL:\s+$src$/;
                }
                unless ($found) {
                    open H, ">> $config{'ETC_HOSTS_DENY'}" or die
                        "Could not open $config{'ETC_HOSTS_DENY'}: $!";
                    print H "ALL: $src\n";
                    close H;
                    ### write the ip out to the auto blocked file
                    &write_blocked_ip($src, $config{'AUTO_BLOCK_TCPWR_FILE'});
                }
            }
            ### keep track of when we blocked the ip
            $auto_blocked_ips{$src} = time();
        }
    }
    return;
}

sub auto_block_ignore_ip() {
    my $ip = shift;
    return 1 if $ip eq '127.0.0.1';
    return 1 if $ip eq '0.0.0.0';
    for my $local_ip (keys %local_ips) {
        return 1 if $ip eq $local_ip;
    }
    return 0;
}

sub timeout_auto_blocked_ips() {
    for my $ip (keys %auto_blocked_ips) {
        if ((time() - $auto_blocked_ips{$ip})
                > $config{'AUTO_BLOCK_TIMEOUT'}) {
            if ($config{'IPTABLES_BLOCK_METHOD'} eq 'Y') {
                if (&ipt_remove_block($ip)) {
                    &Psad::sendmail(" ** psad: removed iptables block " .
                        "against $ip (timeout expired).", '',
                        $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
                }
            }
            if ($config{'TCPWRAPPERS_BLOCK_METHOD'} eq 'Y') {
                if (&tcpwr_remove_block($ip)) {
                    &Psad::sendmail(" ** psad: removed tcpwrappers block " .
                        "against $ip (timeout expired).", '',
                        $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
                }
            }
        }
    }
    return;
}

sub get_iptables_chains() {
    $chk_ipt_chains = 1;
    $ipt_chains{'filter'}{'INPUT'}   = '';
    $ipt_chains{'filter'}{'FORWARD'} = '';
    my $nat_rv = (system "$cmds{'iptables'} -nL -t nat " .
        "> /dev/null 2>&1") >> 8;
    my $mangle_rv = (system "$cmds{'iptables'} -nL -t mangle " .
        "> /dev/null 2>&1") >> 8;
    if ($nat_rv == 0) {
        $ipt_chains{'nat'}{'PREROUTING'} = '';
    }
    if ($mangle_rv == 0) {
        $ipt_chains{'mangle'}{'PREROUTING'} = '';
    }
    return;
}

sub write_blocked_ip() {
    my ($src, $file) = @_;
    if (-e $file) {
        open F, "< $file" or die " ** Could not open open ",
            "$file: $!";
        my @lines = <F>;
        close F;
        ### see if we have already written the ip to the block
        ### file.
        for my $line (@lines) {
            chomp $line;
            return if $line eq $src;  ### already blocked $src
        }
        open B, ">> $file" or
            die " ** Could not append to $file";
        print B "$src\n";
        close B;
    } else {
        open B, "> $file" or
            die " ** Could not create $file";
        print B "$src\n";
        close B;
    }
    return;
}

sub rm_blocked_ip() {
    my ($src, $file) = @_;
    if (-e $file) {
        open B, "< $file" or
            die " ** Could not open $file: $!";
        my @lines = <B>;
        close B;
        open W, "> $file" or
            die " ** Could not open $file: $!";
        for my $line (@lines) {
            chomp $line;
            print W $line, "\n" unless $line eq $src;
        }
        close W;
    }
    return;
}

sub email_limit_reached() {
    my ($src, $dst) = @_;
    my $subject = " ** psad: email message limit for $src has " .
        "been reached on $config{'HOSTNAME'} ($dst)!!!";
    &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
    $scan{$src}{$dst}{'stop_email'} = 1;
    return;
}

sub print_scan() {  ### this should primarily be used for debugging
    my $scanfile = "$config{'PRINT_SCAN_HASH'}.$$";
    open PSCAN, "> $scanfile" or warn ' ** Could not open ',
        "$scanfile: $!" and return;
    print PSCAN " ** Passive OS fingerprinting hash:\n";
    print PSCAN Dumper \%posf;
    print PSCAN " ** Scan danger level hash:\n";
    print PSCAN Dumper %scan_dl;
    print PSCAN " ** Main scan hash:\n";
    print PSCAN Dumper \%scan;
    close PSCAN;
    chmod 0600, $scanfile;
    return;
}

sub get_local_ips() {
    my @ips = `$cmds{'ifconfig'} -a`;
    for my $line (@ips) {
        if ($line =~ /inet\s+addr:($ip_re)\s/) {
            $local_ips{$1} = '';
        }
    }
    return;
}

sub get_listening_ports() {
    %local_ports = ();
    my @lines = `$cmds{'netstat'} -an`;
    for my $line (@lines) {
        chomp $line;
        if ($line =~ m/^\s*(tcp|udp)\s+\d+\s+\d+\s+\S+:(\d+)\s/) {
            ### $1 == protoco (tcp/udp), $2 == port number
            $local_ports{$1}{$2} = '';
        }
    }
    return;
}

sub get_whois_data() {
    my ($ip, $whois_datafile) = @_;
    my @whois_data;
    if (defined $whois_cache{$ip}
            && $whois_cache{$ip} < $config{'WHOIS_THRESHOLD'}
            && -e $whois_datafile) {
        $whois_cache{$ip}++;
    } else {
        $whois_cache{$ip} = 0;
        eval {
            local $SIG{'ALRM'} = sub {die "whois alarm\n"};
            alarm $config{'WHOIS_TIMEOUT'};
            system "$cmds{'whois'} $ip > $whois_datafile 2> /dev/null";
            alarm 0;
        };
        if ($@) {
            ### die unless $@ eq "whois alarm\n";
            ### warn "$@: $?";  ### let the warning handler save the error.
            warn $@;
            $#whois_data = 0;
            @whois_data = ("Whois data not available!\n");
            unlink $whois_datafile;
            return \@whois_data;
        }
    }
    open W, "< $whois_datafile" or
        die " ** Could not open $whois_datafile: $!";
    @whois_data = <W>;
    close W;
    return \@whois_data;
}

sub REAPER {
    my $pid;
    $pid = waitpid(-1, WNOHANG);
#   if (WIFEXITED($?)) {
#       print STDERR " .. **  Process $pid exited.\n";
#   }
    $SIG{'CHLD'} = \&REAPER;
    return;
}

sub file_permissions() {
    my $file = shift;
    if (-e $file) {
        chmod 0600, $file;
    } else {
        open T, "> $file" or die ' ** Could not open ',
            "$file: $!";
        close T;
        chmod 0600, $file;
    }
    return;
}

sub stop_psad() {
    my $rv = 0;

    &Psad::psyslog('psad', '.. shutting down psad daemons.');
    ### must kill psadwatchd first since if not, it might try to restart
    ### any of the other three daemons.
    for my $pidname qw(psadwatchd kmsgsd psad) {
        my $pidfile = $pidfiles{$pidname};
        if (-e $pidfile) {
            open PIDFILE, "< $pidfile" or die ' ** Could not open ',
                "$pidfile: $!";
            my $pid = <PIDFILE>;
            close PIDFILE;
            chomp $pid;
            if (kill 0, $pid) {
                print " .. Stopping $pidname, pid: $pid\n";
                unless (kill 15, $pid) {
                    kill 9, $pid or print " ** psad: Could not kill ",
                        "$pidname, pid: $pid $!\n";
                    $rv = 1;
                }
            } else {
                print " ** psad: $pidname is not running on ",
                    "$config{'HOSTNAME'}.\n";
                $rv = 1;
            }
        } else {
            print " ** psad: pid file $pidfile does not exist for ",
                "$pidname on $config{'HOSTNAME'}\n";
            $rv = 1;
        }
    }
    return $rv;
}

sub restart() {
    my $cmdline;
    if (-e $cmdline_file) {
        open CMD, "< $cmdline_file" or die ' ** Could not open ',
            "$cmdline_file: $!";
        $cmdline = <CMD>;
        close CMD;
        chomp $cmdline;
    } else {
        die " ** psad:  No other psad process is ",
            "running on $config{'HOSTNAME'}!";
    }
    &stop_psad();
    print " .. Restarting the psad daemons on $config{'HOSTNAME'}\n";
    system "$cmds{'psad'} $cmdline";
    return 0;
}

### display the status of all four psad daemons
sub status() {

    ### print the status of a specific ip address
    &status_ip() if $status_ip;

    my $rv = 0;   ### assume psad is not running and test...
    for my $pidname qw(psadwatchd kmsgsd psad) {
        my $pidfile = $pidfiles{$pidname};
        if (-e $pidfile) {
            open PIDFILE, "< $pidfile" or die ' ** Could not open ',
                "$pidfile: $!";
            my $pid = <PIDFILE>;
            close PIDFILE;
            chomp $pid;
            if (kill 0, $pid) {
                print " .. $pidname (pid: $pid)";
                ### XXX should probably just parse /proc instead of
                ### using ps
                my @ps_out = `$cmds{'ps'} auxww`;
                PS: for my $line (@ps_out) {
                    chomp $line;
                    if ($line =~ /^\S+\s+$pid\s+(\S+)\s+(\S+)/) {
                        print "  %CPU: $1  %MEM: $2\n";
                        print "    Running since: " .
                            localtime((stat($pidfile))[9]) . "\n";
                        ### print individual ip info
                        &status_psad_daemon() if $pidname eq 'psad';
                    }
                }
                print "\n";
                $rv = 1;
            } else {
                print " ** psad: $pidname is not running on ",
                    "$config{'HOSTNAME'}\n";
            }
        } else {
            print " ** psad: pid file $pidfile does not exist for ",
                "$pidname on $config{'HOSTNAME'}\n";
        }
    }
    return $rv;
}

sub status_psad_daemon() {
    my $cmdline;
    ### only the psad daemon (normally) runs with command line arguments
    if (-e $cmdline_file) {
        open CMD, "< $cmdline_file" or die ' ** Could not open ',
            "$cmdline_file: $!";
        $cmdline = <CMD>;
        chomp $cmdline;
    }
    if ($cmdline) {
        print "    Command line arguments: $cmdline\n";
    } else {
        print "    Command line arguments: [none specified]\n";
    }
    print "    Alert email address(es): ",
        "$config{'EMAIL_ADDRESSES'}\n";
    ### print the packet counters
    if (-e $config{'PACKET_COUNTER_FILE'}) {
        print "\n    Global packet counters:\n";
        open F, "< $config{'PACKET_COUNTER_FILE'}" or
            die " ** $config{'PACKET_COUNTER_FILE'}: $!";
        print STDOUT "        $_" while (<F>);
        close F;
    }
    ### sort and print the scan source ips
    my %scan_srcs;
    chdir $config{'PSAD_DIR'} or
        die " ** Could not chdir $config{'PSAD_DIR'}: $!";
    opendir D, $config{'PSAD_DIR'} or
        die " ** Could not open dir: $config{'PSAD_DIR'}: $!";
    my @files = readdir D;
    closedir D;
    shift @files; shift @files;
    for my $file (@files) {
        if ($file =~ /$ip_re/ && -d $file) {
            ### $file is a current scan source ip
            my $src_ipdir = $file;
            my $dl = 0;
            if (-e "${src_ipdir}/danger_level") {
                open F, "< ${src_ipdir}/danger_level" or
                    die " ** Could not open ",
                        "${src_ipdir}/danger_level: $!";
                $dl = <F>;
                close F;
                chomp $dl;
            }
            opendir D, $src_ipdir or die " ** Could not open dir: ",
                "$src_ipdir: $!";
            my @ipdirfiles = readdir D;
            closedir D;
            shift @ipdirfiles; shift @ipdirfiles;
            for my $file (@ipdirfiles) {
                my $dst;
                if ($file =~ /($ip_re)_packet_ctr/) {
                    $dst = $1;
                } else {
                    next;
                }
                if (-e "${src_ipdir}/${dst}_packet_ctr") {
                    open F, "< ${src_ipdir}/${dst}_packet_ctr" or
                        die " ** Could not open ",
                            "${src_ipdir}/${dst}_packet_ctr: $!";
                    my @lines = <F>;
                    close F;
                    for my $line (@lines) {
                        if ($line =~ /^(\w+)_(\w+)_(\w+):\s+(\d+)/) {
                            my $chain = $1;
                            my $intf  = $2;
                            my $proto = $3;
                            my $ctr   = $4;
                            if ($status_sort_dl) {
                                $scan_srcs{$dl}{$src_ipdir}{$dst}
                                    {$chain}{$intf}{$proto} = $ctr;
                            } else {
                                $scan_srcs{$src_ipdir}{$dst}{'dl'}
                                    = $dl;
                                $scan_srcs{$src_ipdir}{$dst}
                                    {$chain}{$intf}{$proto} = $ctr;
                            }
                        }
                    }
                }
            }
        }
    }
    print STDOUT "\n";
    if (%scan_srcs) {
        printf "    %-17s%-17s%-8s%-12s%-6s%-6s%-7s%-7s\n", 'src:', 'dst:',
            'chain:', 'interface:', 'tcp:', 'udp:', 'icmp:', 'dl:';
        if ($status_sort_dl) {
            my $found_equal_status = 0;
            for my $dl (sort {$b <=> $a} keys %scan_srcs) {
                if ($status_dl) {
                    next unless $dl >= $status_dl;
                }
                $found_equal_status = 1;
                for my $src (keys %{$scan_srcs{$dl}}) {
                    for my $dst (keys %{$scan_srcs{$dl}{$src}}) {
                        for my $chain qw(input forward output) {
                            next unless defined
                                $scan_srcs{$dl}{$src}{$dst}{$chain};
                            for my $intf (keys
                                    %{$scan_srcs{$dl}{$src}{$dst}{$chain}}) {
                                my $tcp_ctr = 0;
                                my $udp_ctr = 0;
                                my $icmp_ctr = 0;
                                $tcp_ctr = $scan_srcs{$dl}{$src}
                                {$dst}{$chain}{$intf}{'tcp'}
                                    if defined $scan_srcs{$dl}{$src}
                                            {$dst}{$chain}{$intf}{'tcp'};
                                $udp_ctr = $scan_srcs{$dl}{$src}{$dst}
                                {$chain}{$intf}{'udp'}
                                    if defined $scan_srcs{$dl}{$src}
                                            {$dst}{$chain}{$intf}{'udp'};
                                $icmp_ctr = $scan_srcs{$dl}{$src}
                                {$dst}{$chain}{$intf}{'icmp'}
                                    if defined $scan_srcs{$dl}{$src}
                                            {$dst}{$chain}{$intf}{'icmp'};
                                printf "    %-17s%-17s%-8s%-12s%-6s%-6s%-7s%-7s\n",
                                    $src, $dst, $chain, $intf, $tcp_ctr,
                                    $udp_ctr, $icmp_ctr, $dl;
                            }
                        }
                    }
                }
                unless ($found_equal_status) {
                    print STDOUT "    [No level $status_dl scans detected]\n";
                }
            }
        } else {
            my $found_equal_status = 0;
            for my $src (sort keys %scan_srcs) {
                for my $dst (keys %{$scan_srcs{$src}}) {
                    my $dl = $scan_srcs{$src}{$dst}{'dl'};
                    if ($status_dl) {
                        next unless $dl >= $status_dl;
                    }
                    $found_equal_status = 1;
                    for my $chain qw(input forward output) {
                        next unless defined
                            $scan_srcs{$src}{$dst}{$chain};
                        for my $intf (keys
                                %{$scan_srcs{$src}{$dst}{$chain}}) {
                            my $tcp_ctr = 0;
                            my $udp_ctr = 0;
                            my $icmp_ctr = 0;
                            $tcp_ctr = $scan_srcs{$src}
                            {$dst}{$chain}{$intf}{'tcp'}
                                if defined $scan_srcs{$src}
                                        {$dst}{$chain}{$intf}{'tcp'};
                            $udp_ctr = $scan_srcs{$src}{$dst}
                            {$chain}{$intf}{'udp'}
                                if defined $scan_srcs{$src}
                                        {$dst}{$chain}{$intf}{'udp'};
                            $icmp_ctr = $scan_srcs{$src}
                            {$dst}{$chain}{$intf}{'icmp'}
                                if defined $scan_srcs{$src}
                                        {$dst}{$chain}{$intf}{'icmp'};
                            printf "    %-17s%-17s%-8s%-12s%-6s%-6s%-7s%-7s\n",
                                $src, $dst, $chain, $intf, $tcp_ctr,
                                $udp_ctr, $icmp_ctr, $dl;
                        }
                    }
                }
            }
            unless ($found_equal_status) {
                print STDOUT "    [No level $status_dl scans detected]\n";
            }
        }
    } else {
        print STDOUT "    [No scans detected]\n";
    }
    return;
}

sub status_ip() {
    my $rv = 0;
    my @match_ip;
    die " ** $config{'FW_DATA_FILE'} does not exist yet.  Exiting."
        unless -e $config{'FW_DATA_FILE'};
    die " ** No data yet in $config{'FW_DATA_FILE'}.  Exiting."
        unless -s $config{'FW_DATA_FILE'} > 0;
    die " ** No scans from $status_ip have been detected.\n",
        "    See 'psad --Status' for a complete list."
        unless -d "$config{'PSAD_DIR'}/$status_ip";
    open FW, "< $config{'FW_DATA_FILE'}" or die " ** Could not open ",
        "$config{'FW_DATA_FILE'}: $!";
    while (<FW>) {
        push @match_ip, $_ if $_ =~ /SRC=$status_ip\s/
            || $_ =~ /DST=$status_ip\s/;
    }
    close FW;
    die " ** Could not match $status_ip to packets in ",
        "$config{'FW_DATA_FILE'}.  Exiting." unless @match_ip;
    open D, "> $config{'PSAD_DIR'}/$status_ip/fwdata" or
        die " ** Could not open $config{'PSAD_DIR'}/$status_ip/fwdata";
    for my $line (@match_ip) {
        print D $line;
    }
    for (my $i=$#match_ip; $i>=$#match_ip-10; $i--) {
        print STDOUT $match_ip[$i] if defined $match_ip[$i];
    }
    print STDOUT "\n .. The above packet output shows up to 10 of the ",
        "most recently\n    logged packets for $status_ip.\n";
    print STDOUT " .. All packets logged by iptables specifically ",
        "for $status_ip\n    can be viewed here: ",
        "$config{'PSAD_DIR'}/$status_ip/fwdata\n";

    opendir D, "$config{'PSAD_DIR'}/$status_ip" or
        die " ** Could not open dir: $config{'PSAD_DIR'}/$status_ip: $!";
    my @ipdirfiles = readdir D;
    closedir D;
    shift @ipdirfiles; shift @ipdirfiles;
    for my $file (@ipdirfiles) {
        my $dst;
        if ($file =~ /($ip_re)_packet_ctr/) {
            $dst = $1;
        } else {
            next;
        }
        if (-e "$config{'PSAD_DIR'}/$status_ip/${dst}_packet_ctr") {
            print STDOUT " .. Packet counters against dst: $dst:\n";
            open F, "< $config{'PSAD_DIR'}/$status_ip/${dst}_packet_ctr" or
                die " ** Could not open $config{'PSAD_DIR'}/$status_ip/",
                    "${dst}_packet_ctr: $!";
            print STDOUT "        $_" for <F>;
            close F;
        }
    }
    if (-e "$config{'PSAD_DIR'}/$status_ip/email_count") {
        open F, "< $config{'PSAD_DIR'}/$status_ip/email_count" or
            die " ** Could not open $config{'PSAD_DIR'}/$status_ip/",
                "email_count: $!";
        my $ec = <F>;
        close F;
        chomp $ec;
        print STDOUT " .. Email alerts sent: $ec\n";
    }
    if (-e "$config{'PSAD_DIR'}/$status_ip/danger_level") {
        open F, "< $config{'PSAD_DIR'}/$status_ip/danger_level" or
            die " ** Could not open $config{'PSAD_DIR'}/$status_ip/",
                "danger_level: $!";
        my $dl = <F>;
        close F;
        chomp $dl;
        print STDOUT " .. Current danger level: $dl\n";
    }
    exit $rv;
}

sub usr1() {
    my $rv = 0;
    my $psad_pidfile = $pidfiles{'psad'};
    if (-e $psad_pidfile) {
        open PIDFILE, "< $psad_pidfile" or
                die " ** Could not open $psad_pidfile: $!";
        my $pid = <PIDFILE>;
        close PIDFILE;
        chomp $pid;
        if (kill 0, $pid) {  ### make sure psad is actually running
            if (kill 'USR1', $pid) {
                $rv = 1;
                print " .. USR1 signal sent to pid: $pid\n";
                for (my $try=0; $try<=20; $try++) {  ### limit attempts to 20
                    sleep 1;
                    print " .. Checking for file: ",
                        "$config{'PSAD_DIR'}/scan_hash.${pid}\n";
                    if (-e "$config{'PSAD_DIR'}/scan_hash.${pid}") {
                        open U, "< $config{'PSAD_DIR'}/scan_hash.${pid}"
                            or print " ** Sent psad pid $pid a USR1 ",
                                "signal, but could not open\n",
                                "\"$config{'PSAD_DIR'}/scan_hash.${pid}\n\""
                            and return $rv;
                        print while(<U>);
                        close U;
                        print " .. Results available here: ",
                            "$config{'PSAD_DIR'}/scan_hash.${pid}\n";
                        last;
                    }
                }
            } else {
                print " ** Could not send psad the USR1 signal on ",
                    "$config{'HOSTNAME'}\n";
            }
        } else {
            print " ** psad is not running on $config{'HOSTNAME'}\n";
        }
    }
    return $rv;
}

sub usr1_handler() {
    $usr1_flag = 1;
    return;
}

sub hup() {
    my $rv = 0;
    for my $pidname qw(psadwatchd psad kmsgsd) {
        my $pidfile = $pidfiles{$pidname};
        open PID, "< $pidfile" or die " ** Could not open $pidfile: $!";
        my $pid = <PID>;
        close PID;
        chomp $pid;
        if (kill 0, $pid) {
            if (kill 'HUP', $pid) {
                print " .. HUP sent to $pidname (pid: $pid)\n";
            } else {
                print " ** Could not send $pidname ",
                    "(pid: $pid) a HUP signal.\n";
                $rv = 1;
            }
        } else {
            print " ** $pidname daemon not running.\n";
            $rv = 1;
        }
    }
    return $rv;
}

sub hup_handler() {
    $hup_flag = 1;
    return;
}

sub archive_data() {
    chdir $config{'PSAD_DIR'} or die " ** Could not chdir ",
        "$config{'PSAD_DIR'}: $!";
    unless (-d $config{'SCAN_DATA_ARCHIVE_DIR'}) {
        mkdir $config{'SCAN_DATA_ARCHIVE_DIR'}, 0500 or
            die " ** Could not create dir: ",
            "$config{'SCAN_DATA_ARCHIVE_DIR'}: $!";
    }

    ### archive all of the old ip address directories since
    ### we are restarting psad (should add a way to import
    ### these directories back into memory)
    opendir D, $config{'PSAD_DIR'} or die " ** Could not open dir: ",
        "$config{'PSAD_DIR'}: $!";
    my @files = readdir D;
    closedir D;
    shift @files; shift @files;

    for my $file (@files) {
        if ($file =~ /$ip_re/ && -d $file) {
            ### $file is an old scaning ip from a previous psad execution
            my $old_ipdir     = $file;
            my $archive_ipdir = "$config{'SCAN_DATA_ARCHIVE_DIR'}/$old_ipdir";
            if (-d $archive_ipdir) {
                rmtree $archive_ipdir;
            }
            move $old_ipdir, $archive_ipdir;
        }
    }

    ### archive the fwdata file
    my $fwdata    = $config{'FW_DATA_FILE'};
    my $fwarchive = "$config{'SCAN_DATA_ARCHIVE_DIR'}/fwdata_archive";
    ### first see how big the archive file is and zero out if
    ### it is larger than about 10,000 lines
    if (-e $fwarchive && (-s $fwarchive) > 2367766) {  ### about 10,000 lines
        open F, "> $fwarchive" or die ' ** Could not open ',
            "$fwarchive: $!";
        close F;
    }
    unless (-e $fwdata) {
        return;
    }
    open FW, "< $fwdata" or die "$fwdata exists but couldn't open it: $!";
    my @fwlines = <FW>;
    close FW;
    open AR, ">> $fwarchive" or die "Could not open $fwarchive: $!";
    print AR $_ for @fwlines;
    close AR;
    ### zero out $FW_DATA_FILE
    open F, "> $fwdata" or die ' ** Could not open ',
        "$fwdata: $!";
    close F;
    return;
}

sub check_old_cmdargs() {
    if ($oldarg_snort_sids) {
        print " ** The --snort-sids capability is enabled by\n",
            "default (see the --no-snort-sids option).\n";
        &usage(1);
    }
    &print_old_arg('auto_ips', 'auto-ips') if $oldarg_autoips;
    &print_old_arg('Logging_server', 'log-server') if $oldarg_logserv;
    &print_old_arg('errors', 'no-ipt-errors') if $oldarg_errs;
    &print_old_arg('no_errors', 'no-ipt-errors') if $oldarg_nerrs;
    &print_old_arg('no-errors', 'no-ipt-errors') if $oldarg_nerrs2;
    &print_old_arg('reversedns', 'no-rdns') if $oldarg_rdns;
    &print_old_arg('no_rdns', 'no-rdns') if $oldarg_nrdns;
    &print_old_arg('whois', 'no-whois') if $oldarg_whois;
    &print_old_arg('no_whois', 'no-whois') if $oldarg_nwhois;
    &print_old_arg('no_localport', 'no-localport') if $oldarg_nlport;
    &print_old_arg('localport', 'no-netstat') if $oldarg_netstat;
    &print_old_arg('firewallcheck', 'no-fwcheck') if $oldarg_fwcheck;
    &print_old_arg('no_fw_check', 'no-fwcheck') if $oldarg_nfwchk;
    &print_old_arg('Daemon', 'no-daemon') if $oldarg_daemon;
    return;
}

sub print_old_arg() {
    my ($oldarg, $newarg) = @_;
    print qq( ** The "$oldarg" option has been changed to "$newarg"\n);
    &usage(1);  ### this exits
}

sub handle_cmdline() {

    ### make sure the psad logfile is where we think it is.
    $psad_logfile = $config{'PSAD_LOG'} unless $psad_logfile;

    ### The -i switch was given
    $config{'PSAD_CHECK_INTERVAL'} = $chk_interval if $chk_interval;

    ### The --snort-rdir switch was given
    $config{'SNORT_RULES_DIR'} = $snort_rules_dir if $snort_rules_dir;

    ### The --signatures switch was given
    $config{'PSAD_SIGS_FILE'} = $sigs_file if $sigs_file;

    ### The --passive-os-file switch was given
    $config{'PSAD_POSD_FILE'} = $posf_file if $posf_file;

    ### The --auto-ips switch was given
    $config{'PSAD_AUTO_IPS_FILE'} = $autoips_file if $autoips_file;

    return;
}

sub setup() {

    ### turn off buffering
    $| = 1;

    ### store the psad command line.
    $cmdline_file = $config{'PSAD_CMDLINE_FILE'};

    ### pid file hash
    %pidfiles = (
        'psadwatchd' => $config{'PSADWATCHD_PID_FILE'},
        'psad'       => $config{'PSAD_PID_FILE'},
        'kmsgsd'     => $config{'KMSGSD_PID_FILE'},
    );

    unless (-d $config{'PSAD_DIR'}) {
        mkdir $config{'PSAD_DIR'}, 0500;
    }
    unless (-d $config{'PSAD_ERROR_DIR'}) {
        mkdir $config{'PSAD_ERROR_DIR'}, 0500;
    }
    unless (-e $config{'FW_DATA_FILE'}) {
        open F, "> $config{'FW_DATA_FILE'}" or die ' ** Could not open ',
            "$config{'FW_DATA_FILE'}: $!";
        close F;
    }
    unless (-e $config{'FW_ERROR_LOG'}) {
        open E, "> $config{'FW_ERROR_LOG'}" or die ' ** Could not open ',
            "$config{'FW_ERROR_LOG'}: $!";
        close E;
    }
    unless (-e $config{'PSAD_FIFO'}) {
        system "$cmds{'mknod'} -m 600 $config{'PSAD_FIFO'} p";
    }
    ### make sure the new whois path exists
    if (-x '/usr/bin/whois.psad' && ! -x $cmds{'whois'}
            && '/usr/bin/whois.psad' ne $cmds{'whois'}) {
        move '/usr/bin/whois.psad', $cmds{'whois'};
    }

    die ' ** No system logger config file could be found.'
        unless (-e $config{'ETC_SYSLOG_CONF'}
                or -e $config{'ETC_SYSLOGNG_CONF'});

    ### look for psadfifo in some system logger config file
    ### (syslog, syslog-ng, etc.) and attempt to correct if not
    ### found.
    if (-e $config{'ETC_SYSLOG_CONF'}) {
        unless (-e "$config{'ETC_SYSLOG_CONF'}.orig") {
            copy $config{'ETC_SYSLOG_CONF'},
                "$config{'ETC_SYSLOG_CONF'}.orig";
        }
        open RS, "< $config{'ETC_SYSLOG_CONF'}" or
            die " ** Unable to open $config{'ETC_SYSLOG_CONF'}: $!";
        my @lines = <RS>;
        close RS;
        my $found = 0;
        for my $line (@lines) {
            if ($line =~ m/\|\s*$config{'PSAD_FIFO'}/) {
                $found = 1;
                last;
            }
        }
        unless ($found) {
            open SYSLOG, "> $config{'ETC_SYSLOG_CONF'}" or
                die " ** Unable to open $config{'ETC_SYSLOG_CONF'}: $!";
            ### this loop removes any old location for psadfifo
            for my $line (@lines) {
                unless ($line =~ /psadfifo/i) {
                    print SYSLOG $line;
                }
            }
            ### reinstate kernel logging to our named pipe
            print SYSLOG '### Send kern.info messages to psadfifo for ',
                "analysis by kmsgsd\n";
            print SYSLOG "kern.info\t\t|$config{'PSAD_FIFO'}\n";
            close SYSLOG;
            &Psad::psyslog('psad', '.. reconfiguring syslogd to write ' .
                "kern.info messages to $config{'PSAD_FIFO'}");
            system "$cmds{'killall'} -HUP $cmds{'syslogd'}";
        }
    }
    if (-e $config{'ETC_SYSLOGNG_CONF'}) {
        unless (-e "$config{'ETC_SYSLOGNG_CONF'}.orig") {
            copy $config{'ETC_SYSLOGNG_CONF'},
                "$config{'ETC_SYSLOGNG_CONF'}.orig";
        }
        open RS, "< $config{'ETC_SYSLOGNG_CONF'}" or
            die " ** Unable to open $config{'ETC_SYSLOGNG_CONF'}: $!\n";
        my @lines = <RS>;
        close RS;

        my $found = 0;
        for my $line (@lines) {
            if ($line =~ m/$config{'PSAD_FIFO'}/) {
                $found = 1;
                last;
            }
        }
        unless ($found) {
            open SYSLOGNG, "> $config{'ETC_SYSLOGNG_CONF'}" or
                die " ** Unable to open $config{'ETC_SYSLOGNG_CONF'}: $!";
            ### this loop removes any old location for psadfifo
            for my $line (@lines) {
                unless ($line =~ /psadfifo/i) {
                    print SYSLOGNG $line;
                }
            }
            print SYSLOGNG "\n";
            print SYSLOGNG 'destination psadpipe { pipe(',
                "\"$config{'PSAD_FIFO'}\"); };\n";
            print SYSLOGNG "filter f_kerninfo { facility(kern) ",
                "and level(info); };\n";
            print SYSLOGNG 'log { source(src); ',
                "filter(f_kerninfo); destination(psadpipe); };\n";
            close SYSLOGNG;
            &Psad::psyslog('psad', '.. reconfiguring syslog-ng to write ' .
                "kern.info messages to $config{'PSAD_FIFO'}");
            system "$cmds{'killall'} -HUP syslog-ng";
        }
    }

    ### make sure the permissions on these files is 0600
    &file_permissions($config{'FW_DATA_FILE'});
    &file_permissions($config{'FW_ERROR_LOG'});
    return;
}

sub fw_check() {
    my $rv = 0;
    if (defined $cmds{'iptables'} && -x $cmds{'iptables'}) {
        unlink $config{'FW_CHECK_FILE'} if -e $config{'FW_CHECK_FILE'};
        my $input_rv = &ipt_chk_chain('INPUT');
        my $forward_rv = &ipt_chk_chain('FORWARD');
        if ($input_rv && $forward_rv) {
            &Psad::logr(" .. The iptables ruleset on $config{'HOSTNAME'} " .
                "will log and block unwanted packets in both the INPUT and " .
                "FORWARD chains.  Firewall config success!\n",
                {$config{'FW_CHECK_FILE'} => 1});
            $rv = 1;
        } else {
            &Psad::logr("\n", {$config{'FW_CHECK_FILE'} => 1});
            &Psad::logr(' .. NOTE: IPTables::Parse does not yet parse user ' .
                'defined chains and so it is possible your firewall config ' .
                "is compatible with psad anyway.\n",
                {$config{'FW_CHECK_FILE'} => 1});
            &Psad::sendmail(" ** psad: firewall setup warning on " .
                "$config{'HOSTNAME'}!", $config{'FW_CHECK_FILE'},
                $config{'EMAIL_ADDRESSES'},
                $cmds{'mail'}
            );
        }
    } else {
        $rv = &Psad::check_firewall_rules(
            $config{'FW_MSG_SEARCH'},  ### SNORT_SID_STR is normally used for
                                       ### snort "sid" values so don't include
                                       ### it within the firewall check
            $config{'EMAIL_ADDRESSES'},
            $config{'FW_CHECK_FILE'},
            \%cmds
        );
    }
    if ($fw_analyze) {
        if ($rv) {
            print scalar localtime(), " .. Firewall config looks good.\n";
            print scalar localtime(), " .. Completed check of firewall ruleset.\n";
        } else {
            print scalar localtime(), " ** Errors found in firewall config.\n";
            print scalar localtime(), " ** Results in " .
                "$config{'FW_CHECK_FILE'}\n";
            print scalar localtime(), "    emailed to ",
                "$config{'EMAIL_ADDRESSES'}\n";
        }
        print scalar localtime(), " .. Exiting.\n";
        exit 0;
    }
}

### should probably make this into its own script
sub ipt_chk_chain() {
    my $chain = shift;

    my $rv = 1;

    ### check to see if there are multiple interfaces on the
    ### machine and return true by default for the FORWARD
    ### chain if no since the machine will not be able to
    ### forward packets anyway (e.g. desktop machines).  Also
    ### return true by default if forwarding is turned off
    ### we have to trust the machine config is as the admin
    ### wants it).
    if ($chain eq 'FORWARD') {
        my $forwarding;
        if (-e $config{'PROC_FORWARD_FILE'}) {
            open F, "< $config{'PROC_FORWARD_FILE'}"
                or die " ** Could not open $config{'PROC_FORWARD_FILE'}: $!";
            $forwarding = <F>;
            close F;
            chomp $forwarding;
            print " .. forwarding value: $forwarding\n" if $debug;
            return $rv if $forwarding == 0;
        } else {
            die " ** Make sure the path to the ip forwarding file correct.\n",
                "    The PROC_FORWARD_FILE in $config_file points to\n",
                "    $config{'PROC_FORWARD_FILE'}";
        }
        my @if_out = `$cmds{'ifconfig'} -a`;
        my $num_intf = 0;
        for my $line (@if_out) {
            if ($line =~ /inet\s+addr/i && $line !~ /127\.0\.0\.1/) {
                $num_intf++;
            }
        }
        print " .. number of interfaces: $num_intf\n" if $debug;
        if ($num_intf < 2) {
            return $rv;
        }
    }

    my $ipt = new IPTables::Parse 'iptables' => $cmds{'iptables'};

    if ($fw_analyze) {
        print scalar localtime(), " .. Parsing iptables $chain chain rules.\n";
    }
    ### for now we are only looking at the filter table, so if
    ### the iptables ruleset includes the log and drop rules in
    ### a user defined chain then psad will not see this.
    my $ld_hr = $ipt->default_drop('filter', $chain);

    print Dumper $ld_hr if $debug;

    my $fwc = $config{'FW_CHECK_FILE'};
    if (defined $ld_hr && keys %$ld_hr) {
        my @protos;
        my $found_all = 0;
        if (defined $ld_hr->{'all'}) {
            @protos = qw(all);
            $found_all = 1;
        } else {
            @protos = qw(tcp udp icmp);
        }
        for my $proto (@protos) {
            my $str1;
            my $str2;
            if (! defined $ld_hr->{$proto}->{'LOG'}) {
                if ($proto eq 'all') {
                    $str1 = "for all protocols";
                    $str2 = 'scans';
                } else {
                    $str1 = "for the $proto protocol";
                    $str2 = "$proto scans";
                }
                &Psad::logr(" ** The $chain chain in the iptables ruleset on " .
                    "$config{'HOSTNAME'} does not include a default LOG rule " .
                    "$str1.  psad will not be able to detect $str2 without " .
                    "such a rule.\n",
                    {$fwc => 1});
                &Psad::logr("\n", {$fwc => 1});
                $rv = 0;
            }
            if (defined $ld_hr->{$proto}->{'LOG'}->{'prefix'}
                    && $ld_hr->{$proto}->{'LOG'}->{'prefix'}
                    !~ /$config{'FW_MSG_SEARCH'}/) {
                if ($proto eq 'all') {
                    $str1 = " ** The $chain chain in the iptables ruleset " .
                    "on $config{'HOSTNAME'} includes a default LOG rule for " .
                    "all protocols,";
                    $str2 = 'scans';
                } else {
                    $str1 = " ** The $chain chain in the iptables ruleset " .
                    "on $config{'HOSTNAME'} inclues a default LOG rule for " .
                    "the $proto protocol,";
                    $str2 = "$proto scans";
                }
                &Psad::logr("$str1 but the rule does not have a log prefix " .
                    qq(of "$config{'FW_MSG_SEARCH'}".  It appears as though ) .
                    qq(the log prefix is set to "$ld_hr->{$proto}->{'LOG'}->{'prefix'}".) .
                    qq(  psad will not be able to detect $str2 without adding ) .
                    qq(--log-prefix "$config{'FW_MSG_SEARCH'}" to the rule.\n),
                    {$fwc => 1});
                &Psad::logr("\n", {$fwc => 1});
                $rv = 0;
            }
            if (! defined $ld_hr->{$proto}->{'DROP'}) {
                if ($proto eq 'all') {
                    $str1 = "for all protocols";
                } else {
                    $str1 = "for the $proto protocol";
                }
                &Psad::logr(" ** The $chain chain in the iptables ruleset on " .
                    "$config{'HOSTNAME'} does not include a default DROP " .
                    "rule $str1.\n", {$fwc => 1});
                &Psad::logr("\n", {$fwc => 1});
                $rv = 0;
            }
            if ($found_all) {  ### avoid $ld_hr->{'all'} auto vivification
                return $rv;
            }
        }
        unless ($found_all) {
            &Psad::logr(' ** The best way to fix the above errors is to ' .
                'first setup iptables to accept traffic that you need ' .
                "to/through the iptables $chain chain, and then execute the " .
                "following commands:\n", {$fwc => 1});
            &Psad::logr("        iptables -A $chain -j LOG --log-prefix " .
                qq("$config{'FW_MSG_SEARCH'}"\n), {$fwc => 1});
            &Psad::logr("        iptables -A $chain -j DROP\n",
                {$fwc => 1});
        }
    } else {
        &Psad::logr(" ** The $chain chain in the iptables ruleset on " .
            "$config{'HOSTNAME'} does not include default rules that will " .
            "log and drop unwanted packets. You need to include two default " .
            "rules; one that logs packets that have not been accepted by " .
            "previous rules (this rule should have a logging prefix of " .
            "\"$config{'FW_MSG_SEARCH'}\"), and a final rule that drops any " .
            "unwanted packets.\n",
            {$fwc => 1});
        &Psad::logr("\n", {$fwc => 1});
        &Psad::logr('    FOR EXAMPLE:  Assuming you have already setup ' .
            'iptables rules to accept traffic you want to accept, you can ' .
            'probably execute the following two commands to have iptables ' .
            "log and drop unwanted packets in the $chain chain by " .
            "default.\n",
            {$fwc => 1});
        &Psad::logr("\n", {$fwc => 1});
        &Psad::logr("              iptables -A $chain -j LOG --log-prefix " .
            qq(" $config{'FW_MSG_SEARCH'}"\n), {$fwc => 1});
        &Psad::logr("              iptables -A $chain -j DROP\n\n",
            {$fwc => 1});
        &Psad::logr(" ** Psad will not detect in the iptables $chain chain " .
            'scans without an iptables ruleset that includes rules similar ' .
            "to the two rules above.\n",
            {$fwc => 1});
        &Psad::logr("\n", {$fwc => 1});
    }
    return;
}

sub disk_space_exceeded() {
    my @df_data = `$cmds{'df'} $config{'PSAD_DIR'}`;
    my ($prcnt) = ($df_data[$#df_data] =~ /(\d+)%/);
    my $rv = 0;
    if ($config{'DISK_MAX_PERCENTAGE'} > 0 and
            $prcnt > $config{'DISK_MAX_PERCENTAGE'}) {  ### need to remove data
        $rv = 1;
        $rm_data_ctr++;
        &Psad::psyslog('psad', ".. disk partition associated with " .
            "$config{'PSAD_DIR'} exceeded " .
            "$config{'DISK_MAX_PERCENTAGE'} prct utilization.");
        &Psad::sendmail(" ** psad: Exceeded max disk utilization for " .
            "$config{'PSAD_DIR'} on $config{'HOSTNAME'}", '',
            $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
        &Psad::psyslog('psad', ".. removing data in $config{'PSAD_DIR'}");
        if (-e "$config{'SCAN_DATA_ARCHIVE_DIR'}/fwdata_archive") {
            open F, "> $config{'SCAN_DATA_ARCHIVE_DIR'}/fwdata_archive"
                or die " ** Could not truncate ",
                    "$config{'SCAN_DATA_ARCHIVE_DIR'}: $!";
            close F;
        }
        opendir D, $config{'PSAD_DIR'} or
            die " ** Could not open dir: $config{'PSAD_DIR'}: $!";
        my @ipdirs = readdir D;
        closedir D;
        shift @ipdirs; shift @ipdirs;
        chdir $config{'PSAD_DIR'} or die $!;
        for my $ipdir (@ipdirs) {
            if ($ipdir =~ /$ip_re/ and -d $ipdir) {
                opendir IP, $ipdir or die $!;
                my @scanfiles = readdir IP;
                closedir IP;
                for my $file (@scanfiles) {
                    if (-e "${ipdir}/$file" and $file =~ /_signatures/) {
                        unlink "${ipdir}/$file";
                    }
                }
            }
        }
        if ($rm_data_ctr > $config{'DISK_MAX_RM_RETRIES'}) {
            &Psad::psyslog('psad', "** could not sufficiently reduce disk " .
                "utilization in $config{'PSAD_DIR'} partition.  " .
                "Stopping psad!");
            &Psad::sendmail(" ** psad: Could not reduce disk utilization on " .
                $config{'HOSTNAME'}, '', $config{'EMAIL_ADDRESSES'},
                $cmds{'mail'});
            &Psad::sendmail(" ** psad: Stopping psad on $config{'HOSTNAME'}!",
                '', $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
            for my $pidname qw(psadwatchd kmsgsd) {
                my $pidfile = $pidfiles{$pidname};
                open PIDFILE, "< $pidfile" or die ' ** Could not open ',
                    "$pidfile: $!";
                my $pid = <PIDFILE>;
                close PIDFILE;
                chomp $pid;
                if (kill 0, $pid) {
                    unless (kill 15, $pid) {  ### attempt to stop with SIGTERM
                        kill 9, $pid;
                    }
                }
            }
            exit 1;
        }
    } else {
        ### the disk check interval was exceeded but the utilization is ok.
        $rm_data_ctr = 0;
    }
    return $rv;
}

sub stop_legacy_diskmond() {
    my $diskmond_pidfile = '/var/run/psad/diskmond.pid';
    if (-e $diskmond_pidfile) {
        open PIDFILE, "< $diskmond_pidfile" or
            die " ** Could not open $diskmond_pidfile: $!";
        my $pid = <PIDFILE>;
        close PIDFILE;
        chomp $pid;
        if (kill 0, $pid) {
            unless (kill 15, $pid) {  ### attempt to stop with SIGTERM
                kill 9, $pid;
            }
        }
        unlink $diskmond_pidfile;
    }
    if (-e '/etc/psad/diskmond.conf') {
        unlink '/etc/psad/diskmond.conf';
    }
    return;
}

sub dump_conf() {
    print " .. Dumping psad config from: $config_file\n";
    for my $var (sort keys %config) {
        printf "%-30s %s\n", " .. $var", $config{$var};
    }
    return 0;
}

sub required_vars() {
    my @required_vars = qw(
        EMAIL_ADDRESSES PSAD_CHECK_INTERVAL FW_DATA_FILE FW_ERROR_LOG
        FW_MSG_SEARCH SNORT_SID_STR ENABLE_AUTO_IDS PSAD_LOG
        IGNORE_CONNTRACK_BUG_PKTS SCAN_TIMEOUT DANGER_LEVEL1
        DANGER_LEVEL2 DANGER_LEVEL3 DANGER_LEVEL4 DANGER_LEVEL5
        PORT_RANGE_SCAN_THRESHOLD ALERT_ALL PSAD_EMAIL_LIMIT
        IPTABLES_BLOCK_METHOD TCPWRAPPERS_BLOCK_METHOD
        EMAIL_ALERT_DANGER_LEVEL PSAD_FIFO WHOIS_THRESHOLD WHOIS_TIMEOUT
        SNORT_RULES_DIR PACKET_COUNTER_FILE SCAN_DATA_ARCHIVE_DIR HOSTNAME
        PROC_FORWARD_FILE ENABLE_PERSISTENCE AUTO_BLOCK_IPT_FILE
        AUTO_BLOCK_TCPWR_FILE PSAD_SIGS_FILE PSAD_AUTO_IPS_FILE
        AUTO_BLOCK_TIMEOUT EXTERNAL_SCRIPT ENABLE_EXT_SCRIPT_EXEC
        EXEC_EXT_SCRIPT_PER_ALERT ENABLE_DSHIELD_ALERTS
        DSHIELD_ALERT_INTERVAL DSHIELD_ALERT_EMAIL DSHIELD_USER_ID
        DSHIELD_USER_EMAIL DISK_CHECK_INTERVAL DISK_MAX_PERCENTAGE
        DISK_MAX_RM_RETRIES ETC_HOSTS_DENY ETC_SYSLOG_CONF
        ETC_SYSLOGNG_CONF
    );
    &Psad::defined_vars(\%config, $config_file, \@required_vars);
    return;
}

sub usage() {
    my $exitcode = shift;
    print <<_HELP_;

psad; the Port Scan Attack Detector
 .. Version: $version
 .. By Michael Rash (mbr\@cipherdyne.org, http://www.cipherdyne.org)

Usage: psad [-a <auto ips file>] [-c <config file>] [-l] [-i <interval>]
       [-h] [-B] [-F] [-S] [-K] [-R] [-U] [-V] [-f] [-o] [-p] [-D] [-d]
       [--signatures <sig file>] [--passive-os-sigs <posf file>]
       [--snort-type <type>] [--snort-rdir <rules dir>]
       [--interval <seconds>] [--status-ip <ip>] [--status-sort-dl]
       [--no-fwcheck] [--no-daemon] [--no-rdns] [--no-whois]
       [--no-netstat] [--no-ipt-errors] [--no-passiveos]
       [--no-snort-sids]

Options:
    --signatures <sigs file>      - Manually specify the path to the
                                    psad signatures file.
    --passive-os-sigs <sigs file> - Manually specify the path to the
                                    passive os fingerprinting sigs.
    --snort-type                  - Enable psad to look for specific
                                    snort sids such as those in
                                    ddos.rules or backdoor.rules.
    --interval                    - Configure the check interval from
                                    the command line to override the 15
                                    second default.
    -a   --auto-ips <ips file>    - Import auto ips file for automatic
                                    ip danger level increases/decreses.
    -c   --config <config file>   - Use <config file> instead of the
                                    normal config file located at
                                    $config_file.
    -f   --fw-check               - Analyze the local firewall ruleset
                                    and exit.
    -d   --debug                  - Run psad in debugging mode.
    -D   --Dump-conf              - Dump psad configuration on STDOUT
                                    and exit.
    -o   --output                 - Print all messages to STDOUT (this
                                    does not include bad packet messages
                                    that are printed to the error log).
    -l   --log-server             - Psad is being run on a syslog
                                    logging server.
    -F   --Flush                  - Remove any auto-generated firewall
                                    block rules.
    -K   --Kill                   - Kill all running psad processes.
    -R   --Restart                - Restart all running psad processes.
    -S   --Status                 - Displays the status of any
                                    currently running psad processes.
    --status-ip <ip address>      - View status for a specific ip.
    --status-sort-dl              - Sort --Status output by danger level
                                    instead of by ip address.
    --status-dl <dl>              - Display status information for only
                                    those scans that have reach at least
                                    <dl> (from 1 to 5).
    -B   --Benchmark              - run psad in benchmark mode.
    --packets <number>            - Specify number of packets to use in
                                    benchmark test (default is 10,000).
    -U   --USR1                   - Send a running psad process a USR1
                                    signal (generates a dump of psad
                                    data structures on STDOUT).
    -H   --HUP                    - Send all psad daemons a HUP signal
                                    to have them re-import configs.
    -V   --Version                - Print the psad version and exit.

    --no-snort-sids               - Disable psad to look for snort sids
                                    in iptables log messages such as
                                    those generated by fwsnort.
    --no-signatures               - Disable signature processing.
    --no-auto-ips                 - Disable auto danger level assignment.
    --no-daemon                   - Do not run as a daemon.
    --no-ipt-errors               - Do not write errors to the error
                                    log.
    --no-whois                    - Disable whois lookups.
    --no-fwcheck                  - Disable firewall rules verification.
    --no-rdns                     - Disable name resolution against
                                    scanning ips.
    --no-netstat                  - Disable local port lookups for scan
                                    signatures.
    -h   --help                   - Display usage on STDOUT and exit.

_HELP_
    exit $exitcode;
}
