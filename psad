#!/usr/bin/perl -w
#
################################################################################
#
# File: psad
#
# Purpose: psad makes use of ipchains/iptables logs to detect port scans,
#          probes for backdoors and DDoS tools, and other suspect traffic
#          (many signatures were adapted from the snort intrusion
#          detection system).  Data is provided by kmsgsd which reads
#          firewall messages out of the /var/lib/psad/psadfifo named pipe
#          (syslog is reconfigured to write kern.info messages there
#          which include firewall messages).  For more information read
#          the psad man page or view the documentation provided at:
#          http://www.cipherdyne.org.
#
# Author: Michael Rash (mbr@cipherdyne.org)
#
# Credits:  (see the CREDITS file)
#
# Version: 1.2
#
# Copyright (C) 1999-2002 Michael Rash (mbr@cipherdyne.org)
#
# License (GNU Public License):
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
#    USA
#
# TODO:
#   - Extend passive OS fingerprinting to make use of more types of
#     packets than just tcp/syn packets.
#   - Add a density calculation for a range of scanned ports, and also
#     add a "verbose" mode that will display which of the scanned ports
#     actually resolve to something in the IANA spec.
#   - Packet grapher mode with annotated scan alerts.
#   - Database support?
#   - Get rid of the psad_signatures file in favor of just parsing the
#     snort rules files directly.
#   - Make use of other logging options available in iptables to detect
#     more tcp signatures.  (E.g. --log-tcp-options, --log-ip-options,
#     --log-tcp-sequence, etc.) for better signature recognition.
#   - Include a verbose message in the body of certain emails that as
#     of psad-1.0.0-pre2 only contain a subject line.
#   - Allow ipchains to use tcp signatures that only require a syn packet
#     to a port as well as udp signatures.
#   - Deal with the possibility that psad could eat lots of memory over
#     time if $ENABLE_PERSISTENCE="Y". This should involve periodically
#     deleting entries in %scan (or maybe the entire hash), but this
#     should be done in a way that allows some scan data to persist.
#   - Ipfilter support on *BSD platforms.
#   - Take into account syslog message summarization; i.e. "last message
#     repeated n times".
#   - Possibly add a daemon to take into account ACK PSH, ACK FIN, RST etc.
#     packets that the client may generate after the ip_conntrack module
#     is reloaded.  Without anticipating such packets psad will interpret
#     them as a belonging to a port scan.  NOTE: This problem is mostly
#     corrected by the conntrack patch to the kernel.  Also, the
#     IGNORE_CONNTRACK_BUG_PKTS variable was added to mitigate this
#     problem.
#   - Improve check_firewall_rules() to check for a state rule (iptables)
#     since having such a rule greatly improves the quality of the data
#     stream provided to psad by kmsgsd since more packet types will be
#     denied without requiring overly complicated firewall rules to detect
#     odd tcp flag combinations.
#   - Handle various logging daemons other than syslog such as msyslog,
#     and metalog (syslog-ng support was added).
#   - perldoc
#
# Default Command Line Arguments:  As of the 1.0.0-pre3 release, psad by
#   by default will have the --signatures and --auto-ips options set even
#   if these options are not specified on the command line, and psad
#   will use the default locations for the signatures and auto_ips files.
#   The default file locations can be changed by manually specifying the
#   locations to these files with the --signatures and --auto-ips options.
#   The signature matching and the auto_ips danger level assignments can
#   be disabled by using the --no-signatures and --no-auto-ips options
#   respectively.  In addition, psad adheres to the following
#   defaults:
#       -passive OS fingerprinting            = yes
#       -write errors to error log            = yes
#       -daemon mode                          = yes
#       -reverse dns lookups                  = yes
#       -check firewall rules                 = yes
#       -whois lookups of scanning ips        = yes
#       -parse netstat output for local ports = yes
#
# Coding Style:  All configuration variables from psad.conf are stored in
#   the %config hash by keys that are in capital letters.  This is
#   the only place in the code where capital letters will be used in
#   variables names.  There are several variables with file-scope, and
#   these variables are clearly commented near the top of each of the
#   psad daemons.  Lines are generally limited to 80 characters for easy
#   reading.
#
# Sample packets:
#
#  Sample packet (rejected by ipchains)
#  Dec 19 11:54:07 orthanc kernel: Packet log: input REJECT lo PROTO=1
#  10.0.0.4:3127.0.0.1:3 L=88 S=0xC0 I=49513 F=0x0000 T=255
#
#  Sample tcp packet (rejected by iptables... --log-prefix = "DROP ")
#  Mar 11 13:15:52 orthanc kernel: DROP IN=lo OUT= MAC=00:00:00:00:00:00:00:00:
#  00:00:00:00:08:00 SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00
#  TTL=64 ID=0 DF PROTO=TCP SPT=44847 DPT=35 WINDOW=32304 RES=0x00 SYN URGP=0
#
#  Sample icmp packet rejected by iptables
#  Nov 27 15:45:51 orthanc kernel: DROP IN=eth1 OUT= MAC=00:a0:cc:e2:1f:f2:00:
#  20:78:10:70:e7:08:00 SRC=192.168.10.20 DST=192.168.10.1 LEN=84 TOS=0x00
#  PREC=0x00 TTL=64 ID=0 DF PROTO=ICMP TYPE=8 CODE=0 ID=61055 SEQ=256
#
#  Occasionally the kernel klogd ring buffer must become full since log
#  entries are sometimes generated by a long port scan like this (note
#  there is no 'DPT' field):
#
#  Mar 16 23:50:25 orthanc kernel: DROP IN=lo OUT= MAC=00:00:00:00:00:00:00:
#  00:00:00:00:00:08:00 SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00
#  TTL=64 ID=0 DF PROTO=TCP SPT=39935 DINDOW=32304 RES=0x00 SYN URGP=0
#
# Note on iptables tcp log messages:
#
#   Iptables reports tcp flags in the following order:
#
#       URG ACK PSH RST SYN FIN
#
###############################################################################
#
# $Id$
#

### modules used by psad
use lib '/usr/lib/psad';
use Psad;
use IPTables::Parse;
use Net::IPv4Addr 'ipv4_in_network';
use File::stat 'stat';
use File::Copy;
use File::Path;
use Date::Calc qw(Timezone This_Year Decode_Month);
use Getopt::Long 'GetOptions';
use Socket;
use Sys::Hostname 'hostname';
use POSIX;
use IO::Handle;
use Data::Dumper;
use strict;

### ========================== main =================================

### set current the psad version number
my $version = '1.2';

### default config file for psad (can be changed with
### --config switch)
my $config_file  = '/etc/psad/psad.conf';

### disable debugging by default
my $debug = 0;

### we don't yet know which type of firewall we are
### running on; this will be calculated by check_scan()
### when the first dropped packet hits the firewall and
### we can examine the logging format.
my $use_ipchains = 0;
my $use_iptables = 0;

my $chk_ipt_chains = 0;
my $flush_fw       = 0;

### Cache the default table->chain relationships used
### by the auto blocking code for iptables firewalls.
### The nat and mangle PREROUTING chains will be added
### by get_iptables_chains() if they are active.
my %ipt_chains;

### define the input chains for ipchains firewalls (this
### is very simplistic).
my @ipchains_chains = qw(input);

### configuration hash
my %config;

### commands hash
my %cmds;

### array for packets logged by the firewall
my @fw_packets;

### main psad data structure; contains ips, port ranges,
### protocol info, tcp flags, etc.
my %scan;

### cache scan danger levels
my %scan_dl;

### cache executions of external script (only used if
### ENABLE_EXT_SCRIPT_EXEC is set to 'Y');
my %scan_ext_exec;

### cache passive os fingerprinting information
my %posf;

### cache passive os fingerprinting signature information
my %posf_sigs;

### cache all scan signatures (initialized by default)
my %sigs;

### Cache snort rule messages if --snort-sids switch was
### given.  This is only useful if iptables includes rule
### that log things like "SID123".  "fwsnort"
### (http://www.cipherdyne.org/fwsnort/) will automatically
### build such a ruleset from snort signatures.
my %snort_msgs;

### cache signature info that can be check quickly against
### single hash keys
my %sigs_fast;

### cache signature messages, danger levels, etc.
my %sigs_attr;

### data array used for dshield.org logs
my @dshield_data;

### track the last time we sent an alert to dshield.org
my $last_dshield_alert;

### get the current timezone for dshield (this is calculated
### and re-calculated since the timezone may change).
my $timezone;

### get the current year for dshield
my $year;

### %auto_ips holds all ip addresses that should automatically
### be assigned a danger level (or ignored).  (Only initialized
### if the "-a <auto ips file>" is specified on the command line).
my %auto_ips;

### cache the source ips that we have automatically blocked
### (if ENABLE_AUTO_IDS == 'Y')
my %auto_blocked_ips;

### cache the addresses we have executed whois lookups for
my %whois_cache;

### cache ports the local machine is listening on (periodically
### updated by get_listening_ports()).
my %local_ports;

### cache the ip addresses associated with each interface on the
### local machine.
my %local_ips;

### regex to match an ip address
my $ip_re = '(?:\d{1,3}\.){3}\d{1,3}';

### psad logging hash
my %log_hsh;

### ttl values are decremented depending on the number of hops
### the packet has taken before it hits the firewall.  We will
### assume packets will not jump through more than 20 hops on
### average.
my $max_hops = 20;

### packet counters
my $tcp_ctr  = 0;
my $udp_ctr  = 0;
my $icmp_ctr = 0;

### pid file hash
my %pidfiles;

### initialize and scope some default variables (command
### line args can override some default values)
my $sigs_file        = '';
my $posf_file        = '';
my $autoips_file     = '';
my $snort_rules_dir  = '';
my $srules_type      = '';
my $psad_logfile     = '';
my $cmdline_file     = '';
my $snort_sids       = 0;
my $output           = 0;
my $syslog_server    = 0;
my $kill             = 0;
my $restart          = 0;
my $status           = 0;
my $status_ip        = '';
my $benchmark        = 0;
my $b_packets        = 0;
my $usr1             = 0;
my $hup              = 0;
my $usr1_flag        = 0;
my $hup_flag         = 0;
my $ver              = 0;
my $help             = 0;
my $dump_conf        = 0;
my $chk_interval     = 0;
my $netstat_lkup_ctr = 0;
my $log_len          = 23;  ### used in scan_logr()
my $fw_analyze       = 0;

### these flags are used to disable several features
### in psad if specified from the command line
my $no_signatures = 0;
my $no_auto_ips   = 0;
my $no_posf       = 0;
my $no_daemon     = 0;
my $no_ipt_errors = 0;
my $no_rdns       = 0;
my $no_whois      = 0;
my $no_netstat    = 0;
my $no_fwcheck    = 0;

### old command line options
my $oldarg_autoips;
my $oldarg_errs;
my $oldarg_nerrs;
my $oldarg_nerrs2;
my $oldarg_rdns;
my $oldarg_nrdns;
my $oldarg_whois;
my $oldarg_nwhois;
my $oldarg_netstat;
my $oldarg_nlport;
my $oldarg_fwcheck;
my $oldarg_nfwchk;
my $oldarg_daemon;
my $oldarg_logserv;

### used in --Benchmark test
my $b_time;
my $test_pkt;
my $test_pktend;

### get the hostname of the machine
my $hostname = hostname;

### save a copy of the command line arguments
my @args_cp = @ARGV;

### make Getopts case sensitive
Getopt::Long::Configure('no_ignore_case');

&usage(1) unless (GetOptions(
    'signatures=s'      => \$sigs_file,       # Path to psad signatures file.
    'passive-os-sigs=s' => \$posf_file,       # Path to passive os fingerprinting
                                              # signatures.
    'snort-sids'        => \$snort_sids,      # Enable search for snort SID's
                                              # in iptables messages.
    'snort-type=s'      => \$srules_type,     # Only process snort rules of
                                              # this type (e.g. "ddos" or
                                              # "backdoor").
    'snort-rdir=s'      => \$snort_rules_dir, # Specify a directory for snort
                                              # rules.
    'auto-ips=s'        => \$autoips_file,    # Path to psad auto ips file for
                                              # auto-setting ip danger level.
    'output'            => \$output,          # Write scanlog messages to STDOUT.
    'debug'             => \$debug,           # Run in debug mode.
    'Dump-conf'         => \$dump_conf,       # Dump config and exit.
    'interval=i'        => \$chk_interval,    # Set $chk_interval from the
                                              # command line.
    'config=s'          => \$config_file,     # Specify configuration file.
    'fw-check'          => \$fw_analyze,      # Analyze the firewall ruleset and
                                              # exit.
    'logfile=s'         => \$psad_logfile,    # The psad logfile.
    'log-server'        => \$syslog_server,   # We are running psad on a syslog
                                              # logging server.
    'Kill'              => \$kill,            # Kill all running psad processes.
                                              # (psadwatchd, psad, kmsgsd,
                                              # diskmond).
    'Restart'           => \$restart,         # Restart psad with all options of
                                              # the currently running psad process.
    'Flush'             => \$flush_fw,        # Flush any rules that psad previously
                                              # added via the auto blocking code.
    'Status'            => \$status,          # Display status of any currently
                                              # running psad processes.
    'ip-status=s'       => \$status_ip,       # Display status for a specific ip.
    'Benchmark'         => \$benchmark,       # Run in benchmark mode.
    'packets=i'         => \$b_packets,       # Specify number of packets to use
                                              # in benchmark test.
    'USR1'              => \$usr1,            # Send an existing psad process a
                                              # USR1 signal (useful for debugging).
    'HUP'               => \$hup,             # Send psad processes a HUP signal
                                              # to re-import config.
    'no-whois'          => \$no_whois,        # Do not issue whois lookups against
    'no-passiveos'      => \$no_posf,         # Do not attempt to passively
                                              # fingerprint the remote OS.
    'no-signatures'     => \$no_signatures,   # Disable signature processing.
    'no-auto-ips'       => \$no_auto_ips,     # Disable auto danger level
                                              # assignment.
    'no-daemon'         => \$no_daemon,       # Do not run as a daemon.
    'no-fwcheck'        => \$no_fwcheck,      # Do not check firewall rules.
    'no-rdns'           => \$no_rdns,         # Do not issue dns lookups against
                                              # Scanning ip address.
    'no-localport'      => \$no_netstat,      # Do not check to see if the
                                              # firewall is listening on localport
                                              # that has been scanned.
    'no-ipt-errors'     => \$no_ipt_errors,   # Do not write malformed packet.
                                              # messages to error log.
    'Version'           => \$ver,             # Print the psad version and exit.
    'help'              => \$help,            # Display help.
    ### old args
    'Logging_server'     => \$oldarg_logserv, # old command line arg
#    'Daemon'             => \$oldarg_daemon, # old command line arg
    'firewallcheck'      => \$oldarg_fwcheck, # old command line arg
    'no_fw_check'        => \$oldarg_nfwchk,  # old command line arg
    'reversedns'         => \$oldarg_rdns,    # old command line arg
    'localport'          => \$oldarg_netstat, # old command line arg
    'errors'             => \$oldarg_errs,    # old command line arg
    'no_errors'          => \$oldarg_nerrs,   # old command line arg
    'no-errors'          => \$oldarg_nerrs2,  # old command line arg
    'whois'              => \$oldarg_whois,   # old command line arg
    'no_whois'           => \$oldarg_nwhois,  # old command line arg
    'no_rdns'            => \$oldarg_nrdns,   # old command line arg
    'no_localport'       => \$oldarg_nlport,  # old command line arg
));
&usage(0) if $help;

### Print the version number and exit if -V given on the command line.
if ($ver) {
    print " .. psad v$version, by Michael Rash ",
        "<mbr\@cipherdyne.org>\n";
    exit 0;
}

if ($status_ip && ! $status) {
    die ' ** The --ip option can only be specified along with ',
        'the --Status option.  Exiting.';
}

### check for any old command line arguements
&check_old_cmdargs();

### Everthing after this point must be executed as root.
$< == 0 && $> == 0 or
    die ' ** psad: You must be root (or equivalent ',
        "UID 0 account) to execute psad!  Exiting.\n";

### Import all psad configuration and signatures files
### (psad.conf, psad_posf, psad_signatures, and psad_auto_ips).
&import_configs();

### check to make sure another psad process is not already running.
&Psad::unique_pid($config{'PSAD_PID_FILE'});

### get the ip addresses that are local to this machine
&get_local_ips();

### disable whois lookups if for some reason the whois client that is
### bundled with psad can't be found
unless ($no_whois) {
    unless (defined $cmds{'whois'}
            && -x $cmds{'whois'}) {  ### we couldn't find whois_psad
        warn ' ** Could not locate whois_psad binary.  ',
            "Disabling whois lookups.\n";
        $no_whois = 1;
    }
}

### if psad is running on a syslog server, don't check the firewall
### rules since they may not be local.
&fw_check() unless $no_fwcheck || $syslog_server;

### initialize benchmarking test packets if we are running
### in benchmark mode
if ($benchmark) {
    $test_pkt = 'Feb 15 16:42:58 orthanc kernel: DROP IN=eth0 ' .
        'OUT= MAC=00:a0:cc:28:42:5a:00:03:6c:00:98:54:08:00 ' .
        'SRC=10.0.0.1 DST=10.0.0.2 LEN=48 TOS=0x00 PREC=0x00 ' .
        'TTL=110 ID=13383 DF PROTO=TCP SPT=1389 DPT=';
    $test_pktend = 'WINDOW=16384 RES=0x00 SYN URGP=0';
}

### let the user know where email alerts will be sent
print STDOUT " .. psad started; email alerts will be sent to:\n",
    " ----> $config{'EMAIL_ADDRESSES'}\n";

### daemonize psad unless running with --no_daemon or --debug
unless ($no_daemon || $debug || $benchmark) {
    my $pid = fork();
    exit if $pid;
    die " ** $0: Couldn't fork: $!" unless defined $pid;
    POSIX::setsid() or die " ** $0: Can't start a new session: $!";
}

### write the current pid associated with psad to the psad pid file
&Psad::writepid($config{'PSAD_PID_FILE'});

### write the command line args used to start psad to $cmdline_file
&Psad::writecmdline(\@args_cp, $cmdline_file);

### psad _requires_ that kmsgsd is running to receive any data, so let's
### start it here for good measure (as of 0.9.2 it makes use of the pid
### files and unique_pid(), so we don't have to worry about starting a
### duplicate copy).  While we're at it, start psadwatchd and diskmond too.
### Note that this is the best place to start the other daemons since we
### just wrote the psad pid to PSAD_PID_FILE above.
if ($config_file eq '/etc/psad/psad.conf') {
    unless ($benchmark) {
        system $cmds{'kmsgsd'};
        system $cmds{'diskmond'};
        system $cmds{'psadwatchd'} unless $debug;
    }
} else {
    ### start the other daemons with the new (non-default) config file
    unless ($benchmark) {
        system "$cmds{'kmsgsd'} $config_file";
        system "$cmds{'diskmond'} $config_file";
        system "$cmds{'psadwatchd'} $config_file" unless $debug;
    }
}

### Check to see if psad automatically blocked some ips from
### a previous run.  This feature is most useful for preserving
### auto-block rules ips after a reboot or after restarting
### psad.
&renew_auto_blocked_ips() if $config{'ENABLE_AUTO_IDS'} eq 'Y';

### archive old firewall and scan data
&archive_data() unless $benchmark;

### Install signal handlers for debugging %scan with Data::Dumper,
### and for reaping zombie whois processes.  Only install signal
### handlers if we are not running in benchmark mode
unless ($benchmark) {
    $SIG{'__WARN__'} = \&Psad::warn_handler;
    $SIG{'__DIE__'}  = \&Psad::die_handler;
    $SIG{'CHLD'}     = \&REAPER;
    $SIG{'USR1'}     = \&usr1_handler;
    $SIG{'HUP'}      = \&hup_handler;
}

### zero out the packet counter file (the counters
### are all zero at this point anyway).
&write_global_packet_counters();

if ($benchmark) {
    print localtime() . " .. Entering benchmark mode.\n";
    $no_rdns  = 1;  ### turn off network related functions
    $no_whois = 1;
    if ($b_packets) {
        print localtime() . " .. Executing a $b_packets packet test.\n";
    } else {
        print localtime() . ' .. The --packets command line ',
            "option was not specified.\n";
        print localtime() . " .. Defaulting to a 10,000 packet test.\n";
        $b_packets = 10000;
    }
}

if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
    $last_dshield_alert = time() unless $last_dshield_alert;
}

### Get an open filehandle for the main firewall data file FW_DATA_FILE.
### All firewall drop/deny/reject log messages are written to FW_DATA_FILE
### by kmsgsd.
open FWDATA, $config{'FW_DATA_FILE'} or die ' ** Could not open ',
    "$config{'FW_DATA_FILE'}: $!" unless $benchmark;

###=========================================================###
######                    MAIN LOOP                      ######
###=========================================================###
for (;;) {

    if ($hup_flag) {
        $hup_flag = 0;  ### clear the HUP flag

        &Psad::psyslog('psad', 'Received HUP signal, ' .
            're-importing psad.conf');

        my $orig_fwdata = $config{'FW_DATA_FILE'};
        ### Re-import all used config files (psad.conf, psad_auto_ips,
        ### psad_posf, psad_signatures) if we received a HUP signal.
        &import_configs();

        if ($orig_fwdata ne $config{'FW_DATA_FILE'}) {
            close FWDATA;
            ### zero out the new fwdata file just in case (the path
            ### has changed).
            open FWDATA, "> $config{'FW_DATA_FILE'}" or die $!;
            close FWDATA;

            ### re-open the fwdata file
            open FWDATA, $config{'FW_DATA_FILE'} or die
                " ** Could not open $config{'FW_DATA_FILE'}: $!"
        }
    }

    ### See if we need to print out the %scan datastructure
    ### (we received a USR1 signal)
    if ($usr1_flag) {
        $usr1_flag = 0;  ### clear the USR1 flag

        &Psad::psyslog('psad', 'Received USR1 signal, printing scan hashes ' .
            "to $config{'PSAD_DIR'}/scan_hash.$$");
        &print_scan();
    }

    ### clear the firewall data array
    @fw_packets = ();

    ### Get any new packets have been written to
    ### FW_DATA_FILE by kmsgsd for psad analysis.
    if ($benchmark) {
        $b_time = time();
        print localtime() . " .. Creating packet array.\n";
        my $dp = 1000;
        for (my $i=0; $i <= $b_packets; $i++) {
            ### avert "." operator
            push @fw_packets, "$test_pkt DPT=$dp $test_pktend";
            $dp++ if $dp < 50000;
        }
    } else {
        @fw_packets = <FWDATA>;
    }
    if (@fw_packets) {
        print localtime() . " .. check_scan()\n" if $benchmark;

        if (&check_scan()) {
            print localtime() . " .. assign_danger_level()\n"
                if $benchmark;
            ### Assign a danger level to the scan
            &assign_danger_level();

            print localtime() . " .. scan_logr()\n" if $benchmark;
            ### Log and send email and syslog alerts
            &scan_logr();

            ### Don't manage the firewall rules if
            ### psad is running on a syslog server
            if ($config{'ENABLE_AUTO_IDS'} eq 'Y' &&
                ! $syslog_server) {
                &auto_psad_response();
            }
        }
        ### write the number of tcp/udp/icmp packets out
        ### to the global packet counters file
        &write_global_packet_counters();
    }
    ### timeout any auto-blocked ips that are past due
    if ($config{'ENABLE_AUTO_IDS'} eq 'Y'
            && $config{'AUTO_BLOCK_TIMEOUT'} > 0) {
        &timeout_auto_blocked_ips();
    }

    ### send logs to dshield in dshield format
    if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
        &dshield_email_log();
    }

    ### Print the number of new packets we saw in FW_DATA_FILE if we are
    ### running in debug mode
    if ($debug) {
        print "MAIN: number of new packets: $#fw_packets\n";
    }

    if ($benchmark) {
        print localtime() . " .. Packet creation and processing time: ",
            time() - $b_time, " sec.\n";
        print localtime() . " .. Exiting benchmark mode.\n";
        exit 0;
    }

    ### sleep for the check interval number of seconds
    sleep $config{'PSAD_CHECK_INTERVAL'};

    ### clearerr() on the FWDATA filehandle to be ready for new packets
    FWDATA->clearerr() unless $benchmark;
}
exit 0;
###=========================================================###
######                    END MAIN                       ######
###=========================================================###

#=================== BEGIN SUBROUTINES ========================

### Keeps track of scanning ip's, increments packet counters,
### keep track of tcp flags for each scan (iptables only),
### test for snort sid values in iptables packets (if fwsnort
### is being used).
sub check_scan() {
    my @bad_packets;
    my $flags = 'NULL';
    my $src;
    my $dst;
    my $len;
    my $tos;
    my $ttl;
    my $id;
    my $proto;
    my $sp;
    my $dp;
    my $win;
    my $type;
    my $code;
    my $seq;
    my $matched_packet = 0;

    ### If necessary, check which firewall (ipchains vs. iptables)
    unless ($use_ipchains || $use_iptables) {
        &get_fw_type($fw_packets[0]);
    }
    unless ($no_netstat) {
        if ($netstat_lkup_ctr == 10) {
            ### we don't expect the list of ports the machine is listening
            ### on to change very often.
            &get_listening_ports();
            $netstat_lkup_ctr = 0;
        } else {
            $netstat_lkup_ctr++;
        }
    }
    if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
        ### calculate the timezone offset
        $timezone = sprintf("%.2d", (Timezone())[3]) . ':00';
        $year     = This_Year();
    }
    PKT: for my $pkt (@fw_packets) {
        chomp $pkt;
        my $sid = 0;
        my $dshield_str = '';
        print STDOUT $pkt, "\n" if $debug;
        if ($use_iptables) {
            if ($snort_sids) {
                if ($pkt =~ /$config{'SNORT_SID_STR'}(\d+)\s+IN/) {
                    $sid = $1;
                }
            }
            ### May 18 22:21:26 orthanc kernel: DROP IN=eth2 OUT=
            ### MAC=00:60:1d:23:d0:01:00:60:1d:23:d3:0e:08:00 SRC=192.168.20.25
            ### DST=192.168.20.1 LEN=60 TOS=0x10 PREC=0x00 TTL=64 ID=47300 DF
            ### PROTO=TCP SPT=34111 DPT=6345 WINDOW=5840 RES=0x00 SYN URGP=0
            if ($pkt =~ /SRC=(\S+)\s+DST=(\S+)\s+LEN=(\d+)\s+TOS=(\S+)
                        \s*.*\s+TTL=(\d+)\s+ID=(\d+)\s*.*\s+PROTO=TCP\s+
                        SPT=(\d+)\s+DPT=(\d+)\s+WINDOW=(\d+)\s+
                        RES=\S+\s*(.*)\s+URGP=/x) {
                ($src, $dst, $len, $tos, $ttl, $id, $sp, $dp, $win, $flags) =
                    ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
                $proto = 'TCP';
                $flags = 'NULL' unless $flags;  ### default to NULL
                print STDOUT " .. matched packet: src: $src, dst: $dst, " .
                    "len: $len\n    sp: $sp dp: $dp, proto: $proto, flags: " .
                    "$flags\n" if $debug;
                if (!$sid && $config{'IGNORE_CONNTRACK_BUG_PKTS'} eq 'Y' &&
#                    $dp > 1024 && ($flags =~ /ACK/ ||
                        ($flags =~ /ACK/ || $flags =~ /RST/)) {
                    ### XXX ignore TCP packets that have the ACK or RST
                    ### bits set (unless we matched a snort sid) since
                    ### _usually_ we see these packets as a result of the
                    ### iptables connection tracking bug.  Also, note that
                    ### no signatures make use of the RST flag and very
                    ### few that use the ACK flag (need to add code back
                    ### in for these signatures).
                    next PKT;
                }
                ### per page 595 of the Camel book, "if /blah1|blah2/"
                ### can be slower than "if /blah1/ || /blah2/
                unless ($flags !~ /WIN/ &&
                        $flags =~ /URG/ ||
                        $flags =~ /ACK/ ||
                        $flags =~ /PSH/ ||
                        $flags =~ /RST/ ||
                        $flags =~ /SYN/ ||
                        $flags =~ /FIN/ ||
                        $flags eq 'NULL') {
                    push @bad_packets, $pkt;
                    next PKT;
                }
                if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
                    my $dflags = $flags;
                    $dflags =~ s/\s/,/g;
                    $dshield_str = "$src\t$sp\t$dst\t$dp\t$proto\t$dflags";
                }
                $tcp_ctr++;
            ### May 18 22:21:26 orthanc kernel: DROP IN=eth2 OUT=
            ### MAC=00:60:1d:23:d0:01:00:60:1d:23:d3:0e:08:00
            ### SRC=192.168.20.25 DST=192.168.20.1 LEN=28 TOS=0x00 PREC=0x00
            ### TTL=40 ID=47523 PROTO=UDP SPT=57339 DPT=305 LEN=8
            } elsif ($pkt =~ /SRC=(\S+)\s+DST=(\S+)\s+LEN=(\d+)\s+TOS=(\S+)
                              \s.*TTL=(\d+)\s+ID=(\d+)\s*.*\s+PROTO=UDP\s+
                              SPT=(\d+)\s+DPT=(\d+)/x) {
                ($src, $dst, $len, $tos, $ttl, $id, $sp, $dp) =
                    ($1,$2,$3,$4,$5,$6,$7,$8);
                $proto = 'UDP';
                print STDOUT "matched packet: src: $src, dst: $dst, len: " .
                    "$len, sp: $sp\n    dp: $dp, proto: $proto\n" if $debug;
                if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
                    $dshield_str = "$src\t$sp\t$dst\t$dp\t$proto";
                }
                $udp_ctr++;
            } elsif ($pkt =~ /SRC=(\S+)\s+DST=(\S+)\s+LEN=(\d+).*
                              TTL=(\d+).*PROTO=ICMP\s+TYPE=(\d+)\s+
                              CODE=(\d+)\s+ID=(\d+)\s+SEQ=(\d+)/x) {
                ($src, $dst, $len, $ttl, $type, $code, $id, $seq) =
                    ($1,$2,$3,$4,$5,$6,$7,$8);
                $proto = 'ICMP';
                $icmp_ctr++;
                if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
                    $dshield_str = "$src\t$type\t$dst\t$code\t$proto";
                }
                print STDOUT "matched patcket: src: $src, dst: $dst, len: " .
                    "proto: $proto\n" if $debug;
            } else {
                ### Sometimes the iptables log entry gets messed up due to
                ### buffering issues so we write it to the error log.
                push @bad_packets, $pkt;
                next PKT;
            }
            if ($config{'ENABLE_DSHIELD_ALERTS'} eq 'Y') {
                if ($pkt =~ /^\s*(\w+)\s+(\d+)\s+(\S+)/) {
                    my $month   = Decode_Month($1);
                    my $day     = sprintf("%.2d", $2);
                    my $time_24 = $3;
                    push @dshield_data, "$year-$month-$day $time_24 " .
                        "$timezone\t$config{'DSHIELD_USER_ID'}\t1" .
                        "\t$dshield_str\n";
                }
            }
        } elsif ($use_ipchains) {
            ### could implement source port checking here
            if ($pkt =~ /PROTO\=(\d+)\s($ip_re):(\d+)\s($ip_re):(\d+)/) {
                ($proto, $src, $sp, $dst, $dp) = ($1,$2,$3,$4,$5);
                ### should implement protocol mapping
                ### with /etc/protocols here
                if ($proto == 1) {
                    $proto = 'ICMP';
                    $icmp_ctr++;
                } elsif ($proto == 6) {
                    $proto = 'TCP';
                    $tcp_ctr++;
                } elsif ($proto == 17) {
                    $proto = 'UDP';
                    $udp_ctr++;
                }
                $flags = 'NONE';
            } else {
                push @bad_packets, $pkt;
                next PKT;
            }
        }

        ### see if we need to timeout any old scans
        if ($config{'ENABLE_PERSISTENCE'} eq 'N') {
            if (defined $scan{$src}{$dst}{'S_TIME'}) {
                if ((time() - $scan{$src}{$dst}{'S_TIME'})
                        >= $config{'SCAN_TIMEOUT'}) {
                    delete $scan{$src}{$dst};
                }
            }
        }

        ### scan hash initialization; if we made it here then we matched
        ### packets that the firewall logged (and maybe dropped).
        $matched_packet = 1;

        ### initialize the danger level to 0 if it is not already defined
        unless (defined $scan_dl{$src}) {
            $scan_dl{$src} = 0;
        }

        ### we will always send an alert email for any new "bad" packet
        ### if $ALERT_ALL eq "Y"... Else email sent only if the scan
        ### increments its danger level or trips a signature
        if ($config{'ALERT_ALL'} eq 'Y') {
            $scan{$src}{$dst}{'ALERTED'} = 0;
        }

        ### record the absolute starting time of the scan
        unless (defined $scan{$src}{$dst}{'S_TIME'}) {
            $scan{$src}{$dst}{'S_TIME'} = time();
        }

        ### increment hash values
        $scan{$src}{$dst}{'ABSNUM'}++;
        $scan{$src}{$dst}{$proto}{'C_INT'}{'PKTS'}++;
        $scan{$src}{$dst}{$proto}{'PKTS'}++;

        ### keep track of tcp flags
        $scan{$src}{$dst}{'TCP'}{'C_INT'}{'FLAGS'}{$flags}++
            if $proto eq 'TCP';

        ### initialize the start and end port for the scanned port range
        unless ($proto eq 'ICMP' ||
                defined $scan{$src}{$dst}{$proto}{'ABS_SP'}) {
            ### This is the absolute starting port since the
            ### first packet was detected.  Make sure the initial
            ### start port is not too low
            $scan{$src}{$dst}{$proto}{'ABS_SP'} = 65535;
            ### make sure the initial end port is not too high
            $scan{$src}{$dst}{$proto}{'ABS_EP'} = 0;
        }

        ### initialize values for the current interval
        unless ($proto eq 'ICMP' ||
                defined $scan{$src}{$dst}{$proto}{'C_INT'}{'SP'}) {
            ### make sure the initial start port is not too low
            $scan{$src}{$dst}{$proto}{'C_INT'}{'SP'} = 65535;
            ### make sure the initial end port is not too high
            $scan{$src}{$dst}{$proto}{'C_INT'}{'EP'} = 0;
        }

        ### see if the destination port lies outside our current range
        ### and change if needed
        unless ($proto eq 'ICMP') {
            ($scan{$src}{$dst}{$proto}{'ABS_SP'},
                $scan{$src}{$dst}{$proto}{'ABS_EP'}) = &check_range($dp,
                    $scan{$src}{$dst}{$proto}{'ABS_SP'},
                    $scan{$src}{$dst}{$proto}{'ABS_EP'});
            ($scan{$src}{$dst}{$proto}{'C_INT'}{'SP'},
                $scan{$src}{$dst}{$proto}{'C_INT'}{'EP'}) =
                &check_range($dp,
                    $scan{$src}{$dst}{$proto}{'C_INT'}{'SP'},
                    $scan{$src}{$dst}{$proto}{'C_INT'}{'EP'});
        }
        if ($debug) {
            print STDOUT "check_scan(): src: $src, dst: $dst\n";
            print STDOUT Dumper $scan{$src}{$dst};
        }

        ### attempt to passively guess the remote operating
        ### system based on the ttl, id, len, window, and tos
        ### fields in tcp syn packets (this technique is based
        ### on the paper "Passive OS Fingerprinting: Details
        ### and Techniques" by Toby Miller).
        unless ($no_posf) {
            &posf($src, $len, $tos, $ttl, $id, $win)
                if ($proto eq 'TCP' && $flags =~ /SYN/);
        }

        ### might try to match signatures against ipchains messages
        ### also, but then cannot use tcp flags except for -y -l rules
        next PKT unless $use_iptables;

        if ($snort_sids && $sid) {
            ### found a snort sid in the packet log message
            &add_snort_sid($src, $dst, $proto, $sid);
        } else {
            ### attempt to match any tcp/udp/icmp signatures in the
            ### %sigs_fast hash
            &match_fastsigs($src, $dst, $sp, $dp, $proto,
                $flags, $len, $ttl);

            ### attempt to match any tcp/udp/icmp signatures in the
            ### main signatures hash
            &match_sigs($src, $dst, $sp, $dp, $proto,
                $flags, $len, $ttl, $type, $code, $id, $seq);
        }
    }
    &collect_errors(\@bad_packets) unless $no_ipt_errors;
    return $matched_packet;
}

sub match_fastsigs() {
    my ($src, $dst, $sp, $dp, $proto,
        $flags, $len, $ttl) = @_;
    if ($proto eq 'TCP') {
        if (defined $sigs_fast{'TCP'}{$dp}{$sp}{$flags}) {
            for my $sig_id (keys
                    %{$sigs_fast{'TCP'}{$dp}{$sp}{$flags}}) {
                print "matched: $dp,$sp,$flags, ",
                    "sig_id: $sig_id\n" if $debug;
                unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
#                $scan{$src}{$dst}{$proto}{'CURR_SIG'}{$sig_id}{'PKTS'}++;
                &chk_local_port($src, $dst, 'TCP', $dp, $flags, $sig_id)
                    unless $no_netstat;
            }
        }
        if (defined $sigs_fast{'TCP'}{$dp}{'any_sp'}{$flags}) {
            for my $sig_id (keys
                    %{$sigs_fast{'TCP'}{$dp}{'any_sp'}{$flags}}) {
                print "matched $dp,any_sp,$flags, ",
                    "sig_id: $sig_id\n" if $debug;
                unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                &chk_local_port($src, $dst, 'TCP', $dp, $flags, $sig_id)
                    unless $no_netstat;
            }
        }
        if (defined $sigs_fast{'TCP'}{'any_dp'}{$sp}{$flags}) {
            for my $sig_id (keys
                    %{$sigs_fast{'TCP'}{'any_dp'}{$sp}{$flags}}) {
                print "matched any_dp,$sp,$flags, ",
                    "sig_id: $sig_id\n" if $debug;
                unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                &chk_local_port($src, $dst, 'TCP', $dp, $flags, $sig_id)
                    unless $no_netstat;
            }
        }
        if (defined $sigs_fast{'TCP'}{'any_dp'}{'any_sp'}{$flags}) {
            for my $sig_id (keys
                    %{$sigs_fast{'TCP'}{'any_dp'}{'any_sp'}{$flags}}) {
                print "matched any_dp,any_sp,$flags, ",
                    "sig_id: $sig_id\n" if $debug;
                unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                &chk_local_port($src, $dst, 'TCP', $dp, $flags, $sig_id)
                    unless $no_netstat;
            }
        }
    } elsif ($proto eq 'UDP') {
        if (defined $sigs_fast{'UDP'}{$dp}{$sp}) {
            for my $sig_id (keys %{$sigs_fast{'UDP'}{$dp}{$sp}}) {
                unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                &chk_local_port($src, $dst, 'UDP', $dp, '', $sig_id)
                    unless $no_netstat;
            }
        }
    }
    return;
}

sub match_sigs() {
    my ($src, $dst, $sp, $dp, $proto,
        $flags, $len, $ttl, $type, $code, $id, $seq) = @_;
    for my $sig_id (keys %{$sigs{$proto}}) {
        ### need to iterate through all signatures
        ### since a packet may match several
        my $dp_criteria = 0;
        my $sp_criteria = 0;
        my $matched_sig      = 0;
        if ($proto eq 'TCP') {
            if ($flags eq $sigs{'TCP'}{$sig_id}{'flags'}
                    && &check_port_range($sig_id, $sp,
                $dp, $proto)) {  ### tripped a tcp signature
                ### future
#               && &check_misc_fields($sig_id, $proto, $len, $ttl)) {
                print "main sigs matched $dp,$sp,$flags, ",
                    "sig_id: $sig_id\n" if $debug;
                unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                $matched_sig = 1;
            }
        } elsif ($proto eq 'UDP') {
            if (&check_port_range($sig_id, $sp, $dp, $proto)) {
#               && &check_misc_fields($sig_id, $proto, $len, $ttl)) {
                ### tripped a udp signature
                unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                $matched_sig = 1;
            }
        } elsif ($proto eq 'ICMP') {
            if (&check_icmp_sigs($sig_id, $ttl, $type, $code, $id, $seq)) {
                unless ($scan_dl{$src} >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan_dl{$src} = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                $scan{$src}{$dst}{'ICMP'}{'CURR_SIG'}
                {$sig_id}{'PKTS'}++;
            }
        }
        if ($matched_sig && !$no_netstat) {
            &chk_local_port($src, $dst, $proto, $dp, $flags, $sig_id);
        }
    }
    return;
}

sub posf() {
    my ($src, $len, $tos, $ttl, $id, $win) = @_;
    print STDOUT " .. posf():  $src  LEN: $len, TOS: $tos, TTL: $ttl, ",
        "ID: $id, WIN: $win\n" if $debug;
    return if defined $posf{$src}{'guess'};  ### we already guessed the OS
    $posf{$src}{'len'}{$len}++;
    $posf{$src}{'tos'}{$tos}++;
    $posf{$src}{'ttl'}{$ttl}++;
    push @{$posf{$src}{'id'}}, $id;  ### need to maintain ordering
    $posf{$src}{'win'}{$win}++;
    $posf{$src}{'ctr'}++;

    my $id_incr_rv = -1;
    my $id_str = 'RANDOM';
    my $min_ttl;
    my $max_ttl;
    for my $os (keys %posf_sigs) {
        if ($posf{$src}{'ctr'} >= $posf_sigs{$os}{'numpkts'}
                && $id_incr_rv < 0) {
            $id_incr_rv = &id_incr(\@{$posf{$src}{'id'}});
            $id_str = 'SMALLINCR' if $id_incr_rv;
            ($min_ttl, $max_ttl) = &ttl_range($posf{$src}{'ttl'});
        }
        if ($posf{$src}{'ctr'} >= $posf_sigs{$os}{'numpkts'}
                && defined $posf{$src}{'win'}{$posf_sigs{$os}{'win'}}
                && defined $posf{$src}{'tos'}{$posf_sigs{$os}{'tos'}}
                && defined $posf{$src}{'len'}{$posf_sigs{$os}{'len'}}
                && ($min_ttl > ($posf_sigs{$os}{'ttl'}-$max_hops))
                && ($max_ttl <= $posf_sigs{$os}{'ttl'})
                && $id_str eq $posf_sigs{$os}{'id'}) {
            $posf{$src}{'guess'} = $os;
        }
    }
    return;
}

sub id_incr() {
    my $aref = shift;
    my $rv = 1;  ### 1 => small increments, 2 => random
    for (my $i=0; $i<$#$aref; $i++) {
        $rv = 0 unless ($aref->[$i] < $aref->[$i+1]
            && ($aref->[$i+1] - $aref->[$i]) < 1000);
    }
    return $rv;
}

sub ttl_range() {
    my $href = shift;
    my $min_ttl = 256;
    my $max_ttl = 0;
    for my $ttl (keys %$href) {
        $min_ttl = $ttl if $ttl < $min_ttl;
        $max_ttl = $ttl if $ttl > $max_ttl;
    }
    return $min_ttl, $max_ttl;
}

sub add_snort_sid() {
    my ($src, $dst, $proto, $sid) = @_;
    if (defined $snort_msgs{$sid}) {
        unless ($scan_dl{$src} >= 2) {
            ### for now hardcode snort sid matches at
            ### a danger level of two
            $scan_dl{$src} = 2;
            $scan{$src}{$dst}{'ALERTED'} = 0;
        }
        $scan{$src}{$dst}{$proto}{'SNORT_SID'}{$sid}++;
    }
    return;
}

sub dshield_email_log() {
    ### dshield alert interval is in hours.  Check to see if there are more
    ### than 10,000 lines of log data (and if the last alert was sent more than
    ### two hours later than the previous alert), and if yes send the alert
    ### email.
    if (@dshield_data && ((time() - $last_dshield_alert)
            >= 3600*$config{'DSHIELD_ALERT_INTERVAL'})
            || (($#dshield_data > 10000)
            && ((time() - $last_dshield_alert) >= 2*3600))) {
        my $subject = "FORMAT DSHIELD USERID $config{'DSHIELD_USER_ID'} " .
            "TZ $timezone psad Version 1.2";
        if ($config{'DSHIELD_USER_EMAIL'} eq 'NONE') {
            open MAIL, qq(| $cmds{'mail'} -s "$subject" ) .
                $config{'DSHIELD_ALERT_EMAIL'} or die ' ** Could not send ',
                'dshield alert email.';
            print MAIL for @dshield_data;
            close MAIL;
        } else {
            open MAIL, "| $cmds{'sendmail'} -oi -t" or die ' ** Could not ',
                'send dshield alert email.';
            print MAIL "From: $config{'DSHIELD_USER_EMAIL'}\n";
            print MAIL "To: $config{'DSHIELD_ALERT_EMAIL'}\n";
            print MAIL "Subject: $subject\n";
            print MAIL for @dshield_data;
            print STDOUT "sendmail: $_" for @dshield_data;
            close MAIL;
        }

        &Psad::psyslog('psad', "sent $#dshield_data lines of log data to " .
            $config{'DSHIELD_ALERT_EMAIL'});

        ### store the current time
        $last_dshield_alert = time();

        ### clear the dshield data array so we don't re-send
        ### any data.
        @dshield_data = ();
    }
    return;
}

sub chk_local_port() {
    my ($src, $dst, $proto, $dp, $flags, $sig_id) = @_;
    ### check to see if the scan destination ip is directed
    ### at the firewall.  If yes, then check to see if a
    ### server is listening on the DSTPORT by parsing
    ### netstat output.  If not, psad would have to connect
    ### to the destination port on the remote machine, but
    ### of course it should not do this so it is not
    ### implemented. :)
    if (defined $local_ips{$dst}) {
        if (defined $local_ports{$proto}{$dp}) {
            $scan{$src}{$dst}{$proto}{'CURR_SIG'}
            {$sig_id}{'LISTEN'}{$dp}{'PKTS'}++;
            if ($flags) {
                $scan{$src}{$dst}{$proto}{'CURR_SIG'}
                {$sig_id}{'LISTEN'}{$dp}{'FLAGS'}
                    = $flags;
            }
        } else {
            $scan{$src}{$dst}{$proto}{'CURR_SIG'}
            {$sig_id}{'NO_LISTEN'}{$dp}{'PKTS'}++;
            if ($flags) {
                $scan{$src}{$dst}{$proto}{'CURR_SIG'}
                {$sig_id}{'NO_LISTEN'}{$dp}{'FLAGS'}
                    = $flags;
            }
        }
    }
    return;
}

sub check_port_range() {
    my ($sig_id, $sp, $dp, $proto) = @_;
    ### check dst port first
    if (defined $sigs{$proto}{$sig_id}{'dp'}{'uniq_or_any'}) {
        unless ($sigs{$proto}{$sig_id}{'dp'}{'uniq_or_any'} eq 'any') {
            if ($dp != $sigs{$proto}{$sig_id}{'dp'}{'uniq_or_any'}) {
                return 0;
            }
        }
    }
    if (defined $sigs{$proto}{$sig_id}{'dp'}{'start'}) {
        my $start = $sigs{$proto}{$sig_id}{'dp'}{'start'};
        my $end = $sigs{$proto}{$sig_id}{'dp'}{'end'};
        return 0 if ($dp < $start || $dp > $end);
    }
    if (defined $sigs{$proto}{$sig_id}{'dp'}{'not'}) {
        return 0 if ($dp == $sigs{$proto}{$sig_id}{'dp'}{'not'});
    }
    if (defined $sigs{$proto}{$sig_id}{'dp'}{'negstart'}) {
        my $start = $sigs{$proto}{$sig_id}{'dp'}{'negstart'};
        my $end = $sigs{$proto}{$sig_id}{'dp'}{'negend'};
        return 0 if ($dp > $start || $dp < $end);
    }

    ### check src port
    if (defined $sigs{$proto}{$sig_id}{'sp'}{'uniq_or_any'}) {
        unless ($sigs{$proto}{$sig_id}{'sp'}{'uniq_or_any'} eq 'any') {
            if ($dp != $sigs{$proto}{$sig_id}{'sp'}{'uniq_or_any'}) {
                return 0;
            }
        }
    }
    if (defined $sigs{$proto}{$sig_id}{'sp'}{'start'}) {
        my $start = $sigs{$proto}{$sig_id}{'sp'}{'start'};
        my $end = $sigs{$proto}{$sig_id}{'sp'}{'end'};
        return 0 if ($sp < $start || $sp > $end);
    }
    if (defined $sigs{$proto}{$sig_id}{'sp'}{'not'}) {
        return 0 if ($sp == $sigs{$proto}{$sig_id}{'sp'}{'not'});
    }
    if (defined $sigs{$proto}{$sig_id}{'sp'}{'negstart'}) {
        my $start = $sigs{$proto}{$sig_id}{'sp'}{'negstart'};
        my $end   = $sigs{$proto}{$sig_id}{'sp'}{'negend'};
        return 0 if ($sp > $start || $sp < $end);
    }
    ### if we made it to here, then we matched both
    ### the src and dst port criteria
    return 1;
}

sub check_icmp_sigs() {
    my ($sig_id, $ttl, $type, $code, $icmp_id, $icmp_seq) = @_;
    ### check icmp type first
    if (defined $sigs{'ICMP'}{$sig_id}{'type'}) {
        return 0 if ($sigs{'ICMP'}{$sig_id}{'type'} != $type);
    }
    if (defined $sigs{'ICMP'}{$sig_id}{'ttl'}) {
        return 0 if ($sigs{'ICMP'}{$sig_id}{'ttl'} != $ttl);
    }
    if (defined $sigs{'ICMP'}{$sig_id}{'code'}) {
        return 0 if ($sigs{'ICMP'}{$sig_id}{'code'} != $code);
    }
    if (defined $sigs{'ICMP'}{$sig_id}{'icmp_id'}) {
        return 0 if ($sigs{'ICMP'}{$sig_id}{'icmp_id'} != $icmp_id);
    }
    if (defined $sigs{'ICMP'}{$sig_id}{'seq'}) {
        return 0 if ($sigs{'ICMP'}{$sig_id}{'icmp_seq'} != $icmp_seq);
    }
    return 1;  ### if we got to this point, then we matched the signature
}

sub check_misc_fields() {
    my ($msg, $proto, $len, $ttl) = @_;
    if (defined $sigs{$proto}{$msg}{'LEN'}) {
        return 0 if ($sigs{$proto}{$msg}{'LEN'} != $len);
    }
    if (defined $sigs{$proto}{$msg}{'TTL'}) {
        return 0 if ($sigs{$proto}{$msg}{'TTL'} != $ttl);
    }
    return 1;
}

sub import_configs() {

    ### import psad.conf
    &Psad::buildconf(\%config, \%cmds, $config_file);

    ### make sure all necessary configuration variables
    ### are defined
    &required_vars();

    ### make sure the values in the config file make sense
    &validate_config();

    ### check to make sure the commands specified in the config section
    ### are in the right place, and attempt to correct automatically if not.
    &Psad::check_commands(\%cmds);

    ### set some config variables based on command line input
    &handle_cmdline();

    ### make sure PSAD_DIR, FW_DATA_FILE, and /var/lib/psad/psadfifo, etc.
    ### actually exist
    &setup();

    ### dump configuration to STDOUT
    exit &dump_conf() if $dump_conf;

    ### The --Kill command line switch was given.
    exit &stop_psad() if $kill;

    ### The --Flush command line switch was given.
    exit &flush_auto_blocked_ips() if $flush_fw;

    ### The --USR1 command line switch was given.
    exit &usr1() if $usr1;

    ### The --HUP command line switch was given.
    exit &hup() if $hup;

    ### the --Status command line switch was given
    exit &status() if $status;

    ### the --Restart command line switch was given
    exit &restart() if $restart;

    &Psad::psyslog('psad', '.. starting psad ..');

    ### import psad signatures (XXX: these should be taken directly
    ### from the snort signatures instead)
    &import_signatures() unless $no_signatures;

    ### import passive OS fingerprinting signatures
    &import_posf_sigs() unless $no_posf;

    ### import psad_auto_ips file for automatic ip/network danger
    ### level assignment
    &import_auto_ips() unless $no_auto_ips;

    ### parse snort rules if we enable psad to match on iptables log
    ### messages that include snort SID's
    &import_snort_rules() if $snort_sids;

    return;
}

sub validate_config() {
    die ' ** PORT_RANGE_SCAN_THRESHOLD must be between 1 and 65535 '
        unless (&is_digit($config{'PORT_RANGE_SCAN_THRESHOLD'})
            && 0 < $config{'PORT_RANGE_SCAN_THRESHOLD'}
            && $config{'PORT_RANGE_SCAN_THRESHOLD'} < 65535);

    die qq( ** Invalid EMAIL_ADDRESSES value: "$config{'EMAIL_ADDRESSES'}")
        unless $config{'EMAIL_ADDRESSES'} =~ /\S+\@\S+/;
    die ' ** DSHIELD_ALERT_INTERVAL must be between 1 and 24 '
        unless (&is_digit($config{'DSHIELD_ALERT_INTERVAL'})
            && 0 < $config{'DSHIELD_ALERT_INTERVAL'}
            && $config{'DSHIELD_ALERT_INTERVAL'} < 24);
    return;
}

sub is_digit() {
    my $str = shift;
    return 1 if $str =~ m|^\d+$|;
    return 0;
}

sub import_snort_rules() {
    opendir D, $config{'SNORT_RULES_DIR'}
        or die " ** Could not open $config{'SNORT_RULES_DIR'}";
    my @rfiles = readdir D;
    closedir D;
    shift @rfiles; shift @rfiles;

    FILE: for my $rfile (@rfiles) {
        next FILE unless $rfile =~ /\.rules$/;
        if ($srules_type) {
            next FILE unless $rfile =~ /^${srules_type}\.rules$/;
        }
        my ($type) = ($rfile =~ /(\w+)\.rules/);
#        printf("%-30s", " .. $rfile");
#        &logr(" .. Parsing $rfile\n", $logfile);
        open R, "< ${config{'SNORT_RULES_DIR'}}/${rfile}" or
            die " ** Could not open: ${srules_type}/${rfile}";
        my @lines = <R>;
        close R;
        RULE: for my $line (@lines) {
            next RULE unless $line =~ /^alert/;
            chomp $line;
            my $msg;
            my $sid;
            my $classtype;
            my $content;

            ### can't handle multiple content fields
            next RULE if ($line =~ /content:.*content:/);
            next RULE if ($line =~ /content-list:/);

            $msg = $1 if $line =~ /msg:\s*\"(.*?)\"\s*;/;
            $sid = $1 if $line =~ /[\s;]sid:\s*(\d+)\s*;/;
            $classtype = $1 if $line =~ /[\s;]classtype:\s*(.*?)\s*;/;
            $content = $1 if $line =~ /[\s;]uricontent:\s*\"(.*?)\"\s*;/;
            $content = $1 if $line =~ /[\s;]content:\s*\"(.*?)\"\s*;/;
            if ($msg && $sid && $classtype) {
                $snort_msgs{$sid}{'classtype'} = $classtype;
                $snort_msgs{$sid}{'msg'}       = $msg;
                if ($content) {
                    $snort_msgs{$sid}{'content'} = $content;
                }
            }
        }
    }
    print Dumper %snort_msgs if $debug;
    &Psad::psyslog('psad', '.. Imported Snort-2.0 signatures');
    return;
}

sub import_signatures() {
    %sigs = ();  ### undef %sigs so don't leave old signatures around
    open SIGS, "< $config{'PSAD_SIGS_FILE'}" or die
        " ** Could not open the signatures file $config{'PSAD_SIGS_FILE'}: $!";
    my @lines = <SIGS>;
    close SIGS;
    SIG: for my $line (@lines) {
        chomp $line;
        next SIG unless $line;
        next SIG if $line =~ /^\s*#/;
        if ($line =~ /^psad:(\d+);\s*(tcp|udp);\s*(\S+)\s*\-\>\s*(\S+);\s*
                       msg:\s*\"(.*)\";\s*(.*)\s*dlevel:\s*(\d);$/x) {
            my $sig_id  = $1;
            my $proto   = $2;
            my $sp      = $3;
            my $dp      = $4;
            my $msg_str = $5;
            my $options = $6;
            my $dlevel  = $7;

            ### change protocol to uppercase to match firewall log messages
            $proto = uc $proto;

            ### add the signature message string to the %sig_attr cache
            $sigs_attr{$sig_id}{'dlevel'} = $dlevel;
            $sigs_attr{$sig_id}{'msg'}    = $msg_str;

            my $sig_flags = '';
            my $flags     = '';

            if ($options =~ /flags:\s*(\w+)/i) {
                $sig_flags = $1;
                ### make flags identical to what iptables log messages
                ### would report (check in iptables flag reporting order).
                $flags .= 'URG ' if $sig_flags =~ /U/;
                $flags .= 'ACK ' if $sig_flags =~ /A/;
                $flags .= 'PSH ' if $sig_flags =~ /P/;
                $flags .= 'RST ' if $sig_flags =~ /R/;
                $flags .= 'SYN ' if $sig_flags =~ /S/;
                $flags .= 'FIN ' if $sig_flags =~ /F/;

                ### iptables simply reports no flags set at all instead
                ### of reporting "NULL", so put NULL anyway.
                $flags .= 'NULL ' if $sig_flags =~ /N/;
                $flags =~ s/\s*$//;
            }
            ### future
#            my $ttl   = '';
#            if ($options =~ /ttl:\s*(\d+)/i) {
#                $sigs{$proto}{$sig_id}{'TTL'} = $1;
#            }

            ### assign the source and destination port ranges
            &build_tcp_udp_sigs($sig_id, $proto,
                $sp, $dp, $flags);

        } elsif ($line =~ /^psad:(\d+);\s*icmp;\s*
                            msg:\s*\"(.*)\";\s*(.*)\s*dlevel:\s*(\d);$/x) {
            my $sig_id  = $1;
            my $msg_str = $2;
            my $options = $3;
            my $dlevel  = $4;

            ### add the signature message string to the %sig_attr cache
            $sigs_attr{$sig_id}{'dlevel'} = $dlevel;
            $sigs_attr{$sig_id}{'msg'}    = $msg_str;

            if ($options =~ /ttl:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'ttl'} = $1;
            }
            if ($options =~ /itype:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'type'} = $1;
            }
            if ($options =~ /icode:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'code'} = $1;
            }
            if ($options =~ /icmp_seq:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'icmp_seq'} = $1;
            }
            if ($options =~ /icmp_id:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'icmp_id'} = $1;
            }
        } else {  ### the signature line could not be recognized
            warn " ** Bad signature in $config{'PSAD_SIGS_FILE'}: $line\n";
            next SIG;
        }
    }
    if ($debug) {
        print STDOUT " ** main signatures hash:\n";
        print STDOUT Dumper %sigs;
        print STDOUT " ** fast lookup hash:\n";
        print STDOUT Dumper %sigs_fast;
        print STDOUT Dumper " ** signature attributes hash:\n";
        print STDOUT Dumper %sigs_attr;
    }
    &Psad::psyslog('psad', '.. Imported psad-1.2 signatures');
    return;
}

sub build_tcp_udp_sigs() {
    my ($sig_id, $proto, $sp, $dp, $flags) = @_;

    if (&is_range($dp) || &is_range($sp)) {
        ### if we make it here then we have a range of ports so insert
        ### the signature into the %sigs hash
        if ($proto eq 'TCP' && $flags) {
            $sigs{$proto}{$sig_id}{'flags'} = $flags;
        }
        ### deal with source port ranges
        if ($sp =~ /:/ && $sp !~ /!/) {
            my ($start, $end) = split /:/, $sp;
            $start = 1 unless $start;
            $end = 65535 unless $end;
            $sigs{$proto}{$sig_id}{'sp'}{'start'} = $start;
            $sigs{$proto}{$sig_id}{'sp'}{'end'}   = $end;
        } elsif ($sp =~ /!/ && $sp !~ /:/) {
            $sp =~ s/!//;
            $sigs{$proto}{$sig_id}{'sp'}{'not'} = $sp;
        } elsif ($sp =~ /:/ && $sp =~ /!/) {
            my ($start, $end) = split /:/, $sp;
            $start = 1 unless $start;
            $end = 65535 unless $end;
            $sigs{$proto}{$sig_id}{'sp'}{'negstart'} = $start;
            $sigs{$proto}{$sig_id}{'sp'}{'negend'}   = $end;
        } else {
            $sigs{$proto}{$sig_id}{'sp'}{'uniq_or_any'}
                = $sp;
        }

        ### deal with destination port ranges
        if ($dp =~ /:/ && $dp !~ /!/) {
            my ($start, $end) = split /:/, $dp;
            $start = 1 unless $start;
            $end = 65535 unless $end;
            $sigs{$proto}{$sig_id}{'dp'}{'start'} = $start;
            $sigs{$proto}{$sig_id}{'dp'}{'end'}   = $end;
        } elsif ($dp =~ /!/ && $dp !~ /:/) {
            $dp =~ s/!//;
            $sigs{$proto}{$sig_id}{'dp'}{'not'} = $dp;
        } elsif ($dp =~ /:/ && $dp =~ /!/) {
            my ($start, $end) = split /:/, $dp;
            $start = 1 unless $start;
            $end = 65535 unless $end;
            $sigs{$proto}{$sig_id}{'dp'}{'negstart'} = $start;
            $sigs{$proto}{$sig_id}{'dp'}{'negend'}   = $end;
        } else {
            $sigs{$proto}{$sig_id}{'dp'}{'uniq_or_any'} = $dp;
        }
    } else {
        ### build up the %sigs_fast lookup cache
        if ($dp !~ /\D/) {
            if ($sp !~ /\D/) {
                if ($proto eq 'TCP') {
                    $sigs_fast{$proto}{$dp}
                        {$sp}{$flags}{$sig_id} = '';
                } elsif ($proto eq 'UDP') {
                    $sigs_fast{$proto}{$dp}
                        {$sp}{$sig_id} = '';
                }
            } elsif ($sp =~ /any/i) {
                if ($proto eq 'TCP') {
                    $sigs_fast{$proto}{$dp}
                        {'any_sp'}{$flags}{$sig_id} = '';
                } elsif ($proto eq 'UDP') {
                    $sigs_fast{$proto}{$dp}
                        {'any_sp'}{$sig_id} = '';
                }
            }
        } elsif ($dp =~ /any/i) {
            if ($sp !~ /\D/) {
                if ($proto eq 'TCP') {
                    $sigs_fast{$proto}{'any_dp'}
                        {$sp}{$flags}{$sig_id} = '';
                } elsif ($proto eq 'UDP') {
                    $sigs_fast{$proto}{'any_dp'}
                        {$sp}{$sig_id} = '';
                }
            } elsif ($sp =~ /any/i) {
                if ($proto eq 'TCP') {
                    $sigs_fast{$proto}{'any_dp'}
                        {'any_sp'}{$flags}{$sig_id} = '';
                } elsif ($proto eq 'UDP') {
                    $sigs_fast{$proto}{'any_dp'}
                        {'any_sp'}{$sig_id} = '';
                }
            }
        }
    }
    return;
}

sub is_range() {
    my $port = shift;
    return 1 if $port =~ /:/;
    return 1 if $port =~ /!/;
    return 0;
}

sub import_auto_ips() {
    %auto_ips = ();  ### undef so we don't leave old ips in %auto_ips
    open A, "< $config{'PSAD_AUTO_IPS_FILE'}" or die ' ** Could not open ',
        "$config{'PSAD_AUTO_IPS_FILE'}: $!";
    my @lines = <A>;
    close A;
    my $i = 1;
    for my $line (@lines) {
        $i++;
        next if ($line =~ /^\s*#/);
        next unless ($line =~ /\S/);
        if ($line =~ m|^\s*($ip_re)\s+([0-5])|) {
            $auto_ips{'ip'}{$1} = $2;
        } elsif ($line =~ m|^\s*($ip_re/\d+)\s+([0-5])|) {
            $auto_ips{'net'}{$1} = $2;
        } else {
            my $subject = " ** psad import warning: " .
                "$config{'PSAD_AUTO_IPS_FILE'} error on line: $i";
            &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'},
                $cmds{'mail'});
        }
    }
    &Psad::psyslog('psad', '.. Imported psad_auto_ips');
    return;
}

sub import_posf_sigs() {
    %posf_sigs = ();
    my $posf_file = $config{'PSAD_POSF_FILE'};
    open P, "< $posf_file" or die ' ** Could not open ',
        "$posf_file: $!";
    my @lines = <P>;
    close P;
    my $os = '';
    for my $line (@lines) {
        chomp $line;
        next if ($line =~ /^\s*#/);
        next unless ($line =~ /\S/);
        if ($line =~ /^\s*OS\s+(.*);/) {
            $os = $1;
        } elsif ($line =~ /^\s*NUMPKTS\s+(\d+);/) {
            $posf_sigs{$os}{'numpkts'} = $1;
        } elsif ($line =~ /^\s*TOS\s+(\w+);/) {
            $posf_sigs{$os}{'tos'} = $1;
        } elsif ($line =~ /^\s*LEN\s+(\d+);/) {
            $posf_sigs{$os}{'len'} = $1;
        } elsif ($line =~ /^\s*TTL\s+(\d+);/) {
            $posf_sigs{$os}{'ttl'} = $1;
        } elsif ($line =~ /^\s*ID\s+(\w+);/) {
            $posf_sigs{$os}{'id'} = $1;
        } elsif ($line =~ /^\s*WINDOW\s+(\d+);/) {
            $posf_sigs{$os}{'win'} = $1;
        }
    }
    ### make sure each of the os signatures has all fields defined
    OS: for my $os (keys %posf_sigs) {
        unless (defined $posf_sigs{$os}{'numpkts'}) {
            &Psad::psyslog('psad', "** $posf_file: missing " .
                "NUMPKTS for os: $os");
            delete $posf_sigs{$os};
            next OS;
        }
        unless (defined $posf_sigs{$os}{'tos'}) {
            &Psad::psyslog('psad', "** $posf_file: missing " .
                "TOS for os: $os");
            delete $posf_sigs{$os};
            next OS;
        }
        unless (defined $posf_sigs{$os}{'len'}) {
            &Psad::psyslog('psad', "** $posf_file: missing " .
                "LEN for os: $os");
            delete $posf_sigs{$os};
            next OS;
        }
        unless (defined $posf_sigs{$os}{'ttl'}) {
            &Psad::psyslog('psad', "** $posf_file: missing " .
                "TTL for os: $os");
            delete $posf_sigs{$os};
            next OS;
        }
        unless (defined $posf_sigs{$os}{'id'}) {
            &Psad::psyslog('psad', "** $posf_file: missing " .
                "ID for os: $os");
            delete $posf_sigs{$os};
            next OS;
        } else {
            unless ($posf_sigs{$os}{'id'} eq 'SMALLINCR'
                    || $posf_sigs{$os}{'id'} eq 'RANDOM') {
                &Psad::psyslog('psad', "** $posf_file: ID must " .
                    "be either SMALLINCR or RANDOM for os: $os");
                delete $posf_sigs{$os};
                next OS;
            }
        }
        unless (defined $posf_sigs{$os}{'win'}) {
            &Psad::psyslog('psad', "** $posf_file: missing " .
                "WINDOW for os: $os");
            delete $posf_sigs{$os};
            next OS;
        }
    }
    print Dumper %posf_sigs if $debug;

    &Psad::psyslog('psad', '.. Imported passive OS ' .
        'fingerprinting signatures');
    return;
}

sub check_range() {
    my ($port, $start, $end) = @_;
    $start = $port if ($port < $start);
    $end   = $port if ($port > $end);
    return $start, $end;
}

### assign a danger level to a scan.  Note that match_fastsigs()
### and match_sigs() may also assign a danger level.
sub assign_danger_level() {
    SRC: for my $src (keys %scan) {
        print "assign_danger_level(): source ip: $src\n" if $debug;
        if (%auto_ips) {
            if (defined $auto_ips{'ip'}{$src}) {
                for my $dst (keys %{$scan{$src}}) {
                    $scan_dl{$src} = $auto_ips{'ip'}{$src};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                ### ignore $src if the auto danger level is zero
                next SRC if $auto_ips{'ip'}{$src} == 0;
            } else {
                for my $net (keys %{$auto_ips{'net'}}) {
                    if (ipv4_in_network($net, $src)) {
                        for my $dst (keys %{$scan{$src}}) {
                            $scan_dl{$src} = $auto_ips{'net'}{$net};
                            $scan{$src}{$dst}{'ALERTED'} = 0;
                        }
                        ### ignore $src if the auto danger level is zero
                        next SRC if $auto_ips{'net'}{$net} == 0;
                    }
                }
            }
        }
        DST: for my $dst (keys %{$scan{$src}}) {
            my $absnum = $scan{$src}{$dst}{'ABSNUM'};
            my $range;
            my $s_port = 65535;
            my $e_port = 0;

            ### calculate the range over _both_ tcp and udp
            for my $proto qw(TCP UDP) {
                next unless defined $scan{$src}{$dst}{$proto}{'ABS_SP'};
                if ($s_port > $scan{$src}{$dst}{$proto}{'ABS_SP'}) {
                    $s_port = $scan{$src}{$dst}{$proto}{'ABS_SP'};
                }
                if ($e_port < $scan{$src}{$dst}{$proto}{'ABS_EP'}) {
                    $e_port = $scan{$src}{$dst}{$proto}{'ABS_EP'};
                }
            }
            if ($e_port) {
                $range = $e_port - $s_port;
            } else {  ### for icmp
                $range = $absnum;
            }
            if ($debug) {
                print "assign_danger_level(): destination ip: $dst\n";
                print "assign_danger_level(): ABSNUM: ",
                    "$scan{$src}{$dst}{'ABSNUM'}\n";
                for my $proto qw(TCP UDP) {
                    next unless defined $scan{$src}{$dst}{$proto}{'ABS_SP'};
                    print "assign_danger_level(): ABS_SP: ",
                        "$scan{$src}{$dst}{$proto}{'ABS_SP'}, ABS_EP: ",
                        "$scan{$src}{$dst}{$proto}{'ABS_EP'}\n";
                }
                print 'assign_danger_level(): DL (before assignment) = ',
                    "$scan_dl{$src}\n";
            }

            ### if PORT_RANGE_SCAN_THRESHOLD is >= 1, then psad will not assign
            ### a danger level to repeated packets to the same port
            if ($absnum < $config{'DANGER_LEVEL1'}) {
                ### don't have enough packets to even reach danger level 1 yet.
                next DST;
            }
            if ($range >= $config{'PORT_RANGE_SCAN_THRESHOLD'}) {
                if ($absnum < $config{'DANGER_LEVEL2'}) {
                    if ($scan_dl{$src} < 1) {
                        $scan{$src}{$dst}{'ALERTED'} = 0;
                        $scan_dl{$src} = 1;
                    }
                } elsif ($absnum < $config{'DANGER_LEVEL3'}) {
                    if ($scan_dl{$src} < 2) {
                        $scan{$src}{$dst}{'ALERTED'} = 0;
                        $scan_dl{$src} = 2;
                    }
                } elsif ($absnum < $config{'DANGER_LEVEL4'}) {
                    if ($scan_dl{$src} < 3) {
                        $scan{$src}{$dst}{'ALERTED'} = 0;
                        $scan_dl{$src} = 3;
                    }
                } elsif ($absnum < $config{'DANGER_LEVEL5'}) {
                    if ($scan_dl{$src} < 4) {
                        $scan{$src}{$dst}{'ALERTED'} = 0;
                        $scan_dl{$src} = 4;
                    }
                } elsif ($scan_dl{$src} < 5) {
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                    $scan_dl{$src} = 5;
                }
            }
            print 'assign_danger_level(): DL (after assignment) = ',
                "$scan_dl{$src}\n" if $debug;
        }
    }
    return;
}

sub write_global_packet_counters() {
    open P, "> $config{'PACKET_COUNTER_FILE'}" or
        die " ** Could not open $config{'PACKET_COUNTER_FILE'}: $!";
    print P "tcp:  $tcp_ctr\n";
    print P "udp:  $udp_ctr\n";
    print P "icmp: $icmp_ctr\n";
    close P;
    return;
}

sub write_src_packet_counters() {
    my ($tcp, $udp, $icmp, $file) = @_;
    open P, "> $file" or
        die " ** Could not open $file: $!";
    print P "tcp:  $tcp\n";
    print P "udp:  $udp\n";
    print P "icmp: $icmp\n";
    close P;
    return;
}

sub collect_errors() {
    my ($bad_packets_aref) = @_;
    open ERR, ">> $config{'FW_ERROR_LOG'}" or die ' ** Could not open ',
        "$config{'FW_ERROR_LOG'}: $!";
    for my $line (@$bad_packets_aref) {
        print ERR "$line\n";
    }
    close ERR;
}

sub scan_logr() {
    for my $src (keys %scan) {
        print STDOUT "scan_logr(): source ip: $src\n" if $debug;
        DST: for my $dst (keys %{$scan{$src}}) {
            ### already sent an alert
            next DST if $scan{$src}{$dst}{'ALERTED'};
            next DST unless $scan_dl{$src} >= 1;
            my $syslog_flags = '';
            my $dns_str      = '';
            my $rdns         = '';
            my $syslog_range = '';
            my $tcp_newrange = '';
            my $tcp_absrange = '';
            my $udp_newrange = '';
            my $udp_absrange = '';
            my $tcp_newpkts  = 0;
            my $udp_newpkts  = 0;
            my $icmp_newpkts = 0;
            my $tot_tcp  = 0;
            my $tot_udp  = 0;
            my $tot_icmp = 0;
            my $tcp_f  = 0;
            my $udp_f  = 0;
            my $icmp_f = 0;
            my $whois_info_aref;

            ### get the current danger level and the absolute number
            ### of packets used in the scan so far
            my $curr_dlevel = $scan_dl{$src};

            unless (defined $scan{$src}{$dst}{'EMAIL_COUNT'}) {
                $scan{$src}{$dst}{'EMAIL_COUNT'} = 0;
            } elsif ($config{'PSAD_EMAIL_LIMIT'} > 0
                    && $scan{$src}{$dst}{'EMAIL_COUNT'}
                    > $config{'PSAD_EMAIL_LIMIT'}) {
                ### ignore PSAD_EMAIL_LIMIT if it is zero
                unless (defined $scan{$src}{$dst}{'EMAIL_STOPPED'}) {
                    &email_limit_reached($src, $dst);
                    $scan{$src}{$dst}{'EMAIL_STOPPED'} = 1;
                }
                next DST;
            }
            print STDOUT "scan_logr(): dst ip: $dst\n" if $debug;

            ### make $src directory here in /var/log/psad
            ### unless it already exists
            mkdir "$config{'PSAD_DIR'}/${src}", 0500 unless
                -d "$config{'PSAD_DIR'}/${src}";
            my $scanlog       = "$config{'PSAD_DIR'}/${src}/scanlog";
            my $email_alert   = "$config{'PSAD_DIR'}/${src}/email_alert";
            my $ecount_file   = "$config{'PSAD_DIR'}/${src}/email_count";
            my $whois_file    = "$config{'PSAD_DIR'}/${src}/whois";
            my $dl_file       = "$config{'PSAD_DIR'}/${src}/danger_level";
            my $log_sigs      = "$config{'PSAD_DIR'}/${src}/signatures";
            my $pkt_ctr_file  = "$config{'PSAD_DIR'}/${src}/packet_ctr";

            ### unlink $email_alert here since we print to this
            ### file multiple times
            unlink $email_alert;

            ### print the current danger level to the danger_level file
            &Psad::logr("$curr_dlevel\n", {$dl_file => 0});

            ### log everything to stdout if $output of $debug is set
            $scanlog = *STDOUT if ($output || $debug);

            ### filename => 0 (overwrite),  filename => 1 (append)
            my %print_hsh = ($scanlog => 1, $email_alert => 1);

            ### set the overall packet counters for $src
            $tot_tcp  = $scan{$src}{$dst}{'TCP'}{'PKTS'}
                if defined $scan{$src}{$dst}{'TCP'}{'PKTS'};
            $tot_udp  = $scan{$src}{$dst}{'UDP'}{'PKTS'}
                if defined $scan{$src}{$dst}{'UDP'}{'PKTS'};
            $tot_icmp = $scan{$src}{$dst}{'ICMP'}{'PKTS'}
                if defined $scan{$src}{$dst}{'ICMP'}{'PKTS'};

            ### write out the packet counters for $src
            &write_src_packet_counters($tot_tcp,
                $tot_udp, $tot_icmp, $pkt_ctr_file);

            if (defined $scan{$src}{$dst}{'TCP'}{'ABS_SP'}) {
                my $tcp_s_port
                    = $scan{$src}{$dst}{'TCP'}{'ABS_SP'};
                my $tcp_e_port
                    = $scan{$src}{$dst}{'TCP'}{'ABS_EP'};
                if ($tcp_s_port == $tcp_e_port) {
                    $tcp_absrange = $tcp_s_port;
                } else {
                    $tcp_absrange = "$tcp_s_port-$tcp_e_port";
                }
            }
            if (defined $scan{$src}{$dst}{'TCP'}{'C_INT'}) {
                $tcp_f = 1;
                my $tcp_s_port
                    = $scan{$src}{$dst}{'TCP'}{'C_INT'}{'SP'};
                my $tcp_e_port
                    = $scan{$src}{$dst}{'TCP'}{'C_INT'}{'EP'};
                if ($tcp_s_port == $tcp_e_port) {
                    $tcp_newrange = $tcp_s_port;
                } else {
                    $tcp_newrange = "$tcp_s_port-$tcp_e_port";
                }
                $tcp_newpkts = $scan{$src}{$dst}{'TCP'}
                    {'C_INT'}{'PKTS'};
            }
            if (defined $scan{$src}{$dst}{'UDP'}{'ABS_SP'}) {
                my $udp_s_port
                    = $scan{$src}{$dst}{'UDP'}{'ABS_SP'};
                my $udp_e_port
                    = $scan{$src}{$dst}{'UDP'}{'ABS_EP'};
                if ($udp_s_port == $udp_e_port) {
                    $udp_absrange = $udp_s_port;
                } else {
                    $udp_absrange = "$udp_s_port-$udp_e_port";
                }
            }
            if (defined $scan{$src}{$dst}{'UDP'}{'C_INT'}) {
                $udp_f = 1;
                my $udp_s_port
                    = $scan{$src}{$dst}{'UDP'}{'C_INT'}{'SP'};
                my $udp_e_port
                    = $scan{$src}{$dst}{'UDP'}{'C_INT'}{'EP'};
                if ($udp_s_port == $udp_e_port) {
                    $udp_newrange = $udp_s_port;
                } else {
                    $udp_newrange = "$udp_s_port-$udp_e_port";
                }
                $udp_newpkts = $scan{$src}{$dst}{'UDP'}
                    {'C_INT'}{'PKTS'};
            }
            if (defined $scan{$src}{$dst}{'ICMP'}{'C_INT'}) {
                $icmp_f = 1;
                $icmp_newpkts = $scan{$src}{$dst}{'ICMP'}
                    {'C_INT'}{'PKTS'};
            }

            ### get reverse dns info
            unless ($no_rdns) {
                if ($src =~ /$ip_re/) {
                    my $ipaddr = gethostbyname $src;
                    ### my $rdns = gethostbyaddr($ipaddr, AF_INET);
                    if ($rdns = gethostbyaddr $ipaddr, 2) {
                        $dns_str = $rdns;
                    } else {
                        $dns_str = '[No reverse dns info available]';
                    }
                } else {
                    ### $ipaddr was already reported as
                    ### a host name by iptables (does this actually
                    ### happen?)
                    $dns_str = $src;
                }
            }

            ### get whois info
            unless ($no_whois) {
                $whois_info_aref = &get_whois_data($src, $whois_file);
            }
            print STDOUT "scan_logr():  generating email.....\n" if $debug;

            ### get the absolute starting time for the scan and the
            ### current time
            my $abs_s_time = scalar localtime $scan{$src}{$dst}{'S_TIME'};
            my $s_time;
            if (time() - $config{'PSAD_CHECK_INTERVAL'} <
                $scan{$src}{$dst}{'S_TIME'}) {
                $s_time = $abs_s_time;
            } else {
                $s_time = scalar localtime((time()
                    - $config{'PSAD_CHECK_INTERVAL'}));
            }
            my $time = scalar localtime();

            &Psad::logr("=-=-=-=-=-=-=-=-=-=-=-= $time =-=-=-=-=-=-=-=" .
                "-=-=-=-=\n", \%print_hsh);
            &Psad::logr(" ** psad: Suspicious traffic detected against " .
                "$hostname ($dst).\n\n", \%print_hsh);
            &Psad::logr("\n", \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", 'Source: ', "$src\n"),
                \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", 'Source DNS: ',
                "$dns_str\n"), \%print_hsh) unless $no_rdns;
            if (!$no_posf && defined $posf{$src}{'guess'}) {
                &Psad::logr(sprintf("%${log_len}s%s", 'Source OS guess: ',
                    "$posf{$src}{'guess'}\n\n"), \%print_hsh);
            }
            &Psad::logr(sprintf("%${log_len}s%s", 'Destination: ', "$dst\n"),
                \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", 'Danger level: ',
                "[$scan_dl{$src}] (out of 5)\n\n"), \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", 'Current interval: ',
                "$s_time (start)\n"), \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", '',
                "$time (end)\n"), \%print_hsh);
            if ($tcp_f) {
                &Psad::logr(sprintf("%${log_len}s%s", 'Scanned TCP ports: ',
                    "[$tcp_newrange: $tcp_newpkts packets]\n"), \%print_hsh);
                my $prefix = 'TCP flags: ';
                for my $flags (keys
                        %{$scan{$src}{$dst}{'TCP'}{'C_INT'}{'FLAGS'}}) {
                    my $nmap_opts;
                    $syslog_flags .= "$flags ";
                    my $n_pkts = $scan{$src}{$dst}{'TCP'}
                        {'C_INT'}{'FLAGS'}{$flags};
                    if ($flags eq 'SYN') {
                        $nmap_opts = '-sT or -sS';
                    } elsif ($flags eq 'FIN') {
                        $nmap_opts = '-sF';
                    } elsif ($flags eq 'URG PSH FIN') {
                        $nmap_opts = '-sX';
                    } elsif ($flags eq 'NULL') {
                        $nmap_opts = '-sN';
                    } elsif ($flags eq 'URG PSH SYN FIN') {
                        $nmap_opts = '-O';
                    }
                    if ($nmap_opts) {
                        &Psad::logr(sprintf("%${log_len}s%s", $prefix,
                            "[$flags: $n_pkts pkts, Nmap: $nmap_opts]\n"),
                            \%print_hsh);
                    } else {
                        &Psad::logr(sprintf("%${log_len}s%s", $prefix,
                            "[$flags: $n_pkts pkts]\n"), \%print_hsh);
                    }
                    $prefix = '';
                }
                $syslog_flags =~ s/\s*$//;
                $syslog_range .= "tcp=[$tcp_newrange] $syslog_flags";
            }
            if ($udp_f) {
                &Psad::logr(sprintf("%${log_len}s%s", 'Scanned UDP ports: ',
                    "[$udp_newrange: $udp_newpkts pkts, Nmap: -sU]\n"),
                    \%print_hsh);
            }
            if ($icmp_f) {
                &Psad::logr(sprintf("%${log_len}s%s", 'ICMP packets: ',
                    "[$icmp_newpkts]\n"), \%print_hsh);
            }
            &Psad::logr("\n", \%print_hsh);

            ### print the overall stats since the scan began
            &Psad::logr(sprintf("%${log_len}s%s", 'Overall stats since: ',
                "$abs_s_time\n"), \%print_hsh);
            if ($tcp_absrange) {
                &Psad::logr(sprintf("%${log_len}s%s", 'Complete TCP range: ',
                    "[$tcp_absrange]\n"), \%print_hsh);
            }
            if ($udp_absrange) {
                &Psad::logr(sprintf("%${log_len}s%s", 'Complete UDP range: ',
                    "[$udp_absrange]\n"), \%print_hsh);
            }
            &Psad::logr(sprintf("%${log_len}s%s", 'Total TCP  packets: ',
                "$tot_tcp\n"), \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", 'Total UDP  packets: ',
                "$tot_udp\n"), \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", 'Total ICMP packets: ',
                "$tot_icmp\n"), \%print_hsh);

            if ($use_iptables) {
                ### print any matched signatures to the alert
                &scan_logr_signatures($src, $dst,
                    {$scanlog=>1, $email_alert=>1, $log_sigs=>1});
            }

            ### write a message to syslog
            &Psad::psyslog('psad', "scan detected: $src -> $dst " .
                "$syslog_range tcp=$tcp_newpkts udp=$udp_newpkts " .
                "icmp=$icmp_newpkts dangerlevel: $curr_dlevel");

            unless ($no_whois) {
                &Psad::logr("\n\n", \%print_hsh);
                &Psad::logr("---- Whois Information: ----\n", \%print_hsh);
                for my $line (@$whois_info_aref) {
                    &Psad::logr($line, \%print_hsh);
                }
                &Psad::logr("\n", \%print_hsh);
            }
            &Psad::logr("=-=-=-=-=-=-=-=-=-=-=-= $time =-=-=-=-=-=-=-=" .
                "-=-=-=-=\n", \%print_hsh);
            if ($curr_dlevel >= $config{'EMAIL_ALERT_DANGER_LEVEL'}) {
                my $subject;
                if ($rdns) {
                    if ($benchmark) {
                        $subject = " ** psad: BENCHMARK SCAN from: $rdns";
                    } else {
                        $subject = " ** psad: SCAN DETECTED from: $rdns";
                    }
                } else {
                    if ($benchmark) {
                        $subject = " ** psad: BENCHMARK SCAN from: $src";
                    } else {
                        $subject = " ** psad: SCAN DETECTED from: $src";
                    }
                }
                &Psad::sendmail($subject, $email_alert,
                    $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
                $scan{$src}{$dst}{'EMAIL_COUNT'}++;

                ### print the number of email alerts we have sent
                &Psad::logr("$scan{$src}{$dst}{'EMAIL_COUNT'}\n",
                    {$ecount_file => 0});

                if ($config{'ENABLE_EXT_SCRIPT_EXEC'} eq 'Y') {
                    if ($config{'EXEC_EXT_SCRIPT_PER_ALERT'} eq 'Y') {
                        &exec_external_script($src);
                    } else {
                        &exec_external_script($src) unless
                            defined $scan_ext_exec{$src};
                    }
                }
            }
            ### delete all current intervals so they won't show up
            ### in the next alert
            delete $scan{$src}{$dst}{'TCP'}{'C_INT'};
            delete $scan{$src}{$dst}{'UDP'}{'C_INT'};
            delete $scan{$src}{$dst}{'ICMP'}{'C_INT'};

            ### we have sent an alert for $dst
            $scan{$src}{$dst}{'ALERTED'} = 1;
        }
    }
    return;
}

sub scan_logr_signatures() {
    my ($src, $dst, $print_hr) = @_;
    ### ok, these hash keys are too much
    for my $proto qw(TCP UDP ICMP) {
        next unless (defined $scan{$src}{$dst}{$proto}{'CURR_SIG'}
            || defined $scan{$src}{$dst}{$proto}{'SNORT_SID'});
        &Psad::logr("\n", $print_hr);
        &Psad::logr("---- $proto scan signatures ----\n", $print_hr);
        print "scan_logr_signatures(): src: $src dst: $dst proto: $proto\n"
            if $debug;
        for my $sid (keys %{$scan{$src}{$dst}{$proto}{'SNORT_SID'}}) {
            my $msg = $snort_msgs{$sid}{'msg'};
            my $classtype = $snort_msgs{$sid}{'classtype'};
            my $pkts = $scan{$src}{$dst}{$proto}{'SNORT_SID'}{$sid};
            my $content;
            if (defined $snort_msgs{$sid}{'content'}) {
                $content = $snort_msgs{$sid}{'content'};
            }
            &Psad::logr(qq("$msg"\n), $print_hr);
            &Psad::logr("       classtype: $classtype\n", $print_hr);
            &Psad::logr("       sid:       $sid\n", $print_hr);
            &Psad::logr(qq(       content:   "$content"\n), $print_hr)
                if $content;
            &Psad::logr("       packets:   $pkts\n\n", $print_hr);
        }
        for my $sig_id (keys %{$scan{$src}{$dst}{$proto}{'CURR_SIG'}}) {
            my $msg = $sigs_attr{$sig_id}{'msg'};
            if ($proto eq 'TCP') {
                for my $dp (keys
                        %{$scan{$src}{$dst}{'TCP'}{'CURR_SIG'}
                        {$sig_id}{'LISTEN'}}) {
                    my $flags =
                        $scan{$src}{$dst}{'TCP'}
                        {'CURR_SIG'}{$sig_id}{'LISTEN'}{$dp}{'FLAGS'};
                    my $pkts =
                        $scan{$src}{$dst}{'TCP'}
                        {'CURR_SIG'}{$sig_id}{'LISTEN'}{$dp}{'PKTS'};
                    my $l_str = "** Your machine is listening on TCP port: $dp!\n";
                    ### avoid "." operator
                    &Psad::logr(qq("$msg" dp=$dp flags=[$flags] packets=$pkts $l_str),
                        $print_hr);
                }
                for my $dp (keys
                        %{$scan{$src}{$dst}{'TCP'}
                        {'CURR_SIG'}{$sig_id}{'NO_LISTEN'}}) {
                    my $flags =
                        $scan{$src}{$dst}{'TCP'}{'CURR_SIG'}
                        {$sig_id}{'NO_LISTEN'}{$dp}{'FLAGS'};
                    my $pkts =
                        $scan{$src}{$dst}{'TCP'}{'CURR_SIG'}
                        {$sig_id}{'NO_LISTEN'}{$dp}{'PKTS'};
                    my $l_str = "No server on TCP port: $dp\n";
                    &Psad::logr(qq("$msg" dp=$dp flags=[$flags] packets=$pkts $l_str),
                        $print_hr);
                }
            } elsif ($proto eq 'UDP') {
                for my $dp (keys
                        %{$scan{$src}{$dst}{'UDP'}{'CURR_SIG'}
                        {$sig_id}{'LISTEN'}}) {
                    my $pkts =
                        $scan{$src}{$dst}{'UDP'}{'CURR_SIG'}
                        {$sig_id}{'LISTEN'}{$dp}{'PKTS'};
                    my $l_str = "** Your machine is listening on UDP port: $dp!\n";
                    &Psad::logr(qq("$msg" dp=$dp packets=$pkts $l_str),
                        $print_hr);
                }
                for my $dp (keys
                        %{$scan{$src}{$dst}{'UDP'}{'CURR_SIG'}
                        {$sig_id}{'NO_LISTEN'}}) {
                    my $pkts =
                        $scan{$src}{$dst}{'UDP'}{'CURR_SIG'}
                        {$sig_id}{'NO_LISTEN'}{$dp}{'PKTS'};
                    my $l_str = "No server on UDP port: $dp\n";
                    &Psad::logr(qq("$msg" dp=$dp packets=$pkts $l_str),
                        $print_hr);
                }
            } else {
                my $pkts = $scan{$src}{$dst}{'ICMP'}
                    {'CURR_SIG'}{$sig_id}{'PKTS'};
                &Psad::logr(qq("$msg" packets=$pkts\n), $print_hr);
            }

            ### signature logging with syslog is not yet supported
            ### (requires a message for each matched signature).
#            if ($sigmatch =~ /^(\".*\")/) {
#                $syslog_sig_title = "signature=$1";
#            }
        }
        ### need to delete the current signature so it
        ### won't show up in the next alert
        delete $scan{$src}{$dst}{$proto}{'CURR_SIG'}
            unless $config{'SHOW_ALL_SIGNATURES'} eq 'Y';
        delete $scan{$src}{$dst}{$proto}{'SNORT_SID'}
            unless $config{'SHOW_ALL_SIGNATURES'} eq 'Y';
    }
    return;
}

sub exec_external_script() {
    my $src = shift;
    $scan_ext_exec{$src} = '';
    my $cmd = $config{'EXTERNAL_SCRIPT'};
    $cmd =~ s/SRCIP/$src/;
    my $pid;
    if ($pid = fork()) {
        local $SIG{'ALRM'} = sub {die " ** External script timeout.\n"};
        alarm 30;  ### the external script should be finished in 30 secs.
        eval {
            waitpid($pid, 0);
        };
        alarm 0;
        if ($@) {
            kill 9, $pid;
        }
    } else {
        die " ** Could not fork for external script: $!" unless defined $pid;
        exec qq{$cmd};
    }
    return;
}

sub renew_auto_blocked_ips() {
    my $timeout_str = '.';
    if ($config{'AUTO_BLOCK_TIMEOUT'} > 0) {
        $timeout_str = " for $config{'AUTO_BLOCK_TIMEOUT'} seconds.";
    }
    if ($config{'IPTABLES_BLOCK_METHOD'} eq 'Y'
            && -e $config{'AUTO_BLOCK_IPT_FILE'}) {

        ### get the active iptables chains
        &get_iptables_chains() unless $chk_ipt_chains;

        open B, "< $config{'AUTO_BLOCK_IPT_FILE'}" or
            die " ** Could not open $config{'AUTO_BLOCK_IPT_FILE'}: $!";
        my @lines = <B>;
        close B;
        for my $line (@lines) {
            if ($line =~ /($ip_re)/) {
                my $ip = $1;
                ### add block rule for $ip unless it is already blocked
                unless (&ipt_test_block($ip)) {
                    &ipt_block($ip);
                    &Psad::sendmail(" ** psad: RENEWED iptables BLOCK against $ip" .
                        $timeout_str, '', $config{'EMAIL_ADDRESSES'},
                        $cmds{'mail'});
                }
                $auto_blocked_ips{$ip} = time();
            }
        }
    } elsif ($config{'IPCHAINS_BLOCK_METHOD'} eq 'Y'
            && -e $config{'AUTO_BLOCK_IPCH_FILE'}) {
        open B, "< $config{'AUTO_BLOCK_IPCH_FILE'}" or
            die " ** Could not open $config{'AUTO_BLOCK_IPCH_FILE'}: $!";
        my @lines = <B>;
        close B;
        for my $line (@lines) {
            if ($line =~ /($ip_re)/) {
                my $ip = $1;
                ### add block rule for $ip unless it is already blocked
                unless (&ipch_test_block($ip)) {
                    &ipch_block($ip);
                    &Psad::sendmail(" ** psad: RENEWED ipchains BLOCK against $ip" .
                        $timeout_str, '', $config{'EMAIL_ADDRESSES'},
                        $cmds{'mail'});
                }
                $auto_blocked_ips{$ip} = time();
            }
        }
    }
    ### XXX future
#    if ($config{'TCPWRAPPERS_BLOCK_METHOD'} eq 'Y'
#            && -e $config{'TCPWRAPPERS_BLOCK_METHOD'}) {
#    }
    return;
}

sub flush_auto_blocked_ips() {
    my $found_blocked = 0;
    my $rv = 0;
    if (-e $config{'AUTO_BLOCK_IPT_FILE'}) {
        print " .. Removing iptables auto-generated block rules.\n";
        open B, "< $config{'AUTO_BLOCK_IPT_FILE'}" or
            die " ** Could not open $config{'AUTO_BLOCK_IPT_FILE'}: $!";
        my @lines = <B>;
        close B;
        for my $line (@lines) {
            if ($line =~ /($ip_re)/) {
                my $ip = $1;
                ### remove block rules for $ip if it has been blocked
                &ipt_remove_block($ip) if &ipt_test_block($ip);
            }
        }
        ### we have removed the iptables block rules, so remove
        ### the cache file.
        unlink $config{'AUTO_BLOCK_IPT_FILE'};
        $found_blocked = 1;
    }
    if (-e $config{'AUTO_BLOCK_IPCH_FILE'}) {
        print " .. Removing ipchains auto-generated block rules.\n";
        open B, "< $config{'AUTO_BLOCK_IPCH_FILE'}" or
            die " ** Could not open $config{'AUTO_BLOCK_IPCH_FILE'}: $!";
        my @lines = <B>;
        close B;
        for my $line (@lines) {
            if ($line =~ /($ip_re)/) {
                my $ip = $1;
                ### remove block rules for $ip if it has been blocked
                &ipch_remove_block($ip) if &ipch_test_block($ip);
            }
        }
        unlink $config{'AUTO_BLOCK_IPCH_FILE'};
        $found_blocked = 1;
    }
    if (-e $config{'AUTO_BLOCK_TCPWR_FILE'}) {
        print " .. Removing tcpwrapper auto-generated block rules.\n";
        open B, "< $config{'AUTO_BLOCK_TCPWR_FILE'}" or
            die " ** Could not open $config{'AUTO_BLOCK_TCPWR_FILE'}: $!";
        my @lines = <B>;
        close B;
        unlink $config{'AUTO_BLOCK_TCPWR_FILE'};
        $found_blocked = 1;
    }
    unless ($found_blocked) {
        print " ** Currently there are no auto-generated ".
            "block rules in effect.\n";
    }
    exit $rv;
}

sub ipt_test_block() {
    my $ip = shift;

    ### get the active iptables chains
    &get_iptables_chains() unless $chk_ipt_chains;

    for my $table (keys %ipt_chains) {
        for my $chain (keys %{$ipt_chains{$table}}) {
            my @rules = `$cmds{'iptables'} -t $table -nL $chain`;
            RULE: for my $rule (@rules) {
                chomp $rule;
                next RULE if $rule =~ /^\s*Chain\s/;
                next RULE if $rule =~ /^\s*target\s/;
                ### DROP       all  --  1.1.1.1        0.0.0.0/0
                if ($rule =~ /^DROP\s+all.*?$ip\s+0\.0\.0\.0\/0/) {
                    return 1;
                }
            }
        }
    }
    ### did not find the ip
    return 0;
}

sub ipt_block() {
    my $src = shift;
    for my $table (keys %ipt_chains) {
        for my $chain (keys %{$ipt_chains{$table}}) {
            system "$cmds{'iptables'} -t $table -I $chain 1 " .
                "-s $src -j DROP 2> /dev/null 1>&2";
        }
    }
    ### write the ip out to the auto blocked file
    &write_blocked_ip($src, $config{'AUTO_BLOCK_IPT_FILE'});
    return;
}

sub ipt_remove_block() {
    my $src = shift;

    ### get the active iptables chains
    &get_iptables_chains() unless $chk_ipt_chains;

    my $rm_block = 0;
    for my $table (keys %ipt_chains) {
        for my $chain (keys %{$ipt_chains{$table}}) {
            my @rules = `$cmds{'iptables'} -t $table -nL $chain`;
            my $rulenum = 1;
            RULE: for my $rule (@rules) {
                next RULE if $rule =~ /^\s*Chain\s/;
                next RULE if $rule =~ /^\s*target\s/;
                ### DROP       all  --  1.1.1.1        0.0.0.0/0
                if ($rule =~ /^DROP\s+all.*?$src\s+0\.0\.0\.0\/0/) {
                    if ($flush_fw) {
                        print " .. Deleting rule $rulenum for $src, $table ",
                            "table $chain chain:\n";
                        print "        $rule\n";
                    }
                    system "$cmds{'iptables'} -t $table -D $chain $rulenum";
                    $rm_block = 1;
                    last RULE;  ### there should only be one auto-blocked rule
                }
                $rulenum++;
            }
        }
    }
    if ($rm_block) {
        &rm_blocked_ip($src, $config{'AUTO_BLOCK_IPT_FILE'});
    } else {
        print " ** Could not locate iptables block rule for $src.\n"
            if $flush_fw;
    }
    return;
}

sub ipch_test_block() {
    my $ip = shift;
    for my $chain (@ipchains_chains) {
        my @rules = `$cmds{'ipchains'} -nL $chain`;
        RULE: for my $rule (@rules) {
            chomp $rule;
            ### DENY   udp  ------  0.0.0.0/0   0.0.0.0/0   * -> *
            if ($rule =~ /^DENY\s+all.*?$ip.*0\.0\.0\.0\/0\s+\*\s+\-\>\s+\*/) {
                return 1;
            }
        }
    }
    return 0;
}

sub ipch_block() {
    my $src = shift;
    for my $chain (@ipchains_chains) {
        system "$cmds{'ipchains'} -I $chain 1 -s $src " .
            "-j DENY 2> /dev/null 1>&2";
    }
    ### write the ip out to the auto blocked file
    &write_blocked_ip($src, $config{'AUTO_BLOCK_IPCH_FILE'});
    return;
}

sub ipch_remove_block() {
    my $src = shift;
    my $rm_block = 0;
    for my $chain (@ipchains_chains) {
        my @rules = `$cmds{'ipchains'} -nL $chain`;
        my $rulenum = 1;
        RULE: for my $rule (@rules) {
            chomp $rule;
            ### DENY   udp  ------  0.0.0.0/0   0.0.0.0/0   * -> *
            if ($rule =~ /^DENY\s+all.*?$src.*0\.0\.0\.0\/0\s+\*\s+\-\>\s+\*/) {
                if ($flush_fw) {
                    print " .. Deleting rule $rulenum for $src, $chain chain:\n";
                    print "        $rule\n";
                }
                system "$cmds{'ipchains'} -D $chain $rulenum";
                $rm_block = 1;
                last RULE;
            }
            $rulenum++;
        }
    }
    if ($rm_block) {
        &rm_blocked_ip($src, $config{'AUTO_BLOCK_IPCH_FILE'});
    } else {
        print " ** Could not locate ipchains block rule for $src.\n"
            if $flush_fw;
    }
    return;
}

sub auto_psad_response() {
    if ($use_iptables && ! $chk_ipt_chains) {
        ### determine whether or not the NAT or mangle code has
        ### been compiled into iptables
        &get_iptables_chains();
    }
    for my $src (keys %scan) {
        my $dl = $scan_dl{$src};
        ### We only want to block the IP once.  Currently this will block
        ### all traffic from the host to _all_ destinations that are
        ### protected by the firewall if the ip trips the $auto_psad_level
        ### threshold for _any_ destination.
        if ($dl >= $config{'AUTO_IDS_DANGER_LEVEL'}
                && ! defined $auto_blocked_ips{$src}) {

            my $timeout_str = '.';
            if ($config{'AUTO_BLOCK_TIMEOUT'} > 0) {
                $timeout_str = " for $config{'AUTO_BLOCK_TIMEOUT'} seconds.";
            }
            ### we have seen at least one packet logged by the firewall
            ### at this point
            if ($use_iptables && $config{'IPTABLES_BLOCK_METHOD'} eq 'Y') {
                &ipt_block($src);
                &Psad::sendmail(" ** psad: iptables AUTO-BLOCK against $src" .
                    $timeout_str, '', $config{'EMAIL_ADDRESSES'},
                    $cmds{'mail'});
            }
            if ($use_ipchains && $config{'IPCHAINS_BLOCK_METHOD'} eq 'Y') {
                &ipch_block($src);
                &Psad::sendmail(" ** psad: ipchains AUTO-BLOCK against $src" .
                    $timeout_str, '', $config{'EMAIL_ADDRESSES'},
                    $cmds{'mail'});
            }
            if ($config{'TCPWRAPPERS_BLOCK_METHOD'} eq 'Y') {
                &Psad::sendmail(" ** psad: tcpwrappers AUTO-BLOCK against $src" .
                    $timeout_str, '', $config{'EMAIL_ADDRESSES'},
                    $cmds{'mail'});
                ### XXX this needs to be smarter
                open H, ">> /etc/hosts.deny" or die
                    "Could not open /etc/hosts.deny: $!";
                print H "ALL: $src\n";
                close H;
                ### write the ip out to the auto blocked file
                &write_blocked_ip($src, $config{'AUTO_BLOCK_TCPWR_FILE'});
            }
            ### keep track of when we blocked the ip
            $auto_blocked_ips{$src} = time();
        }
    }
    return;
}

sub timeout_auto_blocked_ips() {
    for my $ip (keys %auto_blocked_ips) {
        if ((time() - $auto_blocked_ips{$ip})
                > $config{'AUTO_BLOCK_TIMEOUT'}) {
            if ($config{'IPTABLES_BLOCK_METHOD'} eq 'Y') {
                &Psad::sendmail(" ** psad: removed iptables block " .
                    "against $ip (timeout expired).", '',
                    $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
                &ipt_remove_block($ip);
            }
            if ($config{'IPCHAINS_BLOCK_METHOD'} eq 'Y') {
                &Psad::sendmail(" ** psad: removed ipchains block " .
                    "against $ip (timeout expired)", '',
                    $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
                &ipch_remove_block($ip);
            }
            if ($config{'TCPWRAPPERS_BLOCK_METHOD'} eq 'Y') {
#                &Psad::sendmail(" ** psad: removed tcpwrappers block " .
#                    "against $ip (timeout expired).", '',
#                    $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
#                &tcpwr_remove_block($ip);
            }
            delete $auto_blocked_ips{$ip};
        }
    }
    return;
}

sub get_iptables_chains() {
    $chk_ipt_chains = 1;
    $ipt_chains{'filter'}{'INPUT'}   = '';
    $ipt_chains{'filter'}{'FORWARD'} = '';
    my $nat_rv = (system "$cmds{'iptables'} -nL -t nat " .
        "> /dev/null 2>&1") >> 8;
    my $mangle_rv = (system "$cmds{'iptables'} -nL -t mangle " .
        "> /dev/null 2>&1") >> 8;
    if ($nat_rv == 0) {
        $ipt_chains{'nat'}{'PREROUTING'} = '';
    }
    if ($mangle_rv == 0) {
        $ipt_chains{'mangle'}{'PREROUTING'} = '';
    }
    return;
}

sub write_blocked_ip() {
    my ($src, $file) = @_;
    if (-e $file) {
        open B, ">> $file" or
            die " ** Could not append to $file";
        print B "$src\n";
        close B;
    } else {
        open B, "> $file" or
            die " ** Could not create $file";
        print B "$src\n";
        close B;
    }
    return;
}

sub rm_blocked_ip() {
    my ($src, $file) = @_;
    if (-e $file) {
        open B, "< $file" or
            die " ** Could not open $file: $!";
        my @lines = <B>;
        close B;
        open W, "> $file" or
            die " ** Could not open $file: $!";
        for my $line (@lines) {
            chomp $line;
            print W $line, "\n" unless $line eq $src;
        }
        close W;
    }
    return;
}

sub email_limit_reached() {
    my ($src, $dst) = @_;
    my $subject = " ** psad: email message limit for $src has " .
        "been reached on $hostname ($dst)!!!";
    &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
    return;
}

sub print_scan() {  ### this should primarily be used for debugging
    my $scanfile = "$config{'PRINT_SCAN_HASH'}.$$";
    open PSCAN, "> $scanfile" or warn ' ** Could not open ',
        "$scanfile: $!" and return;
    print PSCAN " ** Passive OS fingerprinting hash:\n";
    print PSCAN Dumper \%posf;
    print PSCAN " ** Scan danger level hash:\n";
    print PSCAN Dumper %scan_dl;
    print PSCAN " ** Main scan hash:\n";
    print PSCAN Dumper \%scan;
    close PSCAN;
    chmod 0600, $scanfile;
    return;
}

sub get_fw_type() {
    my $line = shift;
    if ($line =~ /IN=.+OUT=/) {
        print STDOUT " .. get_fw_type(): firewall is iptables\n" if $debug;
        $use_iptables = 1;
        ### ipchains log messages do not have a MAC address field
    } else {
        print STDOUT " .. get_fw_type(): firewall is ipchains\n" if $debug;
        $use_ipchains = 1;
    }
}

sub get_local_ips() {
    my @ips = `$cmds{'ifconfig'} -a`;
    for my $line (@ips) {
        if ($line =~ /inet\s+addr:($ip_re)\s/) {
            $local_ips{$1} = '';
        }
    }
    return;
}

sub get_listening_ports() {
    %local_ports = ();
    my @lines = `$cmds{'netstat'} -an`;
    for my $line (@lines) {
        chomp $line;
        if ($line =~ m/^\s*(tcp|udp)\s+\d+\s+\d+\s+\S+:(\d+)\s/) {
            ### $1 == protoco (tcp/udp), $2 == port number
            ### convert to upper case to be consistent with iptables
            ### messages (protocol is upper case 'TCP', etc.)
            $local_ports{uc($1)}{$2} = '';
        }
    }
    return;
}

sub get_whois_data() {
    my ($ip, $whois_datafile) = @_;
    my @whois_data;
    if (defined $whois_cache{$ip}
            && $whois_cache{$ip} < $config{'WHOIS_THRESHOLD'}
            && -e $whois_datafile) {
        $whois_cache{$ip}++;
    } else {
        $whois_cache{$ip} = 0;
        eval {
            local $SIG{'ALRM'} = sub {die "whois alarm\n"};
            alarm $config{'WHOIS_TIMEOUT'};
            system "$cmds{'whois'} $ip > $whois_datafile 2> /dev/null";
            alarm 0;
        };
        if ($@) {
            ### die unless $@ eq "whois alarm\n";
            ### warn "$@: $?";  ### let the warning handler save the error.
            warn $@;
            $#whois_data = 0;
            @whois_data = ("Whois data not available!\n");
            unlink $whois_datafile;
            return \@whois_data;
        }
    }
    open W, "< $whois_datafile" or
        die " ** Could not open $whois_datafile: $!";
    @whois_data = <W>;
    close W;
    return \@whois_data;
}

sub REAPER {
    my $pid;
    $pid = waitpid(-1, WNOHANG);
#   if (WIFEXITED($?)) {
#       print STDERR " .. **  Process $pid exited.\n";
#   }
    $SIG{'CHLD'} = \&REAPER;
    return;
}

sub file_permissions() {
    my $file = shift;
    if (-e $file) {
        chmod 0600, $file;
    } else {
        open T, "> $file" or die ' ** Could not open ',
            "$file: $!";
        close T;
        chmod 0600, $file;
    }
    return;
}

sub stop_psad() {
    my $rv = 0;
    ### must kill psadwatchd first since if not, it might try to restart
    ### any of the other three daemons.
    for my $pidname qw(psadwatchd psad kmsgsd diskmond) {
        my $pidfile = $pidfiles{$pidname};
        if (-e $pidfile) {
            open PIDFILE, "< $pidfile" or die ' ** Could not open ',
                "$pidfile: $!";
            my $pid = <PIDFILE>;
            close PIDFILE;
            chomp $pid;
            if (kill 0, $pid) {
                print " .. Stopping $pidname, pid: $pid\n";
                unless (kill 15, $pid) {
                    kill 9, $pid or print " ** psad: Could not kill ",
                        "$pidname, pid: $pid $!\n";
                    $rv = 1;
                }
            } else {
                print " ** psad: $pidname is not running on $hostname.\n";
                $rv = 1;
            }
        } else {
            print " ** psad: pid file $pidfile does not exist for ",
                "$pidname on $hostname\n";
            $rv = 1;
        }
    }
    return $rv;
}

sub restart() {
    my $cmdline;
    if (-e $cmdline_file) {
        open CMD, "< $cmdline_file" or die ' ** Could not open ',
            "$cmdline_file: $!";
        $cmdline = <CMD>;
        close CMD;
        chomp $cmdline;
    } else {
        die " ** psad:  No other psad process is ",
            "running on $hostname!";
    }
    &stop_psad();
    print " .. Restarting the psad daemons on $hostname\n";
    system "$cmds{'psad'} $cmdline";
    return 1;
}

### display the status of all four psad daemons
sub status() {

    ### print the status of a specific ip address
    &status_ip() if $status_ip;

    my $cmdline;
    ### only the psad daemon (normally) runs with command line arguments
    if (-e $cmdline_file) {
        open CMD, "< $cmdline_file" or die ' ** Could not open ',
            "$cmdline_file: $!";
        $cmdline = <CMD>;
        chomp $cmdline;
    }
    my $rv = 0;   ### assume psad is not running and test...
    for my $pidname qw(psad psadwatchd kmsgsd diskmond) {
        my $pidfile = $pidfiles{$pidname};
        if (-e $pidfile) {
            open PIDFILE, "< $pidfile" or die ' ** Could not open ',
                "$pidfile: $!";
            my $pid = <PIDFILE>;
            close PIDFILE;
            chomp $pid;
            if (kill 0, $pid) {
                print " .. $pidname (pid: $pid)";
                my @ps_out = `$cmds{'ps'} -auxww`;
                PS: for my $line (@ps_out) {
                    chomp $line;
                    if ($line =~ /^\S+\s+$pid\s+(\S+)\s+(\S+)/) {
                        print "  %CPU: $1  %MEM: $2\n";
                        print "     Running since: " .
                            localtime(stat($pidfile)->mtime) . "\n";
                        next unless $pidname eq 'psad';
                        if ($cmdline) {
                            print "     Command line arguments: $cmdline\n";
                        } else {
                            print "     Command line arguments: [none specified]\n";
                        }
                        print "     Alert email address(es): ",
                            "$config{'EMAIL_ADDRESSES'}\n";
                        ### print the packet counters
                        if (-e $config{'PACKET_COUNTER_FILE'}) {
                            print "\n     Global packet counters:\n";
                            open F, "< $config{'PACKET_COUNTER_FILE'}" or
                                die " ** $config{'PACKET_COUNTER_FILE'}: $!";
                            print STDOUT "        $_" while (<F>);
                            close F;
                        }
                        ### sort and print the scan source ips
                        my %scan_source_ips;
                        chdir $config{'PSAD_DIR'} or
                            die " ** Could not chdir $config{'PSAD_DIR'}: $!";
                        opendir D, $config{'PSAD_DIR'} or
                            die " ** Could not open dir: $config{'PSAD_DIR'}: $!";
                        my @files = readdir D;
                        closedir D;
                        shift @files; shift @files;
                        for my $file (@files) {
                            if ($file =~ /$ip_re/ && -d $file) {
                                ### $file is a current scan source ip
                                my $src_ipdir = $file;
                                my $dl = 0;
                                my $tcp_ctr = 0;
                                my $udp_ctr = 0;
                                my $icmp_ctr = 0;
                                if (-e "${src_ipdir}/danger_level") {
                                    open F, "< ${src_ipdir}/danger_level" or
                                        die " ** Could not open ",
                                            "${src_ipdir}/danger_level: $!";
                                    $dl = <F>;
                                    close F;
                                    chomp $dl;
                                }
                                if (-e "${src_ipdir}/packet_ctr") {
                                    open F, "< ${src_ipdir}/packet_ctr" or
                                        die " ** Could not open ",
                                            "${src_ipdir}/packet_ctr: $!";
                                    my @lines = <F>;
                                    close F;
                                    for my $line (@lines) {
                                        $tcp_ctr = $1 if $line =~ /tcp:\s+(\d+)/;
                                        $udp_ctr = $1 if $line =~ /udp:\s+(\d+)/;
                                        $icmp_ctr = $1 if $line =~ /icmp:\s+(\d+)/;
                                    }
                                }
                                $scan_source_ips{$dl}{$src_ipdir}{'tcp'}
                                    = $tcp_ctr;
                                $scan_source_ips{$dl}{$src_ipdir}{'udp'}
                                    = $udp_ctr;
                                $scan_source_ips{$dl}{$src_ipdir}{'icmp'}
                                    = $icmp_ctr;
                            }
                        }
                        print STDOUT "\n";
                        printf("     %-18s%-9s%-9s%-9s%-9s\n", 'IP', 'TCP',
                            'UDP', 'ICMP', 'Danger Level');
                        if (%scan_source_ips) {
                            for my $dl (sort {$b <=> $a} keys %scan_source_ips) {
                                for my $src (keys %{$scan_source_ips{$dl}}) {
                                    my $tcp = $scan_source_ips{$dl}{$src}{'tcp'};
                                    my $udp = $scan_source_ips{$dl}{$src}{'udp'};
                                    my $icmp = $scan_source_ips{$dl}{$src}{'icmp'};
                                    printf("     %-18s%-9s%-9s%-9s%-9s\n",
                                        $src, $tcp, $udp, $icmp, $dl);
                                }
                            }
                        } else {
                            print STDOUT "     [No scans detected.]\n";
                        }
                        last PS;
                    }
                }
                print "\n";
                $rv = 1;
            } else {
                print " ** psad: $pidname is not running on $hostname\n";
            }
        } else {
            print " ** psad: pid file $pidfile does not exist for ",
                "$pidname on $hostname\n";
        }
    }
    return $rv;
}

sub status_ip() {
    my $rv = 0;
    my @match_ip;
    die " ** $config{'FW_DATA_FILE'} does not exist yet.  Exiting."
        unless -e $config{'FW_DATA_FILE'};
    die " ** No data yet in $config{'FW_DATA_FILE'}.  Exiting."
        unless -s $config{'FW_DATA_FILE'} > 0;
    die " ** No scans from $status_ip have been detected.\n",
        "    See 'psad --Status' for a complete list."
        unless -d "$config{'PSAD_DIR'}/$status_ip";
    open FW, "< $config{'FW_DATA_FILE'}" or die " ** Could not open ",
        "$config{'FW_DATA_FILE'}: $!";
    while (<FW>) {
        push @match_ip, $_ if $_ =~ /SRC=$status_ip\s/
            || $_ =~ /DST=$status_ip\s/;
    }
    close FW;
    die " ** Could not match $status_ip to packets in $config{'FW_DATA_FILE'}.  ",
        "Exiting." unless @match_ip;
    open D, "> $config{'PSAD_DIR'}/$status_ip/fwdata" or
        die " ** Could not open $config{'PSAD_DIR'}/$status_ip/fwdata";
    for my $line (@match_ip) {
        print D $line;
    }
    for (my $i=$#match_ip; $i>=$#match_ip-10; $i--) {
        print STDOUT $match_ip[$i] if defined $match_ip[$i];
    }
    print STDOUT "\n .. The above packet output shows up to 10 of the ",
        "most recently\n    logged packets for $status_ip.\n";
    print STDOUT " .. All packets logged by iptables specifically for $status_ip\n",
        "    can be viewed here: $config{'PSAD_DIR'}/$status_ip/fwdata\n";
    if (-e "$config{'PSAD_DIR'}/$status_ip/packet_ctr") {
        print STDOUT " .. Packet counters:\n";
        open F, "< $config{'PSAD_DIR'}/$status_ip/packet_ctr" or
            die " ** Could not open $config{'PSAD_DIR'}/$status_ip/",
                "packet_ctr: $!";
        print STDOUT "        $_" for <F>;
        close F;
    }
    if (-e "$config{'PSAD_DIR'}/$status_ip/email_count") {
        open F, "< $config{'PSAD_DIR'}/$status_ip/email_count" or
            die " ** Could not open $config{'PSAD_DIR'}/$status_ip/",
                "email_count: $!";
        my $ec = <F>;
        close F;
        chomp $ec;
        print STDOUT " .. Email alerts sent: $ec\n";
    }
    if (-e "$config{'PSAD_DIR'}/$status_ip/danger_level") {
        open F, "< $config{'PSAD_DIR'}/$status_ip/danger_level" or
            die " ** Could not open $config{'PSAD_DIR'}/$status_ip/",
                "danger_level: $!";
        my $dl = <F>;
        close F;
        chomp $dl;
        print STDOUT " .. Current danger level: $dl\n";
    }
    exit $rv;
}

sub usr1_handler() {
    my $rv = 0;
    my $psad_pidfile = $pidfiles{'psad'};
    if (-e $psad_pidfile) {
        open PIDFILE, "< $psad_pidfile" or
                die " ** Could not open $psad_pidfile: $!";
        my $pid = <PIDFILE>;
        close PIDFILE;
        chomp $pid;
        if (kill 0, $pid) {  ### make sure psad is actually running
            if (kill 'USR1', $pid) {
                $rv = 1;
                print " .. USR1 signal sent to pid: $pid\n";
                for (my $try=0; $try<=20; $try++) {  ### limit attempts to 20
                    sleep 1;
                    print " .. Checking for file: ",
                        "$config{'PSAD_DIR'}/scan_hash.${pid}\n";
                    if (-e "$config{'PSAD_DIR'}/scan_hash.${pid}") {
                        open U, "< $config{'PSAD_DIR'}/scan_hash.${pid}"
                            or print " ** Sent psad pid $pid a USR1 ",
                                "signal, but could not open\n",
                                "\"$config{'PSAD_DIR'}/scan_hash.${pid}\n\""
                            and return $rv;
                        print while(<U>);
                        close U;
                        print " .. Results available here: ",
                            "$config{'PSAD_DIR'}/scan_hash.${pid}\n";
                        last;
                    }
                }
            } else {
                print " ** Could not send psad the USR1 signal on $hostname\n";
            }
        } else {
            print " ** psad is not running on $hostname\n";
        }
    }
    return $rv;
}

sub usr1_sig() {
    $usr1_flag = 1;
    return;
}

sub hup() {
    my $rv = 0;
    for my $pidname qw(psadwatchd psad kmsgsd diskmond) {
        my $pidfile = $pidfiles{$pidname};
        open PID, "< $pidfile" or die " ** Could not open $pidfile: $!";
        my $pid = <PID>;
        close PID;
        chomp $pid;
        if (kill 0, $pid) {
            if (kill 'HUP', $pid) {
                print " .. HUP sent to $pidname (pid: $pid)\n";
            } else {
                print " ** Could not send $pidname ",
                    "(pid: $pid) a HUP signal.\n";
                $rv = 1;
            }
        } else {
            print " ** $pidname daemon not running.\n";
            $rv = 1;
        }
    }
    return $rv;
}

sub hup_handler() {
    $hup_flag = 1;
    return;
}

sub archive_data() {
    chdir $config{'PSAD_DIR'} or die " ** Could not chdir ",
        "$config{'PSAD_DIR'}: $!";
    unless (-d $config{'SCAN_DATA_ARCHIVE_DIR'}) {
        mkdir $config{'SCAN_DATA_ARCHIVE_DIR'}, 0500 or
            die " ** Could not create dir: ",
            "$config{'SCAN_DATA_ARCHIVE_DIR'}: $!";
    }

    ### archive all of the old ip address directories since
    ### we are restarting psad (should add a way to import
    ### these directories back into memory)
    opendir D, $config{'PSAD_DIR'} or die " ** Could not open dir: ",
        "$config{'PSAD_DIR'}: $!";
    my @files = readdir D;
    closedir D;
    shift @files; shift @files;

    for my $file (@files) {
        if ($file =~ /$ip_re/ && -d $file) {
            ### $file is an old scaning ip from a previous psad execution
            my $old_ipdir     = $file;
            my $archive_ipdir = "$config{'SCAN_DATA_ARCHIVE_DIR'}/$old_ipdir";
            if (-d $archive_ipdir) {
                rmtree $archive_ipdir;
            }
            move $old_ipdir, $archive_ipdir;
        }
    }

    ### archive the fwdata file
    my $fwdata    = $config{'FW_DATA_FILE'};
    my $fwarchive = "$config{'SCAN_DATA_ARCHIVE_DIR'}/fwdata_archive";
    ### first see how big the archive file is and zero out if
    ### it is larger than about 10,000 lines
    if (-e $fwarchive && (-s $fwarchive) > 2367766) {  ### about 10,000 lines
        open F, "> $fwarchive" or die ' ** Could not open ',
            "$fwarchive: $!";
        close F;
    }
    unless (-e $fwdata) {
        return;
    }
    open FW, "< $fwdata" or die "$fwdata exists but couldn't open it: $!";
    my @fwlines = <FW>;
    close FW;
    open AR, ">> $fwarchive" or die "Could not open $fwarchive: $!";
    print AR $_ for @fwlines;
    close AR;
    ### zero out $FW_DATA_FILE
    open F, "> $fwdata" or die ' ** Could not open ',
        "$fwdata: $!";
    close F;
    return;
}

sub check_old_cmdargs() {
    &print_old_arg('auto_ips', 'auto-ips') if $oldarg_autoips;
    &print_old_arg('Logging_server', 'log-server') if $oldarg_logserv;
    &print_old_arg('errors', 'no-ipt-errors') if $oldarg_errs;
    &print_old_arg('no_errors', 'no-ipt-errors') if $oldarg_nerrs;
    &print_old_arg('no-errors', 'no-ipt-errors') if $oldarg_nerrs2;
    &print_old_arg('reversedns', 'no-rdns') if $oldarg_rdns;
    &print_old_arg('no_rdns', 'no-rdns') if $oldarg_nrdns;
    &print_old_arg('whois', 'no-whois') if $oldarg_whois;
    &print_old_arg('no_whois', 'no-whois') if $oldarg_nwhois;
    &print_old_arg('no_localport', 'no-localport') if $oldarg_nlport;
    &print_old_arg('localport', 'no-netstat') if $oldarg_netstat;
    &print_old_arg('firewallcheck', 'no-fwcheck') if $oldarg_fwcheck;
    &print_old_arg('no_fw_check', 'no-fwcheck') if $oldarg_nfwchk;
    &print_old_arg('Daemon', 'no-daemon') if $oldarg_daemon;
    return;
}

sub print_old_arg() {
    my ($oldarg, $newarg) = @_;
    print qq( ** The "$oldarg" option has been changed to "$newarg"\n);
    &usage(1);
    return;
}

sub handle_cmdline() {

    ### make sure the psad logfile is where we think it is.
    $psad_logfile = $config{'PSAD_LOG'} unless $psad_logfile;

    ### The -i switch was given
    $config{'PSAD_CHECK_INTERVAL'} = $chk_interval if $chk_interval;

    ### The --snort-rdir switch was given
    $config{'SNORT_RULES_DIR'} = $snort_rules_dir if $snort_rules_dir;

    ### The --signatures switch was given
    $config{'PSAD_SIGS_FILE'} = $sigs_file if $sigs_file;

    ### The --passive-os-file switch was given
    $config{'PSAD_POSD_FILE'} = $posf_file if $posf_file;

    ### The --auto-ips switch was given
    $config{'PSAD_AUTO_IPS_FILE'} = $autoips_file if $autoips_file;

    return;
}

sub setup() {

    ### turn off buffering
    $| = 1;

    ### store the psad command line.
    $cmdline_file = $config{'PSAD_CMDLINE_FILE'};

    ### pid file hash
    %pidfiles = (
        'psadwatchd' => $config{'PSADWATCHD_PID_FILE'},
        'psad'       => $config{'PSAD_PID_FILE'},
        'kmsgsd'     => $config{'KMSGSD_PID_FILE'},
        'diskmond'   => $config{'DISKMOND_PID_FILE'}
    );

    unless (-d $config{'PSAD_DIR'}) {
        mkdir $config{'PSAD_DIR'}, 0500;
    }
    unless (-d $config{'PSAD_ERROR_DIR'}) {
        mkdir $config{'PSAD_ERROR_DIR'}, 0500;
    }
    unless (-e $config{'FW_DATA_FILE'}) {
        open F, "> $config{'FW_DATA_FILE'}" or die ' ** Could not open ',
            "$config{'FW_DATA_FILE'}: $!";
        close F;
    }
    unless (-e $config{'FW_ERROR_LOG'}) {
        open E, "> $config{'FW_ERROR_LOG'}" or die ' ** Could not open ',
            "$config{'FW_ERROR_LOG'}: $!";
        close E;
    }
    unless (-e $config{'PSAD_FIFO'}) {
        system "$cmds{'mknod'} -m 600 $config{'PSAD_FIFO'} p";
    }
    ### make sure the new whois path exists
    if (-x '/usr/bin/whois.psad' && ! -x $cmds{'whois'}
            && '/usr/bin/whois.psad' ne $cmds{'whois'}) {
        move '/usr/bin/whois.psad', $cmds{'whois'};
    }
    unless (-e '/etc/syslog.conf.orig') {
        copy('/etc/syslog.conf', '/etc/syslog.conf.orig');
    }
    ### look for psadfifo in some system logger config file
    ### (syslog, syslog-ng, etc.).
    my $found_logger = 0;
    if (-e '/etc/syslog.conf') {
        open RS, '< /etc/syslog.conf' or
            die " ** Unable to open /etc/syslog.conf: $!";
        my @lines = <RS>;
        close RS;
        my $found = 0;
        for my $line (@lines) {
            if ($line =~ m/|\s*$config{'PSAD_FIFO'}/) {
                $found = 1;
                $found_logger = 1;
            }
        }
        unless ($found) {
            open SYSLOG, '> /etc/syslog.conf' or
                die " ** Unable to open /etc/syslog.conf: $!";
            for my $line (@lines) {
                unless ($line =~ /psadfifo/) {
                    print SYSLOG $line;
                }
            }
            ### reinstate kernel logging to our named pipe
            print SYSLOG '### Send kern.info messages to psadfifo for ',
                "analysis by kmsgsd\n";
            print SYSLOG "kern.info\t\t|$config{'PSAD_FIFO'}\n";
            close SYSLOG;
            system "$cmds{'killall'} -HUP $cmds{'syslogd'}";
        }
    }
    if (-e '/etc/syslog-ng/syslog-ng.conf') {
        open RS, '< /etc/syslog-ng/syslog-ng.conf' or
            die " ** Unable to open /etc/syslog-ng/syslog-ng.conf: $!\n";
        my @lines = <RS>;
        close RS;

        my $found = 0;
        for my $line (@lines) {
            if ($line =~ m/|\s*$config{'PSAD_FIFO'}/) {
                $found = 1;
                $found_logger = 1;
            }
        }
        unless ($found) {
            open SYSLOGNG, '>> /etc/syslog-ng/syslog-ng.conf' or
                die " ** Unable to open /etc/syslog-ng/syslog-ng.conf: $!\n";
            print SYSLOGNG "\n";
            print SYSLOGNG 'destination psadpipe { pipe(',
                "\"/var/run/psadfifo\"); };\n";
            print SYSLOGNG "filter f_kerninfo { facility(kern) ",
                "and level(info); };\n";
            print SYSLOGNG 'log { source(src); ',
                "filter(f_kerninfo); destination(psadpipe); };\n";
            close SYSLOGNG;
            system "$cmds{'killall'} -HUP syslog-ng";
        }
    }
    unless ($found_logger) {
        die " ** Could not find $config{'PSAD_FIFO'} in any system logger ",
            "config file.  Exiting.";
    }
    ### make sure the permissions on these files is 0600
    &file_permissions($config{'FW_DATA_FILE'});
    &file_permissions($config{'FW_ERROR_LOG'});
    return;
}

sub fw_check() {
    my $rv = 0;
    if (defined $cmds{'iptables'} && -x $cmds{'iptables'}) {
        unlink $config{'FW_CHECK_FILE'} if -e $config{'FW_CHECK_FILE'};
        my $input_rv = &ipt_chk_chain('INPUT');
        my $forward_rv = &ipt_chk_chain('FORWARD');
        if ($input_rv && $forward_rv) {
            &Psad::logr(" .. The iptables ruleset on $hostname will log and " .
                "block unwanted packets in both the INPUT and FORWARD " .
                "chains.  Firewall config success!\n",
                {$config{'FW_CHECK_FILE'} => 1});
            $rv = 1;
        } else {
            &Psad::logr("\n", {$config{'FW_CHECK_FILE'} => 1});
            &Psad::logr(' .. NOTE: IPTables::Parse does not yet parse user ' .
                'defined chains and so it is possible your firewall config ' .
                "is compatible with psad anyway.\n",
                {$config{'FW_CHECK_FILE'} => 1});
            &Psad::sendmail(" ** psad: firewall setup warning on $hostname!",
                $config{'FW_CHECK_FILE'},
                $config{'EMAIL_ADDRESSES'},
                $cmds{'mail'}
            );
        }
    } else {
        $rv = &Psad::check_firewall_rules(
            $config{'FW_MSG_SEARCH'},  ### SNORT_SID_STR is normally used for
                                       ### snort "sid" values so don't include
                                       ### it within the firewall check
            $config{'EMAIL_ADDRESSES'},
            $config{'FW_CHECK_FILE'},
            \%cmds
        );
    }
    if ($fw_analyze) {
        if ($rv) {
            print localtime() . " .. Firewall config looks good.\n";
            print localtime() . " .. Completed check of firewall ruleset.\n";
        } else {
            print localtime() . " ** Errors found in firewall config.\n";
            print localtime() . " ** Results in " .
                "$config{'FW_CHECK_FILE'}\n";
            print localtime() . "    emailed to ",
                "$config{'EMAIL_ADDRESSES'}\n";
        }
        print localtime() . " .. Exiting.\n";
        exit 0;
    }
}

### should probably make this into its own script
sub ipt_chk_chain() {
    my $chain = shift;

    my $rv = 1;

    ### check to see if there are multiple interfaces on the
    ### machine and return true by default for the FORWARD
    ### chain if no since the machine will not be able to
    ### forward packets anyway (e.g. desktop machines).  Also
    ### return true by default if forwarding is turned off
    ### we have to trust the machine config is as the admin
    ### wants it).
    if ($chain eq 'FORWARD') {
        my $forwarding;
        if (-e $config{'PROC_FORWARD_FILE'}) {
            open F, "< $config{'PROC_FORWARD_FILE'}"
                or die " ** Could not open $config{'PROC_FORWARD_FILE'}: $!";
            $forwarding = <F>;
            close F;
            chomp $forwarding;
            print " .. forwarding value: $forwarding\n" if $debug;
            return $rv if $forwarding == 0;
        } else {
            die " ** Make sure the path to the ip forwarding file correct.\n",
                "    The PROC_FORWARD_FILE in $config_file points to\n",
                "    $config{'PROC_FORWARD_FILE'}";
        }
        my @if_out = `$cmds{'ifconfig'} -a`;
        my $num_intf = 0;
        for my $line (@if_out) {
            if ($line =~ /inet\s+addr/i && $line !~ /127\.0\.0\.1/) {
                $num_intf++;
            }
        }
        print " .. number of interfaces: $num_intf\n" if $debug;
        if ($num_intf < 2) {
            return $rv;
        }
    }

    my $ipt = new IPTables::Parse 'iptables' => $cmds{'iptables'};

    if ($fw_analyze) {
        print localtime() . " .. Parsing iptables $chain chain rules.\n";
    }
    ### for now we are only looking at the filter table, so if
    ### the iptables ruleset includes the log and drop rules in
    ### a user defined chain then psad will not see this.
    my $ld_hr = $ipt->default_drop('filter', $chain);

    print Dumper $ld_hr if $debug;

    my $fwc = $config{'FW_CHECK_FILE'};
    if (defined $ld_hr && keys %$ld_hr) {
        my @protos;
        my $found_all = 0;
        if (defined $ld_hr->{'all'}) {
            @protos = qw(all);
            $found_all = 1;
        } else {
            @protos = qw(tcp udp icmp);
        }
        for my $proto (@protos) {
            my $str1;
            my $str2;
            if (! defined $ld_hr->{$proto}->{'LOG'}) {
                if ($proto eq 'all') {
                    $str1 = "for all protocols";
                    $str2 = 'scans';
                } else {
                    $str1 = "for the $proto protocol";
                    $str2 = "$proto scans";
                }
                &Psad::logr(" ** The $chain chain in the iptables ruleset on " .
                    "$hostname does not include a default LOG rule $str1.  " .
                    "psad will not be able to detect $str2 without such a " .
                    "rule.\n",
                    {$fwc => 1});
                &Psad::logr("\n", {$fwc => 1});
                $rv = 0;
            }
            if (defined $ld_hr->{$proto}->{'LOG'}->{'prefix'}
                    && $ld_hr->{$proto}->{'LOG'}->{'prefix'}
                    !~ /$config{'FW_MSG_SEARCH'}/) {
                if ($proto eq 'all') {
                    $str1 = " ** The $chain chain in the iptables ruleset " .
                    "on $hostname includes a default LOG rule for all " .
                    "protocols,";
                    $str2 = 'scans';
                } else {
                    $str1 = " ** The $chain chain in the iptables ruleset " .
                    "on $hostname inclues a default LOG rule for the $proto " .
                    "protocol,";
                    $str2 = "$proto scans";
                }
                &Psad::logr("$str1 but the rule does not have a log prefix " .
                    qq(of "$config{'FW_MSG_SEARCH'}".  It appears as though ) .
                    qq(the log prefix is set to "$ld_hr->{$proto}->{'LOG'}->{'prefix'}".) .
                    qq(  psad will not be able to detect $str2 without adding ) .
                    qq(--log-prefix "$config{'FW_MSG_SEARCH'}" to the rule.\n),
                    {$fwc => 1});
                &Psad::logr("\n", {$fwc => 1});
                $rv = 0;
            }
            if (! defined $ld_hr->{$proto}->{'DROP'}) {
                if ($proto eq 'all') {
                    $str1 = "for all protocols";
                } else {
                    $str1 = "for the $proto protocol";
                }
                &Psad::logr(" ** The $chain chain in the iptables ruleset on " .
                    "$hostname does not include a default DROP rule $str1.\n",
                    {$fwc => 1});
                &Psad::logr("\n", {$fwc => 1});
                $rv = 0;
            }
            if ($found_all) {  ### avoid $ld_hr->{'all'} auto vivification
                return $rv;
            }
        }
        unless ($found_all) {
            &Psad::logr(' ** The best way to fix the above errors is to ' .
                'first setup iptables to accept traffic that you need ' .
                "to/through the iptables $chain chain, and then execute the " .
                "following commands:\n", {$fwc => 1});
            &Psad::logr("        iptables -A $chain -j LOG --log-prefix " .
                qq("$config{'FW_MSG_SEARCH'}"\n), {$fwc => 1});
            &Psad::logr("        iptables -A $chain -j DROP\n",
                {$fwc => 1});
        }
    } else {
        &Psad::logr(" ** The $chain chain in the iptables ruleset on " .
            "$hostname does not include default rules that will log and " .
            'drop unwanted packets. You need to include two default rules; '.
            'one that logs packets that have not been accepted by previous ' .
            'rules (this rule should have a logging prefix of ' .
            "\"$config{'FW_MSG_SEARCH'}\"), and a final rule that drops any " .
            "unwanted packets.\n",
            {$fwc => 1});
        &Psad::logr("\n", {$fwc => 1});
        &Psad::logr('    FOR EXAMPLE:  Assuming you have already setup ' .
            'iptables rules to accept traffic you want to accept, you can ' .
            'probably execute the following two commands to have iptables ' .
            "log and drop unwanted packets in the $chain chain by " .
            "default.\n",
            {$fwc => 1});
        &Psad::logr("\n", {$fwc => 1});
        &Psad::logr("              iptables -A $chain -j LOG --log-prefix " .
            qq(" $config{'FW_MSG_SEARCH'}"\n), {$fwc => 1});
        &Psad::logr("              iptables -A $chain -j DROP\n\n",
            {$fwc => 1});
        &Psad::logr(" ** Psad will not detect in the iptables $chain chain " .
            'scans without an iptables ruleset that includes rules similar ' .
            "to the two rules above.\n",
            {$fwc => 1});
        &Psad::logr("\n", {$fwc => 1});
    }
    return;
}

sub dump_conf() {
    for my $var (sort keys %config) {
        printf("%-30s %s\n", " .. $var", $config{$var});
    }
    return 0;
}

sub required_vars() {
    my @required_vars = qw(
        EMAIL_ADDRESSES PSAD_CHECK_INTERVAL FW_DATA_FILE FW_ERROR_LOG
        FW_MSG_SEARCH SNORT_SID_STR ENABLE_AUTO_IDS PSAD_LOG
        IGNORE_CONNTRACK_BUG_PKTS SCAN_TIMEOUT DANGER_LEVEL1
        DANGER_LEVEL2 DANGER_LEVEL3 DANGER_LEVEL4 DANGER_LEVEL5
        PORT_RANGE_SCAN_THRESHOLD ALERT_ALL PSAD_EMAIL_LIMIT
        IPTABLES_BLOCK_METHOD IPCHAINS_BLOCK_METHOD
        TCPWRAPPERS_BLOCK_METHOD EMAIL_ALERT_DANGER_LEVEL
        PSAD_FIFO WHOIS_THRESHOLD WHOIS_TIMEOUT SNORT_RULES_DIR
        PACKET_COUNTER_FILE SCAN_DATA_ARCHIVE_DIR
        PROC_FORWARD_FILE ENABLE_PERSISTENCE AUTO_BLOCK_IPT_FILE
        AUTO_BLOCK_IPCH_FILE AUTO_BLOCK_TCPWR_FILE PSAD_SIGS_FILE
        PSAD_AUTO_IPS_FILE AUTO_BLOCK_TIMEOUT EXTERNAL_SCRIPT
        ENABLE_EXT_SCRIPT_EXEC EXEC_EXT_SCRIPT_PER_ALERT
        ENABLE_DSHIELD_ALERTS DSHIELD_ALERT_INTERVAL
        DSHIELD_ALERT_EMAIL DSHIELD_USER_ID DSHIELD_USER_EMAIL
    );
    &Psad::defined_vars(\%config, $config_file, \@required_vars);
    return;
}

sub usage() {
    my $exitcode = shift;
    print <<_HELP_;

psad; the Port Scan Attack Detector
 .. Version: $version
 .. By Michael Rash (mbr\@cipherdyne.org, http://www.cipherdyne.org)

Usage: psad [-a <auto ips file>] [-c <config file>] [-l] [-i <interval>]
       [-h] [-B] [-F] [-S] [-K] [-R] [-U] [-V] [-f] [-o] [-p] [-D] [-d]
       [--signatures <sig file>] [--passive-os-sigs <posf file>]
       [--snort-sids] [--snort-type <type>] [--snort-rdir <rules dir>]
       [--interval <seconds>] [--ip-status <ip>] [--no-fwcheck]
       [--no-daemon] [--no-rdns] [--no-whois] [--no-netstat]
       [--no-ipt-errors] [--no-passiveos]

Options:
    --signatures <sigs file>      - Manually specify the path to the
                                    psad signatures file.
    --passive-os-sigs <sigs file> - Manually specify the path to the
                                    passive os fingerprinting sigs.
    --snort-sids                  - Enable psad to look for snort sids
                                    in iptables log messages such as
                                    those generated by fwsnort.
    --snort-type                  - Enable psad to look for specific
                                    snort sids such as those in
                                    ddos.rules or backdoor.rules.
    --interval                    - Configure the check interval from
                                    the command line to override the 15
                                    second default.
    -a   --auto-ips <ips file>    - Import auto ips file for automatic
                                    ip danger level increases/decreses.
    -c   --config <config file>   - Use <config file> instead of the
                                    normal config file located at
                                    $config_file.
    -f   --fw-check               - Analyze the local firewall ruleset
                                    and exit.
    -d   --debug                  - Run psad in debugging mode.
    -D   --Dump-conf              - Dump psad configuration on STDOUT
                                    and exit.
    -o   --output                 - Print all messages to STDOUT (this
                                    does not include bad packet messages
                                    that are printed to the error log).
    -l   --log-server             - Psad is being run on a syslog
                                    logging server.
    -F   --Flush                  - Remove any auto-generated firewall
                                    block rules.
    -K   --Kill                   - Kill all running psad processes.
    -R   --Restart                - Restart all running psad processes.
    -S   --Status                 - Displays the status of any
                                    currently running psad processes.
    --ip-status    <ip address>   - View status for a specific ip.
    -B   --Benchmark              - run psad in benchmark mode.
    -p   --packets                - Specify number of packets to use in
                                    benchmark test.
    -U   --USR1                   - Send a running psad process a USR1
                                    signal (generates a dump of psad
                                    data structures on STDOUT).
    -H   --HUP                    - Send all psad daemons a HUP signal
                                    to have them re-import configs.
    -V   --Version                - Print the psad version and exit.

    --no-signatures               - Disable signature processing.
    --no-auto-ips                 - Disable auto danger level assignment.
    --no-daemon                   - Do not run as a daemon.
    --no-ipt-errors               - Do not write errors to the error
                                    log.
    --no-whois                    - Disable whois lookups.
    --no-fwcheck                  - Disable firewall rules verification.
    --no-rdns                     - Disable name resolution against
                                    scanning ips.
    --no-netstat                  - Disable local port lookups for scan
                                    signatures.
    -h   --help                   - Display usage on STDOUT and exit.

_HELP_
    exit $exitcode;
}
