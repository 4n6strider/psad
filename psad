#!/usr/bin/perl -w
#
# Description: Port Scan Attack Detector (psad)
# - uses ipchains/iptables logs.  Uses input from /var/log/psad/fwdata generated by
# kmsgsd
#
# version 0.8.0
# Copyright (C) 1999-2001 Michael B. Rash (mbr@cipherdyne.com)
# Thanks to Manuel Caphina for greatly assisting in the original version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#	IDEA: how about a signal handler that dumps the contents
#	of the %Scan hash to a file upon receiving a specific signal?
#
# TODO: 
#	- make line counts of fwdata file take high-rate scans into
#	  account.
#	- signal handler for configuration checking (implies we have a 
#	  config file).
#	- "ignore ips" file
#
# Sample packet (rejected by ipchains)
# Dec 19 11:54:07 orthanc kernel: Packet log: input REJECT lo PROTO=1
# 10.0.0.4:3127.0.0.1:3 L=88 S=0xC0 I=49513 F=0x0000 T=255
#
# Sample packet (rejected by iptables... --log-prefix = "DENY")
# Mar 11 13:15:52 orthanc kernel: DENY IN=lo OUT= MAC=00:00:00:00:00:00:00:00:00:00:00:00:08:00
# SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=44847 
# DPT=35 WINDOW=32304 RES=0x00 SYN URGP=0
#
# There may be a bug in iptables, since occasionally log entries are generated 
# by a long port scan like this (note there is no 'DPT' field: 
#   Mar 16 23:50:25 orthanc kernel: DENY IN=lo OUT= MAC=00:00:00:00:00:00:00:00:00:00:00:00:08:00 
#   SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=39935 
#   DINDOW=32304 RES=0x00 SYN URGP=0
#
#
#==================== config =======================
# Initialize config variables.  Some can be overriden with command line args
my $PSAD_LOGFILE = "/var/log/psad/scanlog";
my $FW_DATA = "/var/log/psad/fwdata";
my $ERROR_LOG = "/var/log/psad/fwerrorlog";
my $EMAIL_ALERTFILE = "/var/log/psad/email_alert";
$PRINT_SCAN_HASH = "/var/log/psad/scan_hash.$$";  # global for sub print_scan
my $CHECK_INTERVAL = 5;
my $PORT_RANGE_SCAN_THRESHOLD = 1;
my %DANGER_LEVELS;
$DANGER_LEVELS{'1'} = 10;
$DANGER_LEVELS{'2'} = 50;
$DANGER_LEVELS{'3'} = 1000;
$DANGER_LEVELS{'4'} = 5000;
$DANGER_LEVELS{'5'} = 10000;
my $ENABLE_EMAIL_ALERTS = "Y";
my $EMAIL_ALERT_DANGER_LEVEL = 1;  # Send email alert if danger level >= to this value
my $EMAIL_ADDRESS = "root\@localhost";  # Email the alert to this address
my $ENABLE_AUTO_IDS = "N"; 	# Automated IDS response #
my $AUTO_IDS_DANGER_LEVEL = 5;  # Block all traffic from offending IP if danger level >= to this value 

# system binaries
my $ipchainsCmd = "/sbin/ipchains";
my $iptablesCmd = "/usr/local/bin/iptables";
my $wcCmd = "/usr/bin/wc";
my $tailCmd = "/usr/bin/tail";
my $mailCmd = "/bin/mail";
my $touchCmd = "/bin/touch";
#================== end config ====================
#===================== main =======================

$USE_IPCHAINS = 0;      # these two are global variables
$USE_IPTABLES = 0;

my $Scan_href;  # contains ips, port ranges, tcp flags, and danger levels
# my $port_to_service_href = read_services("/etc/services");    Could implement this...
my $daemon = 0;
my $output = 0;
my $errors = 0;
my $dnslookups = 0;
my $dnsstring;

use Getopt::Long;
use Data::Dumper;
use Socket;

$SIG{USR1} = \&print_scan;  # install signal handler for debugging the %Scan hash with Data::Dumper

usage_and_exit(1) unless (GetOptions (
        'help'          => \$help,
	'output'	=> \$output,
	'daemon'	=> \$daemon,
	'config=s'	=> \$config,
	'namelookups'	=> \$dnslookups,
	'errors'	=> \$errors
));
usage_and_exit(0) if ($help);

fork and exit unless ($daemon);

if ($config) {
	open CONF, "< $config";
	eval $_ while(<CONF>);
	close CONF;
}	
unless ($errors) {
	open ERR, ">> $ERROR_LOG";
	print ERR "============= psad: pid $$ ===============\n";
	close ERR;
}
`$touchCmd $FW_DATA` unless (-e $FW_DATA);
# main loop
for (;;) {
	$fwdata_start_lines = (split /\s+/, `$wcCmd -l $FW_DATA`)[1];
#	print "Current number of lines: $fwdata_start_lines\n";   # this will be useful for the TODO
	sleep $CHECK_INTERVAL;
	$fwdata_end_lines = (split /\s+/, `$wcCmd -l $FW_DATA`)[1];
	if ($fwdata_end_lines - $fwdata_start_lines > 0) {
		my $grabnum = $fwdata_end_lines - $fwdata_start_lines;
		my @process_lines = `$tailCmd -$grabnum $FW_DATA`;
#		print "Number of lines to process: $#process_lines\n";  # this will be useful for the TODO
		$Scan_href = check_scan(\@process_lines, $errors, $ERROR_LOG);
		$Scan_href = assign_danger_level($Scan_href, $PORT_RANGE_SCAN_THRESHOLD, \%DANGER_LEVELS);
		($Scan_href, $mesg, $flags_mesg, $dnsstring) = logr($Scan_href, $PSAD_LOGFILE, $output, $dnslookups);
		if ($ENABLE_EMAIL_ALERTS eq "Y") {
			$Scan_href = email_alert($Scan_href, $mesg, $flags_mesg, $dnsstring, $EMAIL_ALERT_DANGER_LEVEL, 
							$EMAIL_ALERTFILE, $EMAIL_ADDRESS, $mailCmd);	
		}
		if ($ENABLE_AUTO_IDS eq "Y") {
			$Scan_href = auto_psad_response($Scan_href, $AUTO_IDS_DANGER_LEVEL, 
									$ipchainsCmd, $iptablesCmd);
		}
	}
}

#================== end main ======================
sub check_scan() {  # keeps track of scanning ip's, increments packet counters, keep track of tcp flags for each
		    # scan (iptables only)
		# include udp/icmp scans
	my ($process_lines_aref, $errors, $error_log) = @_;
	my @bad_packets;
	my ($srcip, $dstip, $proto, $port, $flags);
	# if necessary check which firewall (ipchains vs. iptables)
	check_fw($process_lines_aref->[0]) unless ($USE_IPCHAINS || $USE_IPTABLES);
	READPKT: foreach my $l (@$process_lines_aref) {
		chomp $l;
		if ($USE_IPTABLES) {
			# sometimes the log entry is messed up by iptables so we right it to the error log
			if ($l =~ /SRC\=(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\sDST\=(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s.+?PROTO\=(\w{3,4})\s.+?DPT\=(\d+)\s.+?RES\S+\s(.+?)\s+URGP/) {
				 ($srcip, $dstip, $proto, $port, $flags) = ($1,$2,$3,$4,$5);
			} else {
				push @bad_packets, $l;
				next READPKT;
			}
			# double check packet
			unless ($flags =~ /SYN|FIN|URG|PSH/ && $flags !~ /LEN|TOS|PREC|PROTO|WINDOW|RES/) {
				push @bad_packets, $l;
                                next READPKT;
                        }
		} elsif ($USE_IPCHAINS) {
			# could implement source port checking here
			if ($l =~ /PROTO\=(\d+)\s(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\:\d+\s(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\:(\d+)/) {
				($proto, $srcip, $dstip, $port) = ($1,$2,$3,$4);
				$flags = "NONE";
			} else {
				push @bad_packets, $l;
                                next READPKT;
                        }
		}
		# hash initialization
		$Scan{$srcip}{'ABSNUM'} = 0 unless (defined $Scan{$srcip});
		$Scan{$srcip}{'DSTIP'} = $dstip unless (defined $Scan{$srcip}{'DSTIP'});
		$Scan{$srcip}{'FLAGS'}{$flags} = 0 unless (defined $Scan{$srcip}{'FLAGS'}{$flags});
		$Scan{$srcip}{'CURRENT_DANGER_LEVEL'} = 0 unless (defined $Scan{$srcip}{'CURRENT_DANGER_LEVEL'});
		unless (defined $Scan{$srcip}{'SCAN_RANGE'}) {
			$Scan{$srcip}{'SCAN_RANGE'}{'START_PORT'} = 65535; # make sure the initial start port is not too low
			$Scan{$srcip}{'SCAN_RANGE'}{'END_PORT'} = 0; # make sure the initial end port is not too high
		}
		# increment hash values
		$Scan{$srcip}{'ABSNUM'}++;
		$Scan{$srcip}{'FLAGS'}{$flags}++;
		# see if this port lies outside our current range
		($Scan{$srcip}{'SCAN_RANGE'}{'START_PORT'}, $Scan{$srcip}{'SCAN_RANGE'}{'END_PORT'}) = 
				check_range($port, $Scan{$srcip}{'SCAN_RANGE'}{'START_PORT'}, $Scan{$srcip}{'SCAN_RANGE'}{'END_PORT'});
	}
	collect_errors(\@bad_packets, $error_log) unless $errors;
	return \%Scan;
}
sub check_range() {
	my ($port, $start, $end) = @_;
	$start = $port if ($port < $start);
	$end = $port if ($port > $end);
	return $start, $end;
}
sub assign_danger_level() {
	my ($Scan_href, $port_range_scan_threshold, $danger_levels_href) = @_;
	foreach my $ip (keys %$Scan_href) {
		my $absnum = $Scan_href->{$ip}->{'ABSNUM'};
		my $range = $Scan_href->{$ip}->{'SCAN_RANGE'}->{'END_PORT'} - $Scan_href->{$ip}->{'SCAN_RANGE'}->{'START_PORT'};
		# if $port_range_scan_threshold is >= 1, then psad will not assign a danger level to repeated packets to the same port
		$Scan_href->{$ip}->{'CURRENT_DANGER_LEVEL'} = 1 if ($absnum >= $danger_levels_href->{'1'} && $range >= $port_range_scan_threshold);
		$Scan_href->{$ip}->{'CURRENT_DANGER_LEVEL'} = 2 if ($absnum >= $danger_levels_href->{'2'} && $range >= $port_range_scan_threshold);
		$Scan_href->{$ip}->{'CURRENT_DANGER_LEVEL'} = 3 if ($absnum >= $danger_levels_href->{'3'} && $range >= $port_range_scan_threshold);
		$Scan_href->{$ip}->{'CURRENT_DANGER_LEVEL'} = 4 if ($absnum >= $danger_levels_href->{'4'} && $range >= $port_range_scan_threshold);
		$Scan_href->{$ip}->{'CURRENT_DANGER_LEVEL'} = 5 if ($absnum >= $danger_levels_href->{'5'} && $range >= $port_range_scan_threshold);
	}
	return $Scan_href;
}
sub collect_errors() {
	my ($bad_packets_aref, $error_log) = @_;
	open ERRORS, ">> $error_log";
	foreach my $l (@$bad_packets_aref) {
		print ERRORS "$l\n";
	}
	close ERRORS;
}
sub logr() {
	my ($Scan_href, $logfile, $output, $dnslookups) = @_;
	my $mesg;
	my $flags_mesg;
	my $hndl;
	my $dnsstring = 0;
       	if ($output) {
                $hndl = "STDOUT";
       	} else {
		$hndl = "LOG"; 
		open LOG, ">> $logfile";
       	}
	foreach my $ip (keys %$Scan_href) {
		if ($Scan_href->{$ip}->{'CURRENT_DANGER_LEVEL'} >= 1) {
			my $start_range = $Scan_href->{$ip}->{'SCAN_RANGE'}->{'START_PORT'};
			my $end_range = $Scan_href->{$ip}->{'SCAN_RANGE'}->{'END_PORT'};
			my $dstip = $Scan_href->{$ip}->{'DSTIP'};
                        my @time = split / /, scalar localtime;   ### Get the current time as a nice ASCII string.
                        pop @time; shift @time;    ### Get rid of the day and the year to make the time consistent with syslog
                        my $time = join ' ', @time;
			$mesg = join ' ', $time, "PORTSCAN DETECTED  Source: $ip  Destination: $dstip  Port_Range: [$start_range-$end_range]  Total_Packets: $Scan_href->{$ip}->{'ABSNUM'}  Danger_Level: [$Scan_href->{$ip}->{'CURRENT_DANGER_LEVEL'} out of 5]";
			print $hndl "$mesg\n";
			unless ($dnslookups) {
				my $ipaddr = gethostbyname($ip);
				my $rdns = gethostbyaddr($ipaddr, AF_INET);
				$rdns = "No reverse dns info available" unless $rdns;
				$dnsstring = "DNS: $ip -> $rdns";
				print $hndl "$dnsstring\n"
			}
			if ($USE_IPTABLES) {
				print $hndl "   --- Scan Signature: ---\n";
				$flags_mesg = "   --- Scan Signature: ---\n";
				foreach my $flags (keys %{$Scan_href->{$ip}->{'FLAGS'}}) {
					my $nmapOpts = 0;
					$nmapOpts = "-sT or -sS" if ($flags eq "SYN");
					$nmapOpts = "-sF" if ($flags eq "FIN");
					$nmapOpts = "-sX" if ($flags eq "URG PSH FIN"); 
					print $hndl "   TCP_flags: [$flags]  Number_of_packets: $Scan_href->{$ip}->{'FLAGS'}->{$flags}";
					if ($nmapOpts) {
						print $hndl "  Nmap_option: [$nmapOpts]\n";
						$flags_mesg = join '  ', $flags_mesg, "   TCP_flags: [$flags]  Number_of_packets: $Scan_href->{$ip}->{'FLAGS'}->{$flags}  Nmap_option: [$nmapOpts]\n";
					} else {
						print $hndl "\n";
						$flags_mesg = join '  ', $flags_mesg, "   TCP_flags: [$flags]  Number_of_packets: $Scan_href->{$ip}->{'FLAGS'}->{$flags}\n";
					}
				}
			} else {
				$flags_mesg = 0;
			}
		}
	}
	close LOG unless $output;
	return $Scan_href, $mesg, $flags_mesg, $dnsstring;
}
sub auto_psad_response(){
        my ($Scan_href, $auto_psad_level, $ipchainsCmd, $iptablesCmd) = @_;
	foreach my $ip (keys %$Scan_href) {
		my $current_danger_level = $Scan_href->{$ip}->{'CURRENT_DANGER_LEVEL'};
		### We only want to block the IP once
        	if ($current_danger_level >= $auto_psad_level && !(defined $Scan_href->{$ip}->{'BLOCKED'})) {
                	if ($USE_IPCHAINS) {
                        	my @chains = get_input_chains("ipchains", $ipchainsCmd);
                        	foreach my $inchain (@chains) {
                                	`$ipchainsCmd -I $inchain 1 -s $ip -l -j DENY`;
                        	}
				$Scan_href->{$ip}->{'BLOCKED'} = "Y";
                	} elsif ($USE_IPTABLES) {
                        	my @chains = get_input_chains("iptables", $iptablesCmd);
                        	foreach my $inchain (@chains) {
                                	`$iptablesCmd -I $inchain 1 -s $ip -j DROP`;
                        	}
				$Scan_href->{$ip}->{'BLOCKED'} = "Y";
                	}
		}
        }
	return $Scan_href;
}
sub get_input_chains() {
        my $fw = shift;
	my $fwCmd = shift;
        my @rules;
        my @chains;
        @rules = `$fwCmd -L`;
        foreach my $r (@rules) {
                next unless ($r =~ /Chain/);
                my ($cname) = ($r =~ /Chain\s(\w+)/);
                next unless ($cname =~ /in/i);  # we don't have an input chain
                push @chains, $cname;
        }
        return @chains;
}
sub email_alert(){
        my ($Scan_href, $mesg, $flags_mesg, $dnsstring, $email_danger_level, $email_alertfile, $email_address, $mailCmd) = @_;
	foreach my $ip (keys %$Scan_href) {
		my $current_danger_level = $Scan_href->{$ip}->{'CURRENT_DANGER_LEVEL'};
        	if ($current_danger_level >= $email_danger_level && 
				!(defined $Scan_href->{$ip}->{$current_danger_level}->{'ALERTED'})) {
        		### Send the email once for each danger level greater than $EMAIL_ALERT_DANGER_LEVEL, but not more
        		### than once.  The administrator should take appropriate action once an email has been sent.
                	open EMAILALERT, "> $email_alertfile";
                	print EMAILALERT "$mesg\n";
			print EMAILALERT "$dnsstring\n" if $dnsstring;
			print EMAILALERT "$flags_mesg\n" if $flags_mesg;
                	close EMAILALERT;
        		system("$mailCmd $EMAIL_ADDRESS -s \"psad WARNING: You have been scanned!\" < $email_alertfile");
			$Scan_href->{$ip}->{$current_danger_level}->{'ALERTED'} = "Y";
		}
	}
	return $Scan_href;
}
sub print_scan() {  # this should primarily be used for debugging
	open PSCAN, "> $PRINT_SCAN_HASH";
	print PSCAN Dumper $Scan_href;
	close PSCAN;
	return;
}
sub check_fw() {
	my $line = shift;
	if ($line !~ /MAC/) {
		$USE_IPCHAINS = 1;
	} else {
		$USE_IPTABLES = 1;
	}
}	
#sub read_services() {
#	my $service_file = shift;
#	my %service_hash;
#	my $fh = open SERVICES, "< $service_file" or warn "Could not open file /etc/services : ports will not be resolved to services\n";
#	if ($fh) {
#		while(<SERVICES>) {
#			my $line;
#			chomp($line = $_);
#			next if ($line =~ /^#/ || ! $line);
#			my ($val, $key) = ($line =~ /^(\S+)\s+(\S+)/);
#			$key =~ s/\///;
#			$service_hash{$key} = $val;
#		}
#	}
#	close SERVICES;
#	return \%service_hash;
#}
sub usage_and_exit() {
        my $exitcode = shift;
        print <<_HELP_;

Usage: psad [-d] [-o] [-e] [-c <config file>] [-h]

        -daemon			- do not run as a daemon.
	-error			- do not write errors to the error log.
	-output			- print all messages to STDOUT (this 
				  does not include bad packet messages
				  that are printed to the error log).
	-config <config file>	- use config file instead of the values
				  contained within the psad script.
	-namelookups		- disable name resolution against
				  scanning ips.
        -h                      - prints this help message.

_HELP_
        exit $exitcode;
}
