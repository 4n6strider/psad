#!/usr/bin/perl -w
#
################################################################################
#
# File: psad
#
# Purpose: psad makes use of ipchains/iptables logs to detect port scans,
#          probes for backdoors and DDoS tools, and other suspect traffic
#          (many signatures were adapted from the snort intrusion
#          detection system).  Data is provided by kmsgsd which reads
#          firewall messages out of the /var/lib/psad/psadfifo named pipe
#          (syslog is reconfigured to write kern.info messages there
#          which include firewall messages).  For more information read
#          the psad man page or view the documentation provided at:
#          http://www.cipherdyne.com.
#
# Author: Michael B. Rash (mbr@cipherdyne.com)
#
# Credits:  (see the CREDITS file)
#
# Version: 1.0
#
# Copyright (C) 1999-2002 Michael B. Rash (mbr@cipherdyne.com)
#
# License (GNU Public License):
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
#    USA
#
# TODO:
#   - More verbose --Status output to include scan start time, end time,
#     whether or not each ip has an auto-assigned danger level, etc.
#   - Add a density calculation for a range of scanned ports, and also
#     add a "verbose" mode that will display which of the scanned ports
#     actually resolve to something in the IANA spec.
#   - Send psad alerts to network abuse alerting services such as
#     abuse.net and dshield.org.
#   - Packet grapher mode with annotated scan alerts.
#   - Allow ip ranges to be specified in psad_auto_ips and validated with
#     the ipv4_in_network() function in the Net::IPv4Addr CPAN module.
#   - Make use of other logging options available in iptables to detect
#     more tcp signatures.  (E.g. --log-tcp-options, --log-ip-options,
#     --log-tcp-sequence, etc.) for better signature recognition.
#   - Make use of string matching support to look for application level
#     signatures.  See http://www.stearns.org/snort2iptables
#   - Include a verbose message in the body of certain emails that as
#     of psad-1.0.0-pre2 only contain a subject line.
#   - Allow ipchains to use tcp signatures that only require a syn packet
#     to a port as well as udp signatures.
#   - Deal with the possibility that psad could eat lots of memory over
#     time if $ENABLE_PERSISTENCE="Y". This should involve periodically
#     deleting entries in %scan (or maybe the entire hash), but this
#     should be done in a way that allows some scan data to persist.
#   - Put source and destination ip addresses back into psad_signatures.
#   - Ipfilter support on *BSD platforms.
#   - Possibly add a daemon to take into account ACK PSH, ACK FIN, RST etc.
#     packets that the client may generate after the ip_conntrack module
#     is reloaded.  Without anticipating such packets psad will interpret
#     them as a belonging to a port scan.  NOTE: This problem is mostly
#     corrected by the conntrack patch to the kernel.  Also, the
#     IGNORE_CONNTRACK_BUG_PKTS variable was added.
#   - Improve check_firewall_rules() to check for a state rule (iptables)
#     since having such a rule greatly improves the quality of the data
#     stream provided to psad by kmsgsd since more packet types will be
#     denied without requiring overly complicated firewall rules to detect
#     odd tcp flag combinations.
#   - Investigate the possibility of passive OS fingerprinting by looking
#     at TTL and other fields in the headers (good idea Jay).
#   - Handle various logging daemons other than syslog such as msyslog,
#     and metalog (syslog-ng support was added).
#   - perldoc
#
# Default Command Line Arguments:  As of the 1.0.0-pre3 release, psad by
#   by default will have the --signatures and --auto_ips options set even
#   if these options are not specified on the command line, and psad
#   will use the default locations for the signatures and auto_ips files.
#   The default file locations can be changed by manually specifying the
#   locations to these files with the --signatures and --auto_ips options.
#   The signature matching and the auto_ips danger level assignments can
#   be disabled by using the --no_signatures and --no_auto_ips options
#   respectively.  In addition the psad adheres to the following
#   defaults:
#       -write errors to error log            = yes
#       -daemon mode                          = yes
#       -reverse dns lookups                  = yes
#       -check firewall rules                 = yes
#       -whois lookups of scanning ips        = yes
#       -parse netstat output for local ports = yes
#
# Coding Style:  All configuration variables from psad.conf are stored in
#   the $config hash ref by keys that are in capital letters.  This is
#   the only place in the code where capital letters will be used in
#   variables names.  There are several variables with file-scope, and
#   these variables are clearly commented near the top of each of the
#   psad daemons.
#
# Sample packets:
#
#  Sample packet (rejected by ipchains)
#  Dec 19 11:54:07 orthanc kernel: Packet log: input REJECT lo PROTO=1
#  10.0.0.4:3127.0.0.1:3 L=88 S=0xC0 I=49513 F=0x0000 T=255
#
#  Sample tcp packet (rejected by iptables... --log-prefix = "DROP ")
#  Mar 11 13:15:52 orthanc kernel: DROP IN=lo OUT= MAC=00:00:00:00:00:00:00:00:
#  00:00:00:00:08:00 SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00
#  TTL=64 ID=0 DF PROTO=TCP SPT=44847 DPT=35 WINDOW=32304 RES=0x00 SYN URGP=0
#
#  Sample icmp packet rejected by iptables
#  Nov 27 15:45:51 orthanc kernel: DROP IN=eth1 OUT= MAC=00:a0:cc:e2:1f:f2:00:
#  20:78:10:70:e7:08:00 SRC=192.168.10.20 DST=192.168.10.1 LEN=84 TOS=0x00
#  PREC=0x00 TTL=64 ID=0 DF PROTO=ICMP TYPE=8 CODE=0 ID=61055 SEQ=256
#
#  Occasionally the kernel klogd ring buffer must become full since log
#  entries are sometimes generated by a long port scan like this (note
#  there is no 'DPT' field):
#
#  Mar 16 23:50:25 orthanc kernel: DROP IN=lo OUT= MAC=00:00:00:00:00:00:00:
#  00:00:00:00:00:08:00 SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00
#  TTL=64 ID=0 DF PROTO=TCP SPT=39935 DINDOW=32304 RES=0x00 SYN URGP=0
#
# Note on iptables tcp log messages:
#
#   Iptables reports tcp flags in the following order:
#
#       URG ACK PSH RST SYN FIN
#
###############################################################################
#
# $Id$
#

### modules used by psad
use lib '/usr/lib/psad';
use Psad;
use File::stat 'stat';
use File::Copy;
use File::Path;
use Getopt::Long 'GetOptions';
use Socket;
use Sys::Hostname 'hostname';
use Unix::Syslog qw(:subs :macros);
use POSIX;
use IO::Handle;
use Data::Dumper;
use strict;

### ========================== main =================================

### set current the psad version number
my $version = '1.0';

### establish some default paths
my $config_dir   = '/etc/psad';
my $config_file  = "${config_dir}/psad.conf";
my $sigs_file    = "${config_dir}/psad_signatures";
my $autoips_file = "${config_dir}/psad_auto_ips";

### disable debugging by default
my $debug = 0;

### we don't yet know which type of firewall we are
### running on; this will be calculated by check_scan()
### when the first dropped packet hits the firewall and
### we can examine the logging format.
my $use_ipchains = 0;
my $use_iptables = 0;

my $checked_iptables_flags = 0;
my $flush_fw_rules         = 0;

### Cache the default table->chain relationships used
### by the auto blocking code for iptables firewalls.
### The nat and mangle PREROUTING chains will be added
### by iptables_flags().
my %iptables_chains;

### define the input chains for ipchains firewalls (this
### is very simplistic).
my @ipchains_chains = qw(input);

### main psad data structure; contains ips, port ranges,
### protocol info, tcp flags, etc.
my %scan;

### cache all scan signatures (initialized by default)
my %sigs;

### cache signature info that can be check quickly against
### single hash keys
my %sigs_fast;

### cache signature messages, danger levels, etc.
my %sigs_attr;

### %auto_ips holds all ip addresses that should automatically
### be assigned a danger level (or ignored).  (Only initialized
### if the "-a <auto ips file>" is specified on the command line).
my %auto_ips;

### cache the addresses we have executed whois lookups for
my %whois_cache;

### cache ports the local machine is listening on (periodically
### updated by get_listening_ports()).
my %local_listening_ports;

### packet counters
my $tcp_ctr  = 0;
my $udp_ctr  = 0;
my $icmp_ctr = 0;

### initialize and scope some default variables (command
### line args can override some default values)
my $found_new_packets = 0;
my $output            = 0;
my $syslog_server     = 0;
my $kill              = 0;
my $restart           = 0;
my $status            = 0;
my $benchmark         = 0;
my $b_packets         = 0;
my $usr1              = 0;
my $ver               = 0;
my $help              = 0;
my $dump_conf         = 0;
my $check_interval    = 0;
my $netstat_lkup_ctr  = 0;
my $log_len           = 29;  ### used in scan_logr()
my $fw_analyze        = 0;

### these flags are used to disable several features
### in psad if specified from the command line
my $no_signatures = 0;
my $no_auto_ips   = 0;
my $no_daemon     = 0;
my $no_errors     = 0;
my $no_rdns       = 0;
my $no_whois      = 0;
my $no_netstat    = 0;
my $no_fwcheck    = 0;

### old command line options
my $oldarg_autoips;
my $oldarg_errs;
my $oldarg_nerrs;
my $oldarg_rdns;
my $oldarg_nrdns;
my $oldarg_whois;
my $oldarg_nwhois;
my $oldarg_netstat;
my $oldarg_nlport;
my $oldarg_fwcheck;
my $oldarg_nfwchk;
my $oldarg_daemon;
my $oldarg_logserv;

### used in --Benchmark test
my $b_time;
my $test_pkt = 'Feb 15 16:42:58 orthanc kernel: DROP IN=eth0 ' .
    'OUT= MAC=00:a0:cc:28:42:5a:00:03:6c:00:98:54:08:00 ' .
    'SRC=10.0.0.1 DST=10.0.0.2 LEN=48 TOS=0x00 PREC=0x00 ' .
    'TTL=110 ID=13383 DF PROTO=TCP SPT=1389 DPT=';
my $test_pktend = 'WINDOW=16384 RES=0x00 SYN URGP=0';

### get the hostname of the machine
my $hostname = hostname;

### save a copy of the command line arguments
my @args_cp = @ARGV;

### make Getopts case sensitive
Getopt::Long::Configure('no_ignore_case');

&usage(1) unless (GetOptions(
    'signatures=s'  => \$sigs_file,      # Path to psad signatures file.
    'auto-ips=s'    => \$autoips_file,   # Path to psad auto ips file for
                                         # auto-setting ip danger level.
    'output'        => \$output,         # Write scanlog messages to STDOUT.
    'debug'         => \$debug,          # Run in debug mode.
    'Dump-conf'     => \$dump_conf,      # Dump config and exit.
    'interval=i'    => \$check_interval, # Set $check_interval from the
                                         # command line.
    'config=s'      => \$config_file,    # Specify configuration file.
    'fw-check'      => \$fw_analyze,     # Analyze the firewall ruleset and
                                         # exit.
    'log-server'    => \$syslog_server,  # We are running psad on a syslog
                                         # logging server.
    'Kill'          => \$kill,           # Kill all running psad processes.
                                         # (psadwatchd, psad, kmsgsd,
                                         # diskmond).
    'Restart'       => \$restart,        # Restart psad with all options of
                                         # the currently running psad process.
    'Flush'         => \$flush_fw_rules, # Flush any rules that psad added
                                         # via the auto blocking code.
    'Status'        => \$status,         # Display status of any currently
                                         # running psad processes.
    'Benchmark'     => \$benchmark,      # Run in benchmark mode.
    'packets=i'     => \$b_packets,      # Specify number of packets to use
                                         # in benchmark test.
    'USR1'          => \$usr1,           # Send an existing psad process a
                                         # USR1 signal (useful for debugging).
    'no-whois'      => \$no_whois,       # Do not issue whois lookups against
    'no-signatures' => \$no_signatures,  # Disable signature processing.
    'no-auto_ips'   => \$no_auto_ips,    # Disable auto danger level
                                         # assignment.
    'no-daemon'     => \$no_daemon,      # Do not run as a daemon.
    'no-fwcheck'    => \$no_fwcheck,     # Do not check firewall rules.
    'no-rdns'       => \$no_rdns,        # Do not issue dns lookups against
                                         # Scanning ip address.
    'no-localport'  => \$no_netstat,     # Do not check to see if the
                                         # firewall is listening on localport
                                         # that has been scanned.
    'no-errors'     => \$no_errors,      # Do not write malformed packet.
                                         # messages to error log.
    'Version'       => \$ver,            # Print the psad version and exit.
    'help'          => \$help,           # Display help.
    ### old args
    'Logging_server' => \$oldarg_logserv, # old command line arg
    'Daemon'         => \$oldarg_daemon,  # old command line arg
    'firewallcheck'  => \$oldarg_fwcheck, # old command line arg
    'no_fw_check'    => \$oldarg_nfwchk,  # old command line arg
    'reversedns'     => \$oldarg_rdns,    # old command line arg
    'localport'      => \$oldarg_netstat, # old command line arg
    'errors'         => \$oldarg_errs,    # old command line arg
    'no_errors'      => \$oldarg_nerrs,   # old command line arg
    'whois'          => \$oldarg_whois,   # old command line arg
    'no_whois'       => \$oldarg_nwhois,  # old command line arg
    'no_rdns'        => \$oldarg_nrdns,   # old command line arg
    'no_localport'   => \$oldarg_nlport,  # old command line arg
));
&usage(0) if $help;

### Print the version number and exit if -V given on the command line.
if ($ver) {
    print " .. psad v$version, by Michael Rash " .
        "(mbr\@cipherdyne.com)\n";
    exit 0;
}

### check for any old command line arguements
&check_old_cmdargs();

### Everthing after this point must be executed as root.
$< == 0 && $> == 0 or
    die " ** psad: You must be root (or equivalent ",
        "UID 0 account) to execute psad!  Exiting.\n";

### read in configuration file
my ($config_href, $cmds_href) = &Psad::buildconf($config_file);

### make sure the configuration is complete
&check_config();

my %config = %$config_href;
my %cmds   = %$cmds_href;

### release the memory in config_href and cmds_href
%$config_href = ();
%$cmds_href   = ();

### dump configuration to STDOUT
&dump_conf() if $dump_conf;

### store the psad command line.
my $cmdline_file = $config{'PSAD_CMDLINE_FILE'};

### define the path to the auto_blocked_ips file
my $auto_blocked_file = "$config{'PSAD_DIR'}/auto_blocked_ips";

### pid file array
my @pidfiles = (
    $config{'PSADWATCHD_PID_FILE'},
    $config{'PSAD_PID_FILE'},
    $config{'KMSGSD_PID_FILE'},
    $config{'DISKMOND_PID_FILE'}
);

### The --Kill command line switch was given.
if ($kill) {
    &kill_psad();
    exit 0;
}

### The --Flush command line switch was given.
if ($flush_fw_rules) {
    if (-e $auto_blocked_file) {
        print " .. Removing auto-generated block rules.\n";
        &old_auto_blocked_ips();
        unlink $auto_blocked_file;
    } else {
        print " ** Currently there are no auto-generated ".
            "block rules in effect.\n";
    }
    exit 0;
}

### The --USR1 command line switch was given.
if ($usr1) {
    exit &usr1();
}

### The -i <check interval> command line argument was given
if ($check_interval) {
    $config{'PSAD_CHECK_INTERVAL'} = $check_interval;
}

### check to make sure the commands specified in the config section
### are in the right place, and attempt to correct automatically if not.
&Psad::check_commands(\%cmds);

### Now that we are sure the psad command is where it should be,
### assign $PSADCMD (used by the SEGV handler)
my $PSADCMD = $cmds{'psad'};

### the --Status command line switch was given
&status() if $status;

### make sure $PSAD_DIR, $FW_DATA, and /var/lib/psad/psadfifo, etc.
### actually exist
&setup();

### the --Restart command line switch was given
if ($restart) {
    &restart();
    exit 0;
}

### check to make sure another psad process is not already running.
&Psad::unique_pid($config{'PSAD_PID_FILE'});

### make sure the permissions on these files is 0600
&check_permissions(
    $config{'FW_DATA'},
    $config{'ERROR_LOG'},
);

### get the ip addresses that are local to this machine
my $local_ips_href = &get_local_ips();

### disable whois lookups if for some reason the whois client that is
### bundled with psad can't be found
unless ($no_whois) {
    unless (defined $cmds{'whois'}
            && -x $cmds{'whois'}) {  ### we couldn't find whois.psad
        warn " ** Could not locate whois.psad binary.  " .
            "Disabling whois lookups.\n";
        $no_whois = 1;
    }
}

### if psad is running on a syslog server, don't check the firewall
### rules since they may not be local.
unless ($no_fwcheck || $syslog_server) {
    my $rv = &Psad::check_firewall_rules(
        $config{'FW_MSG_SEARCH1'},  ### FW_MSG_SEARCH2 is normally used for
                                    ### snort "sid" values so don't include
                                    ### it within the firewall check
        $config{'EMAIL_ADDRESSES'},
        "$config{'PSAD_DIR'}/fw_check.txt",
        \%cmds
    );
    if ($rv) {
        if ($fw_analyze) {
            print localtime() . " .. Firewall config looks good.\n";
            print localtime() . " .. Completed check of firewall ruleset.\n";
        }
    } else {
        if ($fw_analyze) {
            print localtime() . " ** Errors found in firewall config.\n";
            print localtime() . " ** Results emailed to " .
                "$config{'EMAIL_ADDRESSES'}\n";
        }
    }
    if ($fw_analyze) {
        print localtime() . " .. Exiting.\n";
        exit 0;
    }
}

### daemonize psad unless running with --no_daemon or --debug
unless ($no_daemon || $debug || $benchmark) {
    my $pid = fork();
    exit if $pid;
    die " ** $0: Couldn't fork: $!" unless defined $pid;
    POSIX::setsid() or die " ** $0: Can't start a new session: $!";
}

### write the current pid associated with psad to the psad pid file
&Psad::writepid($config{'PSAD_PID_FILE'});

### write the command line args used to start psad to $cmdline_file
&Psad::writecmdline(\@args_cp, $cmdline_file);

### psad _requires_ that kmsgsd is running to receive any data, so let's
### start it here for good measure (as of 0.9.2 it makes use of the pid
### files and unique_pid(), so we don't have to worry about starting a
### duplicate copy).  While we're at it, start psadwatchd and diskmond too
### Note that this is the best place to start the other daemons since we
### just wrote the psad pid to PSAD_PID_FILE above.
if ($config_file eq '/etc/psad/psad.conf') {
    unless ($benchmark) {
        system $cmds{'kmsgsd'};
        system $cmds{'diskmond'};
        system $cmds{'psadwatchd'} unless $debug;
    }
} else {  ### start the other daemons with the new (non-default) config file
    unless ($benchmark) {
        system "$cmds{'kmsgsd'} $config_file";
        system "$cmds{'diskmond'} $config_file";
        system "$cmds{'psadwatchd'} $config_file" unless $debug;
    }
}

### import the scan signatures and auto ips file
&import_signatures() if $sigs_file;
&import_auto_ips()   if $autoips_file;

### Check to see if psad automatically blocked some ips from
### a previous run.  This feature is most useful for preserving
### automatically blocked ips after a reboot.
if ($config{'ENABLE_AUTO_IDS'} eq 'Y') {
    &old_auto_blocked_ips();
}

### archive old firewall and scan data
&archive_data() unless $benchmark;

### Install signal handlers for debugging %scan with Data::Dumper,
### and for reaping zombie whois processes
$SIG{'__WARN__'} = \&Psad::warn_handler;
$SIG{'__DIE__'}  = \&Psad::die_handler;
$SIG{'CHLD'}     = \&REAPER;
$SIG{'USR1'}     = \&print_scan;

### Get the mtimes of the signatures and auto ips files.
my $sigs_mtime     = stat($sigs_file)->mtime;
my $auto_ips_mtime = stat($autoips_file)->mtime;
my $config_mtime   = stat($config_file)->mtime;

### zero out the packet counter file (the counters
### are all zero at this point).
&write_packet_counters();

if ($benchmark) {
    print localtime() . " .. Entering benchmark mode.\n";
    $no_rdns  = 1;  ### turn off network related functions
    $no_whois = 1;
    if ($b_packets) {
        print localtime() . " .. Executing a $b_packets packet test.\n";
    } else {
        print localtime() . " .. The --packets command line " .
            "option was not specified.\n";
        print localtime() . " .. Defaulting to a 10,000 packet test.\n";
        $b_packets = 10000;
    }
}

### Get an open filehandle for the main firewall data file $FW_DATA.
### All firewall drop/deny/reject log messages are written to $FW_DATA
### by kmsgsd.
open FWDATA, $config{'FW_DATA'} unless $benchmark;

###=========================================================###
######                    MAIN LOOP                      ######
###=========================================================###
for (;;) {

    ### See if we need to import any changed config variables
    &check_import_config(\$config_mtime, $config_file);

    ### See if we need to import any new signatures
    &check_import(\$sigs_mtime, $sigs_file, 1);

    ### See if we need to re-import the psad_auto_ips file
    &check_import(\$auto_ips_mtime, $autoips_file, 0);

    ### Get any new packets have been written to
    ### $FW_DATA by kmsgsd for psad analysis.
    my @new_packets;
    if ($benchmark) {
        $b_time = time();
        print localtime() . " .. Creating packet array.\n";
        my $dst_port = 1000;
        for (my $i=0; $i <= $b_packets; $i++) {
            ### avert "." operator
            push @new_packets, "$test_pkt DPT=$dst_port $test_pktend";
            $dst_port++ if $dst_port < 50000;
        }
    } else {
        @new_packets = <FWDATA>;
    }
    if (@new_packets) {
        print localtime() . " .. check_scan()\n" if $benchmark;

        my $found_potential_scan = &check_scan(
            \@new_packets,
            $sigs_file,
        );
        if ($found_potential_scan) {

            print localtime() . " .. assign_danger_level()\n"
                if $benchmark;
            ### Assign a danger level to the scan
            &assign_danger_level();

            print localtime() . " .. scan_logr()\n" if $benchmark;
            ### Log and send email and syslog alerts
            &scan_logr();

            ### Don't manage the firewall rules if
            ### psad is running on a syslog server
            if ($config{'ENABLE_AUTO_IDS'} eq 'Y' &&
                ! $syslog_server) {
                &auto_psad_response();
            }
        }

        ### write the number of tcp/udp/icmp packets out
        ### to the packet counters file
        &write_packet_counters();
    }
    ### Print how many new packets we got in $FW_DATA if we are
    ### running in $debug mode
    if ($debug) {
        print "MAIN: number of new packets: $#new_packets\n";
    }

    if ($benchmark) {
        print localtime() . " .. Packet creation and processing time: ",
            time() - $b_time, " sec.\n";
        print localtime() . " .. Exiting benchmark mode.\n";
        exit 0;
    }

    sleep $config{'PSAD_CHECK_INTERVAL'};
    ### clearerr() on the FWDATA filehandle to be ready for new packets
    FWDATA->clearerr() unless $benchmark;
}
exit 0;
###=========================================================###
######                    END MAIN                       ######
###=========================================================###

#=================== BEGIN SUBROUTINES ========================

### Keeps track of scanning ip's, increments packet counters,
### keep track of tcp flags for each scan (iptables only)
sub check_scan() {
    my ($fw_lines_aref, $signatures) = @_;
    my @bad_packets;
    my $flags;
    my $src;
    my $dst;
    my $len;
    my $ttl;
    my $proto;
    my $srcport;
    my $dstport;
    my $type;
    my $code;
    my $id;
    my $seq;
    my $matched_packet = 0;

    ### If necessary, check which firewall (ipchains vs. iptables)
    unless ($use_ipchains || $use_iptables) {
        &check_fw($fw_lines_aref->[0]);
    }
    unless ($no_netstat) {
        if ($netstat_lkup_ctr == 10) {
            ### we don't expect the list of ports the machine is listening
            ### on to change very often.
            &get_listening_ports();
            $netstat_lkup_ctr = 0;
        } else {
            $netstat_lkup_ctr++;
        }
    }
    PKT: for my $line (@$fw_lines_aref) {
        chomp $line;
        if ($use_iptables) {
            ### Sometimes the log entry is messed up by iptables so
            ### we write it to the error log.
            if ($line =~ /SRC=(\S+)\s+DST=(\S+)\s+
                          LEN=(\d+).*TTL=(\d+).*PROTO=(\S+)\s+
                          SPT=(\d+)\s+DPT=(\d+)/x) {
                ($src, $dst, $len, $ttl, $proto, $srcport, $dstport) =
                    ($1,$2,$3,$4,$5,$6,$7,$8);
                if ($proto ne 'TCP' && $proto ne 'UDP') {
                    ### it was some weird non-tcp/udp packet
                    ### with source and destination ports
                    push @bad_packets, $line;
                    next PKT;
                }
                if ($proto eq 'TCP') {
                    $flags = 'NULL';  ### default to NULL
                    if ($line =~ /RES=\S+\s+(.*)\s+URGP=/) {
                        $flags = $1;
                    }

                    if ($config{'IGNORE_CONNTRACK_BUG_PKTS'} eq 'Y' &&
#                        $dstport > 1024 && ($flags =~ /ACK/ ||
                        ($flags =~ /ACK/ || $flags =~ /RST/)) {
                        ### XXX ignore TCP packets that have the ACK or RST
                        ### bits set ### since _usually_ we see these packets
                        ### as a result of the iptables connection tracking
                        ### bug.  Also, note that there are no signatures
                        ### make use of the RST flag and very few that use
                        ### the ACK flag (need to add code back in for these
                        ### signatures).
                        next PKT;
                    }
                    ### per page 595 of the Camel book, "if /blah1|blah2/"
                    ### can be slower than "if /blah1/ || /blah2/
                    unless ($flags !~ /WIN/ &&
                            $flags =~ /URG/ ||
                            $flags =~ /ACK/ ||
                            $flags =~ /PSH/ ||
                            $flags =~ /RST/ ||
                            $flags =~ /SYN/ ||
                            $flags =~ /FIN/ ||
                            $flags eq 'NULL') {
                        push @bad_packets, $line;
                        next PKT;
                    }
                    $tcp_ctr++;
                } else {
                    ### it is UDP, but there are no more fields we need to
                    ### define since we already have the ports, etc.
                    $udp_ctr++;
                }
                $matched_packet = 1;
            } elsif ($line =~ /SRC=(\S+)\s+DST=(\S+)\s+LEN=(\d+).*
                               TTL=(\d+).*PROTO=ICMP\s+TYPE=(\d+)\s+
                               CODE=(\d+)\s+ID=(\d+)\s+SEQ=(\d+)/x) {
                ($src, $dst, $len, $ttl, $type, $code, $id, $seq) =
                    ($1,$2,$3,$4,$5,$6,$7,$8);
                $proto = 'ICMP';
                $icmp_ctr++;
                $matched_packet = 1;
            } else {
                push @bad_packets, $line;
                next PKT;
            }
        } elsif ($use_ipchains) {
            ### could implement source port checking here
            if ($line =~ /PROTO\=(\d+)\s(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):
                          (\d+)\s(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d+)/x) {
                ($proto, $src, $srcport, $dst, $dstport) = ($1,$2,$3,$4,$5);
                ### should implement protocol mapping
                ### with /etc/protocols here
                if ($proto == 1) {
                    $proto = 'ICMP';
                    $icmp_ctr++;
                } elsif ($proto == 6) {
                    $proto = 'TCP';
                    $tcp_ctr++;
                } elsif ($proto == 17) {
                    $proto = 'UDP';
                    $udp_ctr++;
                }
                $flags = 'NONE';
                $matched_packet = 1;
            } else {
                push @bad_packets, $line;
                next PKT;
            }
        }

        ### see if we need to timeout any old scans
        if ($config{'ENABLE_PERSISTENCE'} eq 'N') {
            if (defined $scan{$src}{$dst}{'S_TIME'}) {
                if ((time() - $scan{$src}{$dst}{'S_TIME'})
                    >= $config{'SCAN_TIMEOUT'}) {
                    delete $scan{$src}{$dst};
                }
            }
        }

        ### scan hash initialization; if we made it here then we matched
        ### packets that the firewall dropped.

        ### initialize the danger level to 0 if it is not already defined
        unless (defined $scan{$src}{$dst}{'CURR_DL'}) {
            $scan{$src}{$dst}{'CURR_DL'} = 0;
        }

        ### we will always send an alert email for any new "bad" packet
        ### if $ALERT_ALL eq "Y"... Else email sent only if the scan
        ### increments its danger level or trips a signature
        if ($config{'ALERT_ALL'} eq 'Y') {
            $scan{$src}{$dst}{'ALERTED'} = 0;
        }

        ### record the absolute starting time of the scan
        unless (defined $scan{$src}{$dst}{'S_TIME'}) {
            $scan{$src}{$dst}{'S_TIME'} = time();
        }

        ### inialize the start and end port for the scanned port range
        unless (defined $scan{$src}{$dst}{'S_PORT'} || $proto eq 'ICMP') {
            ### This is the absolute starting port since the
            ### first packet was detected.  Make sure the initial
            ### start port is not too low
            $scan{$src}{$dst}{'S_PORT'} = 65535;
            ### make sure the initial end port is not too high
            $scan{$src}{$dst}{'E_PORT'} = 0;
        }

        ### initialize values for the current interval
        unless (defined $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_INT'}) {
            unless ($proto eq 'ICMP') {
                ### make sure the initial start port is not too low
                $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_INT'}{'S_PORT'}
                    = 65535;
                ### make sure the initial end port is not too high
                $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_INT'}{'E_PORT'}
                    = 0;
            }
        }

        ### increment hash values
        $scan{$src}{$dst}{'ABSNUM'}++;
        $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_INT'}{'PKTS'}++;

        ### keep track of tcp flags
        if ($proto eq 'TCP') {
            $scan{$src}{$dst}{'PROTO'}{'TCP'}{'CURR_INT'}{'FLAGS'}{$flags}++;
        }

        ### see if the destination port lies outside our current range
        ### and change if needed
        unless ($proto eq 'ICMP') {
            ($scan{$src}{$dst}{'S_PORT'}, $scan{$src}{$dst}{'E_PORT'}) =
                &check_range($dstport,
                    $scan{$src}{$dst}{'S_PORT'},
                    $scan{$src}{$dst}{'E_PORT'});
            ($scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_INT'}{'S_PORT'},
                $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_INT'}{'E_PORT'}) =
                &check_range($dstport,
                    $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_INT'}{'S_PORT'},
                    $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_INT'}{'E_PORT'});
        }
        if ($debug) {
            print STDOUT "check_scan(): src: $src, dst: $dst\n";
            print STDOUT Dumper $scan{$src}{$dst};
        }
        ### might try to match signatures against ipchains messages
        ### also, but then cannot use tcp flags except for -y -l rules
        next PKT unless ($signatures && $use_iptables);

        ### attempt to match any tcp/udp/icmp signatures in the
        ### %sigs_fast hash
        &match_fastsigs($src, $dst, $srcport, $dstport, $proto,
            $flags, $len, $ttl);

        ### attempt to match any tcp/udp/icmp signatures in the
        ### main signatures hash
        &match_sigs($src, $dst, $srcport, $dstport, $proto,
            $flags, $len, $ttl, $type, $code, $id, $seq);

    }
    &collect_errors(\@bad_packets) unless $no_errors;
    return $matched_packet;
}

sub match_fastsigs() {
    my ($src, $dst, $srcport, $dstport, $proto,
        $flags, $len, $ttl) = @_;
    if ($proto eq 'TCP') {
        if (defined $sigs_fast{'TCP'}{$dstport}{$srcport}{$flags}) {
            for my $sig_id (keys
                %{$sigs_fast{'TCP'}{$dstport}{$srcport}{$flags}}) {
                print "matched: $dstport,$srcport,$flags, " .
                    "sig_id: $sig_id\n" if $debug;
                unless ($scan{$src}{$dst}{'CURR_DL'}
                    >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan{$src}{$dst}{'CURR_DL'}
                        = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
#                $scan{$src}{$dst}{$proto}{'CURR_SIG'}{$sig_id}{'PKTS'}++;
                &cache_dst_port($src, $dst, 'TCP', $dstport, $flags, $sig_id)
                    unless $no_netstat;
            }
        }
        if (defined $sigs_fast{'TCP'}{$dstport}{'any_src_port'}{$flags}) {
            for my $sig_id (keys
                %{$sigs_fast{'TCP'}{$dstport}{'any_src_port'}{$flags}}) {
                print "matched $dstport,any_src_port,$flags, " .
                    "sig_id: $sig_id\n" if $debug;
                unless ($scan{$src}{$dst}{'CURR_DL'}
                    >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan{$src}{$dst}{'CURR_DL'}
                        = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                &cache_dst_port($src, $dst, 'TCP', $dstport, $flags, $sig_id)
                    unless $no_netstat;
            }
        }
        if (defined $sigs_fast{'TCP'}{'any_dst_port'}{$srcport}{$flags}) {
            for my $sig_id (keys
                %{$sigs_fast{'TCP'}{'any_dst_port'}{$srcport}{$flags}}) {
                print "matched any_dst_port,$srcport,$flags, " .
                    "sig_id: $sig_id\n" if $debug;
                unless ($scan{$src}{$dst}{'CURR_DL'}
                    >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan{$src}{$dst}{'CURR_DL'}
                        = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                &cache_dst_port($src, $dst, 'TCP', $dstport, $flags, $sig_id)
                    unless $no_netstat;
            }
        }
        if (defined $sigs_fast{'TCP'}{'any_dst_port'}{'any_src_port'}{$flags}) {
            for my $sig_id (keys
                %{$sigs_fast{'TCP'}{'any_dst_port'}{'any_src_port'}{$flags}}) {
                print "matched any_dst_port,any_src_port,$flags, " .
                    "sig_id: $sig_id\n" if $debug;
                unless ($scan{$src}{$dst}{'CURR_DL'}
                    >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan{$src}{$dst}{'CURR_DL'}
                        = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                &cache_dst_port($src, $dst, 'TCP', $dstport, $flags, $sig_id)
                    unless $no_netstat;
            }
        }
    } elsif ($proto eq 'UDP') {
        if (defined $sigs_fast{'UDP'}{$dstport}{$srcport}) {
            for my $sig_id (keys %{$sigs_fast{'UDP'}{$dstport}{$srcport}}) {
                unless ($scan{$src}{$dst}{'CURR_DL'}
                    >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan{$src}{$dst}{'CURR_DL'} =
                        $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                &cache_dst_port($src, $dst, 'UDP', $dstport, '', $sig_id)
                    unless $no_netstat;
            }
        }
    }
    return;
}

sub match_sigs() {
    my ($src, $dst, $srcport, $dstport, $proto,
        $flags, $len, $ttl, $type, $code, $id, $seq) = @_;
    for my $sig_id (keys %{$sigs{$proto}}) {
        ### need to iterate through all signatures
        ### since a packet may match several
        my $dstport_criteria = 0;
        my $srcport_criteria = 0;
        my $matched_sig      = 0;
        if ($proto eq 'TCP') {
            if ($flags eq $sigs{'TCP'}{$sig_id}{'flags'}
                && &check_port_range($sig_id, $srcport,
                $dstport, $proto)) {  ### tripped a tcp signature
                ### future
#               && &check_misc_fields($sig_id, $proto, $len, $ttl)) {
                print "main sigs matched $dstport,$srcport,$flags, " .
                    "sig_id: $sig_id\n" if $debug;
                unless ($scan{$src}{$dst}{'CURR_DL'}
                    >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan{$src}{$dst}{'CURR_DL'} =
                        $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                $matched_sig = 1;
            }
        } elsif ($proto eq 'UDP') {
            if (&check_port_range($sig_id, $srcport, $dstport, $proto)) {
#               && &check_misc_fields($sig_id, $proto, $len, $ttl)) {
                ### tripped a udp signature
                unless ($scan{$src}{$dst}{'CURR_DL'}
                    >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan{$src}{$dst}{'CURR_DL'}
                        = $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                $matched_sig = 1;
            }
        } elsif ($proto eq 'ICMP') {
            if (&check_icmp_sigs($sig_id, $ttl, $type, $code, $id, $seq)) {
                unless ($scan{$src}{$dst}{'CURR_DL'}
                    >= $sigs_attr{$sig_id}{'dlevel'}) {
                    $scan{$src}{$dst}{'CURR_DL'} =
                        $sigs_attr{$sig_id}{'dlevel'};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                $scan{$src}{$dst}{'PROTO'}{'ICMP'}{'CURR_SIG'}
                {$sig_id}{'PKTS'}++;
            }
        }
        if ($matched_sig && !$no_netstat && $proto ne 'ICMP') {
            &cache_dst_port($src, $dst, $proto, $dstport, $flags, $sig_id);
        }
    }
    return;
}

sub cache_dst_port() {
    my ($src, $dst, $proto, $dstport, $flags, $sig_id) = @_;
    ### check to see if the scan destination ip is directed
    ### at the firewall.  If yes, then check to see if a
    ### server is listening on the DSTPORT by parsing
    ### netstat output.  If not, psad would have to connect
    ### to the destination port on the remote machine, but
    ### it should not do this so it is not implemented. :)
    if (defined $local_ips_href->{$dst}) {
        if (defined $local_listening_ports{$proto}{$dstport}) {
            $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_SIG'}
            {$sig_id}{'LISTEN'}{$dstport}{'PKTS'}++;
            if ($flags) {
                $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_SIG'}
                {$sig_id}{'LISTEN'}{$dstport}{'FLAGS'}
                    = $flags;
            }
        } else {
            $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_SIG'}
            {$sig_id}{'NO_LISTEN'}{$dstport}{'PKTS'}++;
            if ($flags) {
                $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_SIG'}
                {$sig_id}{'NO_LISTEN'}{$dstport}{'FLAGS'}
                    = $flags;
            }
        }
    }
    return;
}

sub check_port_range() {
    my ($sig_id, $srcport, $dstport, $proto) = @_;
    ### check dst port first
    if (defined $sigs{$proto}{$sig_id}{'dstport'}{'unique_or_any'}) {
        unless ($sigs{$proto}{$sig_id}{'dstport'}{'unique_or_any'} eq 'any') {
            if ($dstport != $sigs{$proto}{$sig_id}{'dstport'}{'unique_or_any'}) {
                return 0;
            }
        }
    }
    if (defined $sigs{$proto}{$sig_id}{'dstport'}{'start'}) {
        my $start = $sigs{$proto}{$sig_id}{'dstport'}{'start'};
        my $end = $sigs{$proto}{$sig_id}{'dstport'}{'end'};
        return 0 if ($dstport < $start || $dstport > $end);
    }
    if (defined $sigs{$proto}{$sig_id}{'dstport'}{'not'}) {
        return 0 if ($dstport == $sigs{$proto}{$sig_id}{'dstport'}{'not'});
    }
    if (defined $sigs{$proto}{$sig_id}{'dstport'}{'negstart'}) {
        my $start = $sigs{$proto}{$sig_id}{'dstport'}{'negstart'};
        my $end = $sigs{$proto}{$sig_id}{'dstport'}{'negend'};
        return 0 if ($dstport > $start || $dstport < $end);
    }

    ### check src port
    if (defined $sigs{$proto}{$sig_id}{'srcport'}{'unique_or_any'}) {
        unless ($sigs{$proto}{$sig_id}{'srcport'}{'unique_or_any'} eq 'any') {
            if ($dstport != $sigs{$proto}{$sig_id}{'srcport'}{'unique_or_any'}) {
                return 0;
            }
        }
    }
    if (defined $sigs{$proto}{$sig_id}{'srcport'}{'start'}) {
        my $start = $sigs{$proto}{$sig_id}{'srcport'}{'start'};
        my $end = $sigs{$proto}{$sig_id}{'srcport'}{'end'};
        return 0 if ($srcport < $start || $srcport > $end);
    }
    if (defined $sigs{$proto}{$sig_id}{'srcport'}{'not'}) {
        return 0 if ($srcport == $sigs{$proto}{$sig_id}{'srcport'}{'not'});
    }
    if (defined $sigs{$proto}{$sig_id}{'srcport'}{'negstart'}) {
        my $start = $sigs{$proto}{$sig_id}{'srcport'}{'negstart'};
        my $end   = $sigs{$proto}{$sig_id}{'srcport'}{'negend'};
        return 0 if ($srcport > $start || $srcport < $end);
    }
    return 1;   ### if we made it to here, then we matched both
                ### the src and dst port criteria
}

sub check_icmp_sigs() {
    my ($sig_id, $ttl, $type, $code, $icmp_id, $icmp_seq) = @_;
    ### check icmp type first
    if (defined $sigs{'ICMP'}{$sig_id}{'type'}) {
        return 0 if ($sigs{'ICMP'}{$sig_id}{'type'} != $type);
    }
    if (defined $sigs{'ICMP'}{$sig_id}{'ttl'}) {
        return 0 if ($sigs{'ICMP'}{$sig_id}{'ttl'} != $ttl);
    }
    if (defined $sigs{'ICMP'}{$sig_id}{'code'}) {
        return 0 if ($sigs{'ICMP'}{$sig_id}{'code'} != $code);
    }
    if (defined $sigs{'ICMP'}{$sig_id}{'icmp_id'}) {
        return 0 if ($sigs{'ICMP'}{$sig_id}{'icmp_id'} != $icmp_id);
    }
    if (defined $sigs{'ICMP'}{$sig_id}{'seq'}) {
        return 0 if ($sigs{'ICMP'}{$sig_id}{'icmp_seq'} != $icmp_seq);
    }
    return 1; ### if we got to this point, then we matched the signature
}

sub check_misc_fields() {
    my ($msg, $proto, $len, $ttl) = @_;
    if (defined $sigs{$proto}{$msg}{'LEN'}) {
        return 0 if ($sigs{$proto}{$msg}{'LEN'} != $len);
    }
    if (defined $sigs{$proto}{$msg}{'TTL'}) {
        return 0 if ($sigs{$proto}{$msg}{'TTL'} != $ttl);
    }
    return 1;
}

sub check_import() {
    my ($mtime_ref, $file, $sigs) = @_;
    my $mtime_tmp = stat($file)->mtime;
    if ($mtime_tmp != $$mtime_ref) {  ### the file was modified, so import
        if ($sigs) {  ### import signatures
            &import_signatures($file);
        } else {
            &import_auto_ips($file);
        }
        my $subject = "psad: re-read $file on $hostname";
        &Psad::sendmail($subject, '',
            $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
        $$mtime_ref = $mtime_tmp;
    }
    return;
}

sub check_import_config() {
    my ($mtime_ref, $file) = @_;
    my $mtime_tmp = stat($file)->mtime;
    if ($mtime_tmp != $$mtime_ref) {  ### the file was modified, so import

        ($config_href, $cmds_href) = &Psad::buildconf($file);

        ### make sure the configuration is complete
        &check_config();

        %config = %$config_href;
        %cmds   = %$cmds_href;
        my $subject = "psad: re-read $file on $hostname";
        &Psad::sendmail($subject, '',
            $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
        $$mtime_ref = $mtime_tmp;

        ### kill kmsgsd since it does not have the capability of
        ### checking for a modified config file
        open K, "< $config{'KMSGSD_PID_FILE'}" or warn
            " ** Could not open $config{'KMSGSD_PID_FILE'}";
        my $pid = <K>;
        close K;
        chomp $pid;
        if (kill 0, $pid) {
            kill 15, $pid;
            ### NOTE: we are not restarting kmsgsd here since we
            ###       don't want to create a race condition between
            ###       psad and psadwatchd both starting kmsgsd
        }
    }
    return;
}

sub import_signatures() {
    %sigs = ();  ### undef %sigs so don't leave old signatures around
    open SIGS, "< $sigs_file" or die
        " ** Could not open the signatures file $sigs_file: $!";
    my @lines = <SIGS>;
    close SIGS;
    SIG: for my $line (@lines) {
        chomp $line;
        next SIG unless $line;
        next SIG if $line =~ /^\s*#/;
        if ($line =~ /^psad:(\d+);\s*(tcp|udp);\s*(\S+)\s*\-\>\s*(\S+);\s*
                       msg:\s*\"(.*)\";\s*(.*)\s*dlevel:\s*(\d);$/x) {
            my $sig_id   = $1;
            my $proto    = $2;
            my $src_port = $3;
            my $dst_port = $4;
            my $msg_str  = $5;
            my $options  = $6;
            my $dlevel   = $7;

            ### change protocol to uppercase to match firewall log messages
            $proto = uc $proto;

            ### add the signature message string to the %sig_attr cache
            $sigs_attr{$sig_id}{'dlevel'} = $dlevel;
            $sigs_attr{$sig_id}{'msg'}    = $msg_str;

            my $sig_flags = '';
            my $flags     = '';

            if ($options =~ /flags:\s*(\w+)/i) {
                $sig_flags = $1;
                ### make flags identical to what iptables log messages
                ### would report (check in iptables flag reporting order).
                $flags .= 'URG ' if $sig_flags =~ /U/;
                $flags .= 'ACK ' if $sig_flags =~ /A/;
                $flags .= 'PSH ' if $sig_flags =~ /P/;
                $flags .= 'RST ' if $sig_flags =~ /R/;
                $flags .= 'SYN ' if $sig_flags =~ /S/;
                $flags .= 'FIN ' if $sig_flags =~ /F/;

                ### iptables does not report "NULL" for no flags set
                ### (it does not report anything), but put NULL to make it
                ### so we have something to match against.
                $flags .= 'NULL ' if $sig_flags =~ /N/;
                $flags =~ s/\s*$//;
            }
            ### future
#            my $ttl   = '';
#            if ($options =~ /ttl:\s*(\d+)/i) {
#                $sigs{$proto}{$sig_id}{'TTL'} = $1;
#            }

            ### assign the source and destination port ranges
            &build_tcp_udp_sigs($sig_id, $proto,
                $src_port, $dst_port, $flags);

        } elsif ($line =~ /^psad:(\d+);\s*icmp;\s*
                            msg:\s*\"(.*)\";\s*(.*)\s*dlevel:\s*(\d);$/x) {
            my $sig_id  = $1;
            my $msg_str = $2;
            my $options = $3;
            my $dlevel  = $4;

            ### add the signature message string to the %sig_attr cache
            $sigs_attr{$sig_id}{'dlevel'} = $dlevel;
            $sigs_attr{$sig_id}{'msg'}    = $msg_str;

            if ($options =~ /ttl:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'ttl'} = $1;
            }
            if ($options =~ /itype:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'type'} = $1;
            }
            if ($options =~ /icode:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'code'} = $1;
            }
            if ($options =~ /icmp_seq:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'icmp_seq'} = $1;
            }
            if ($options =~ /icmp_id:\s*(\d+)/i) {
                $sigs{'icmp'}{$sig_id}{'icmp_id'} = $1;
            }
        } else {  ### the signature line could not be recognized
            warn " ** Bad signature in $sigs_file: $line\n";
            next SIG;
        }
    }
    if ($debug) {
        print STDOUT " ** main signatures hash:\n";
        print STDOUT Dumper %sigs;
        print STDOUT " ** fast lookup hash:\n";
        print STDOUT Dumper %sigs_fast;
        print STDOUT Dumper " ** signature attributes hash:\n";
        print STDOUT Dumper %sigs_attr;
    }
    return;
}

sub build_tcp_udp_sigs() {
    my ($sig_id, $proto, $src_port, $dst_port, $flags) = @_;

    if (&is_range($dst_port) || &is_range($src_port)) {
        ### if we make it here then we have a range of ports so insert
        ### the signature into the %sigs hash
        if ($proto eq 'TCP' && $flags) {
            $sigs{$proto}{$sig_id}{'flags'} = $flags;
        }
        ### deal with source port ranges
        if ($src_port =~ /:/ && $src_port !~ /!/) {
            my ($start, $end) = split /:/, $src_port;
            $start = 1 unless $start;
            $end = 65535 unless $end;
            $sigs{$proto}{$sig_id}{'srcport'}{'start'} = $start;
            $sigs{$proto}{$sig_id}{'srcport'}{'end'}   = $end;
        } elsif ($src_port =~ /!/ && $src_port !~ /:/) {
            $src_port =~ s/!//;
            $sigs{$proto}{$sig_id}{'srcport'}{'not'} = $src_port;
        } elsif ($src_port =~ /:/ && $src_port =~ /!/) {
            my ($start, $end) = split /:/, $src_port;
            $start = 1 unless $start;
            $end = 65535 unless $end;
            $sigs{$proto}{$sig_id}{'srcport'}{'negstart'} = $start;
            $sigs{$proto}{$sig_id}{'srcport'}{'negend'}   = $end;
        } else {
            $sigs{$proto}{$sig_id}{'srcport'}{'unique_or_any'} = $src_port;
        }

        ### deal with destination port ranges
        if ($dst_port =~ /:/ && $dst_port !~ /!/) {
            my ($start, $end) = split /:/, $dst_port;
            $start = 1 unless $start;
            $end = 65535 unless $end;
            $sigs{$proto}{$sig_id}{'dstport'}{'start'} = $start;
            $sigs{$proto}{$sig_id}{'dstport'}{'end'}   = $end;
        } elsif ($dst_port =~ /!/ && $dst_port !~ /:/) {
            $dst_port =~ s/!//;
            $sigs{$proto}{$sig_id}{'dstport'}{'not'} = $dst_port;
        } elsif ($dst_port =~ /:/ && $dst_port =~ /!/) {
            my ($start, $end) = split /:/, $dst_port;
            $start = 1 unless $start;
            $end = 65535 unless $end;
            $sigs{$proto}{$sig_id}{'dstport'}{'negstart'} = $start;
            $sigs{$proto}{$sig_id}{'dstport'}{'negend'}   = $end;
        } else {
            $sigs{$proto}{$sig_id}{'dstport'}{'unique_or_any'} = $dst_port;
        }
    } else {
        ### build up the %sigs_fast lookup cache
        if ($dst_port !~ /\D/) {
            if ($src_port !~ /\D/) {
                if ($proto eq 'TCP') {
                    $sigs_fast{$proto}{$dst_port}{$src_port}{$flags}{$sig_id}
                        = '';
                } elsif ($proto eq 'UDP') {
                    $sigs_fast{$proto}{$dst_port}{$src_port}{$sig_id}
                        = '';
                }
            } elsif ($src_port =~ /any/i) {
                if ($proto eq 'TCP') {
                    $sigs_fast{$proto}{$dst_port}{'any_src_port'}{$flags}{$sig_id}
                        = '';
                } elsif ($proto eq 'UDP') {
                    $sigs_fast{$proto}{$dst_port}{'any_src_port'}{$sig_id}
                        = '';
                }
            }
        } elsif ($dst_port =~ /any/i) {
            if ($src_port !~ /\D/) {
                if ($proto eq 'TCP') {
                    $sigs_fast{$proto}{'any_dst_port'}{$src_port}{$flags}{$sig_id}
                        = '';
                } elsif ($proto eq 'UDP') {
                    $sigs_fast{$proto}{'any_dst_port'}{$src_port}{$sig_id}
                        = '';
                }
            } elsif ($src_port =~ /any/i) {
                if ($proto eq 'TCP') {
                    $sigs_fast{$proto}{'any_dst_port'}{'any_src_port'}{$flags}{$sig_id}
                        = '';
                } elsif ($proto eq 'UDP') {
                    $sigs_fast{$proto}{'any_dst_port'}{'any_src_port'}{$sig_id}
                        = '';
                }
            }
        }
    }
    return;
}

sub is_range() {
    my $port = shift;
    return 1 if $port =~ /:/;
    return 1 if $port =~ /!/;
    return 0;
}

sub import_auto_ips() {
    %auto_ips = ();  ### undef so we don't leave old ips in %auto_ips
    open A, "< $autoips_file";
    my @lines = <A>;
    close A;
    my $i = 1;
    for my $line (@lines) {
        $i++;
        next if ($line =~ /^\s*#/);
        next unless ($line =~ /\S/);
        if ($line =~ /^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+([0-5])/) {
            $auto_ips{$1} = $2;
        } else {
            my $subject = "psad import warning: $autoips_file " .
                "error on line: $i";
            &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'},
                $cmds{'mail'});
        }
    }
    return;
}

sub check_range() {
    my ($port, $start, $end) = @_;
    $start = $port if ($port < $start);
    $end   = $port if ($port > $end);
    return $start, $end;
}

### assign a danger level to a scan.  Note that match_fastsigs()
### and match_sigs() may also assign a danger level.
sub assign_danger_level() {
    SRC: for my $src (keys %scan) {
        print "assign_danger_level(): source ip: $src\n" if $debug;
        if (%auto_ips) {
            if (defined $auto_ips{$src}) {
                for my $dst (keys %{$scan{$src}}) {
                    $scan{$src}{$dst}{'CURR_DL'} = $auto_ips{$src};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                ### ignore $src if the auto danger level is zero
                next SRC if $auto_ips{$src} == 0;
            }
        }
        DST: for my $dst (keys %{$scan{$src}}) {
            my $absnum = $scan{$src}{$dst}{'ABSNUM'};
            my $range;
            if (defined $scan{$src}{$dst}{'S_PORT'}) {
                $range = $scan{$src}{$dst}{'E_PORT'} -
                    $scan{$src}{$dst}{'S_PORT'};
            } else {
                $range = $absnum;
            }
            if ($debug) {
                print "assign_danger_level(): destination ip: $dst\n";
                print "assign_danger_level(): ABSNUM: " .
                    "$scan{$src}{$dst}{'ABSNUM'}\n";
                if (defined $scan{$src}{$dst}{'S_PORT'}) {
                    print "assign_danger_level(): S_PORT: " .
                        "$scan{$src}{$dst}{'S_PORT'}, E_PORT: " .
                        "$scan{$src}{$dst}{'E_PORT'}\n";
                }
                print 'assign_danger_level(): CURR_DL (before assignment) = ' .
                    "$scan{$src}{$dst}{'CURR_DL'}\n";
            }

            ### if $PORT_RANGE_SCAN_THRESHOLD is >= 1, then psad will not assign
            ### a danger level to repeated packets to the same port
            if ($absnum < $config{'DANGER_LEVEL1'}) {
                ### don't have enough packets to even reach danger level 1 yet.
                next DST;
            }
            if ($range >= $config{'PORT_RANGE_SCAN_THRESHOLD'}) {
                if ($absnum < $config{'DANGER_LEVEL2'}) {
                    if ($scan{$src}{$dst}{'CURR_DL'} < 1) {
                        $scan{$src}{$dst}{'ALERTED'} = 0;
                        $scan{$src}{$dst}{'CURR_DL'} = 1;
                    }
                } elsif ($absnum < $config{'DANGER_LEVEL3'}) {
                    if ($scan{$src}{$dst}{'CURR_DL'} < 2) {
                        $scan{$src}{$dst}{'ALERTED'} = 0;
                        $scan{$src}{$dst}{'CURR_DL'} = 2;
                    }
                } elsif ($absnum < $config{'DANGER_LEVEL4'}) {
                    if ($scan{$src}{$dst}{'CURR_DL'} < 3) {
                        $scan{$src}{$dst}{'ALERTED'} = 0;
                        $scan{$src}{$dst}{'CURR_DL'} = 3;
                    }
                } elsif ($absnum < $config{'DANGER_LEVEL5'}) {
                    if ($scan{$src}{$dst}{'CURR_DL'} < 4) {
                        $scan{$src}{$dst}{'ALERTED'} = 0;
                        $scan{$src}{$dst}{'ALERTED'} = 0;
                        $scan{$src}{$dst}{'CURR_DL'} = 4;
                    }
                } elsif ($scan{$src}{$dst}{'CURR_DL'} < 5) {
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                    $scan{$src}{$dst}{'CURR_DL'} = 5;
                }
            }
            print 'assign_danger_level(): CURR_DL (after assignment) = ' .
                "$scan{$src}{$dst}{'CURR_DL'}\n" if $debug;
        }
    }
    return;
}

sub write_packet_counters() {
    open P, "> $config{'PACKET_COUNTER_FILE'}" or
        die " ** Could not open $config{'PACKET_COUNTER_FILE'}: $!";
    print P "tcp:  $tcp_ctr\n";
    print P "udp:  $udp_ctr\n";
    print P "icmp: $icmp_ctr\n";
    close P;
    return;
}

sub collect_errors() {
    my ($bad_packets_aref) = @_;
    open ERR, ">> $config{'ERROR_LOG'}";
    for my $line (@$bad_packets_aref) {
        print ERR "$line\n";
    }
    close ERR;
}

sub scan_logr() {
    for my $src (keys %scan) {
        print STDOUT "scan_logr(): source ip: $src\n" if $debug;
        DST: for my $dst (keys %{$scan{$src}}) {
            next DST if $scan{$src}{$dst}{'ALERTED'};  ### already sent an alert
            next DST unless $scan{$src}{$dst}{'CURR_DL'} >= 1;
            my $syslog_flags = '';
            my $dnsstring    = '';
            my $rdns         = '';
            my $syslog_range = '';
            my $abs_s_port   = '';
            my $abs_e_port   = '';
            my $tcp_s_port   = '';
            my $tcp_e_port   = '';
            my $udp_s_port   = '';
            my $udp_e_port   = '';
            my $tcp_newrange = '';
            my $udp_newrange = '';
            my $range        = '';
            my $tcp  = 0;
            my $udp  = 0;
            my $icmp = 0;
            my $whois_info_aref;

            ### get the current danger level and the absolute number
            ### of packets used in the scan so far
            my $curr_dlevel = $scan{$src}{$dst}{'CURR_DL'};
            my $abs_numpkts = $scan{$src}{$dst}{'ABSNUM'};

            unless (defined $scan{$src}{$dst}{'EMAIL_COUNT'}) {
                $scan{$src}{$dst}{'EMAIL_COUNT'} = 0;
            } elsif ($config{'PSAD_EMAIL_LIMIT'} > 0
                && $scan{$src}{$dst}{'EMAIL_COUNT'}
                > $config{'PSAD_EMAIL_LIMIT'}) {
                ### ignore PSAD_EMAIL_LIMIT if it is zero
                unless (defined $scan{$src}{$dst}{'EMAIL_STOPPED'}) {
                    &email_limit_reached($src, $dst);
                    $scan{$src}{$dst}{'EMAIL_STOPPED'} = 1;
                }
                next DST;
            }
            print STDOUT "scan_logr(): dst ip: $dst\n" if $debug;

            ### make $src directory here in /var/log/psad
            ### unless it already exists
            mkdir "$config{'PSAD_DIR'}/${src}", 0500 unless
                -d "$config{'PSAD_DIR'}/${src}";
            my $scanlog     = "$config{'PSAD_DIR'}/${src}/scanlog";
            my $email_alert = "$config{'PSAD_DIR'}/${src}/email_alert";
            my $ecount_file = "$config{'PSAD_DIR'}/${src}/email_count";
            my $whois_file  = "$config{'PSAD_DIR'}/${src}/whois";
            my $dl_file     = "$config{'PSAD_DIR'}/${src}/danger_level";
            my $log_sigs    = "$config{'PSAD_DIR'}/${src}/signatures";

            ### unlink $email_alert here since we print to this
            ### file multiple times
            unlink $email_alert;

            ### print the current danger level to the danger_level file
            &Psad::logr("$curr_dlevel\n", {$dl_file => 0});

            ### log everything to stdout if $output of $debug is set
            $scanlog = *STDOUT if ($output || $debug);

            ### file => append?  e.g.  filename => 0  means don't append
            my %print_hsh = ($scanlog => 1, $email_alert => 1);

            if (defined $scan{$src}{$dst}{'PROTO'}{'TCP'}{'CURR_INT'}) {
                $tcp = 1;
                $tcp_s_port
                    = $scan{$src}{$dst}{'PROTO'}{'TCP'}{'CURR_INT'}{'S_PORT'};
                $tcp_e_port
                    = $scan{$src}{$dst}{'PROTO'}{'TCP'}{'CURR_INT'}{'E_PORT'};
                if ($tcp_s_port == $tcp_e_port) {
                    $tcp_newrange = $tcp_s_port;
                } else {
                    $tcp_newrange = "$tcp_s_port-$tcp_e_port";
                }
            }
            if (defined $scan{$src}{$dst}{'PROTO'}{'UDP'}{'CURR_INT'}) {
                $udp = 1;
                $udp_s_port
                    = $scan{$src}{$dst}{'PROTO'}{'UDP'}{'CURR_INT'}{'S_PORT'};
                $udp_e_port
                    = $scan{$src}{$dst}{'PROTO'}{'UDP'}{'CURR_INT'}{'E_PORT'};
                if ($udp_s_port == $udp_e_port) {
                    $udp_newrange = $udp_s_port;
                } else {
                    $udp_newrange = "$udp_s_port-$udp_e_port";
                }
            }
            if (defined $scan{$src}{$dst}{'S_PORT'}) {
                $abs_s_port = $scan{$src}{$dst}{'S_PORT'};
                $abs_e_port = $scan{$src}{$dst}{'E_PORT'};
                if ($abs_s_port == $abs_e_port) {
                    $range = $abs_s_port;
                } else {
                    $range = "$abs_s_port-$abs_e_port";
                }
            }
            if (defined $scan{$src}{$dst}{'PROTO'}{'ICMP'}{'CURR_INT'}) {
                $icmp = 1;
            }

            ### get reverse dns info
            unless ($no_rdns) {
                if ($src =~ /^(?:\d{1,3}\.){3}\d{1,3}$/) {
                    my $ipaddr = gethostbyname $src;
                    ### my $rdns = gethostbyaddr($ipaddr, AF_INET);
                    if ($rdns = gethostbyaddr $ipaddr, 2) {
                        $dnsstring = "$src -> $rdns";
                    } else {
                        $dnsstring = "$src -> No reverse dns info available";
                    }
                } else {
                    ### $ipaddr was already reported as
                    ### a host name by iptables
                    $dnsstring = $src;
                }
            }

            ### get whois info
            unless ($no_whois) {
                $whois_info_aref = &get_whois_data($src, $whois_file);
            }
            print STDOUT "scan_logr():  generating email.....\n" if $debug;

            ### get the absolute starting time for the scan and the
            ### current time
            my $s_time = scalar localtime $scan{$src}{$dst}{'S_TIME'};
            my $time   = scalar localtime();

            &Psad::logr("=-=-=-=-=-=-=-=-=-=-=-= $time =-=-=-=-=-=-=-=" .
                "-=-=-=-=\n", \%print_hsh);
            &Psad::logr("psad: portscan detected against $hostname ($dst).\n",
                \%print_hsh);
            &Psad::logr("\n", \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", 'Source: ', "$src\n"),
                \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", 'Destination: ', "$dst\n"),
                \%print_hsh);
            if ($tcp) {
                &Psad::logr(sprintf("%${log_len}s%s", 'Newly scanned TCP ports: ',
                    "[$tcp_newrange]\n"), \%print_hsh);
                &Psad::logr(sprintf("%${log_len}s%s",
                    'Newly Blocked TCP packets: ',
                    "[$scan{$src}{$dst}{'PROTO'}{'TCP'}{'CURR_INT'}{'PKTS'}]\n"),
                    \%print_hsh);
                for my $flags (keys
                    %{$scan{$src}{$dst}{'PROTO'}{'TCP'}{'CURR_INT'}{'FLAGS'}}) {
                    my $num_pkts =
                        $scan{$src}{$dst}{'PROTO'}{'TCP'}
                        {'CURR_INT'}{'FLAGS'}{$flags};
                    $syslog_flags .= "$flags ";
                    &Psad::logr(sprintf("%${log_len}s%s", 'TCP flags: ',
                        "[$flags -- packets: $num_pkts]\n"), \%print_hsh);
                    my $nmap_opts;
                    $nmap_opts = '[-sT or -sS]' if $flags eq 'SYN';
                    $nmap_opts = '[-sF]' if $flags eq 'FIN';
                    $nmap_opts = '[-sX]' if $flags eq 'URG PSH FIN';
                    $nmap_opts = '[-sN]' if $flags eq 'NULL';
                    $nmap_opts = '[-O]'  if $flags eq 'URG PSH SYN FIN';
                    &Psad::logr(sprintf("%${log_len}s%s", 'Nmap options: ',
                        "$nmap_opts\n"), \%print_hsh) if $nmap_opts;
                }
                $syslog_range .= "tcp=[$tcp_newrange] $syslog_flags";
            }
            if ($udp) {
                &Psad::logr(sprintf("%${log_len}s%s", 'Newly scanned UDP ports: ',
                    "[$udp_newrange]\n"), \%print_hsh);
                &Psad::logr(sprintf("%${log_len}s%s", 'Newly blocked UDP packets: ',
                    "[$scan{$src}{$dst}{'PROTO'}{'UDP'}{'CURR_INT'}{'PKTS'}]\n"),
                    \%print_hsh);
            }
            if ($icmp) {
                &Psad::logr(sprintf("%${log_len}s%s", 'Newly blocked ICMP packets: ',
                    "[$scan{$src}{$dst}{'PROTO'}{'ICMP'}{'CURR_INT'}{'PKTS'}]\n"),
                    \%print_hsh);
            }
            if ($range) {
                &Psad::logr(sprintf("%${log_len}s%s", 'Complete TCP/UDP port range: ',
                    "[$range]\n"), \%print_hsh);
            }
            &Psad::logr(sprintf("%${log_len}s%s", 'Total blocked packets: ',
                "$scan{$src}{$dst}{'ABSNUM'}\n"), \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", 'Start time: ',
                "$s_time\n"), \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", 'End time: ',
                "$time\n"), \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", 'Danger level: ',
                "$scan{$src}{$dst}{'CURR_DL'} out of 5\n"), \%print_hsh);
            &Psad::logr(sprintf("%${log_len}s%s", 'DNS info: ',
                "$dnsstring\n"), \%print_hsh) unless $no_rdns;

            if ($use_iptables) {
                ### print any matched signatures to the alert
                &scan_logr_signatures($src, $dst,
                    {$scanlog=>1, $email_alert=>1, $log_sigs=>1});
            }

            ### write a message to syslog
            openlog 'psad', LOG_DAEMON, LOG_LOCAL7;
            syslog LOG_INFO, "scan detected: $src -> $dst $syslog_range " .
                "pkts=$abs_numpkts dangerlevel: $curr_dlevel";
            closelog();
            unless ($no_whois) {
                &Psad::logr("\n\n", \%print_hsh);
                &Psad::logr("---- Whois Information: ----\n", \%print_hsh);
                for my $line (@$whois_info_aref) {
                    &Psad::logr($line, \%print_hsh);
                }
                &Psad::logr("\n", \%print_hsh);
            }
            &Psad::logr("=-=-=-=-=-=-=-=-=-=-=-= $time =-=-=-=-=-=-=-=" .
                "-=-=-=-=\n", \%print_hsh);
            if ($curr_dlevel >= $config{'EMAIL_ALERT_DANGER_LEVEL'}) {
                my $subject;
                if ($rdns) {
                    if ($benchmark) {
                        $subject = "psad: BENCHMARK SCAN from: $rdns";
                    } else {
                        $subject = "psad: SCAN DETECTED from: $rdns";
                    }
                } else {
                    if ($benchmark) {
                        $subject = "psad: BENCHMARK SCAN from: $src";
                    } else {
                        $subject = "psad: SCAN DETECTED from: $src";
                    }
                }
                &Psad::sendmail($subject, $email_alert, $config{'EMAIL_ADDRESSES'},
                    $cmds{'mail'});
                $scan{$src}{$dst}{'EMAIL_COUNT'}++;

                ### print the number of email alerts we have sent
                &Psad::logr("$scan{$src}{$dst}{'EMAIL_COUNT'}\n",
                    {$ecount_file => 0});
            }
            ### delete all current intervals so they won't show up
            ### in the next alert
            delete $scan{$src}{$dst}{'PROTO'}{'TCP'}{'CURR_INT'};
            delete $scan{$src}{$dst}{'PROTO'}{'UDP'}{'CURR_INT'};
            delete $scan{$src}{$dst}{'PROTO'}{'ICMP'}{'CURR_INT'};

            ### we have sent an alert for $dst
            $scan{$src}{$dst}{'ALERTED'} = 1;
        }
    }
    return;
}

sub scan_logr_signatures() {
    my ($src, $dst, $print_hsh_href) = @_;
    ### ok, these hash keys are too much
    for my $proto (keys %{$scan{$src}{$dst}{'PROTO'}}) {
        if (defined $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_SIG'}) {
            &Psad::logr("\n", $print_hsh_href);
            &Psad::logr("---- $proto scan signatures ----\n", $print_hsh_href);
        }
        print "scan_logr_signatures(): src: $src dst: $dst proto: $proto\n"
            if $debug;
        for my $sig_id (keys %{$scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_SIG'}}) {
            my $msg = $sigs_attr{$sig_id}{'msg'};
            if ($proto eq 'TCP') {
                for my $dp (keys
                    %{$scan{$src}{$dst}{'PROTO'}{'TCP'}{'CURR_SIG'}
                    {$sig_id}{'LISTEN'}}) {
                    my $flags =
                        $scan{$src}{$dst}{'PROTO'}{'TCP'}
                        {'CURR_SIG'}{$sig_id}{'LISTEN'}{$dp}{'FLAGS'};
                    my $pkts =
                        $scan{$src}{$dst}{'PROTO'}{'TCP'}
                        {'CURR_SIG'}{$sig_id}{'LISTEN'}{$dp}{'PKTS'};
                    &Psad::logr("\"$msg\" dp=$dp flags=[$flags] packets=$pkts " .
                        "** Your machine is listening on TCP port: $dp!\n",
                        $print_hsh_href);
                }
                for my $dp (keys
                    %{$scan{$src}{$dst}{'PROTO'}{'TCP'}
                    {'CURR_SIG'}{$sig_id}{'NO_LISTEN'}}) {
                    my $flags =
                        $scan{$src}{$dst}{'PROTO'}{'TCP'}{'CURR_SIG'}
                        {$sig_id}{'NO_LISTEN'}{$dp}{'FLAGS'};
                    my $pkts =
                        $scan{$src}{$dst}{'PROTO'}{'TCP'}{'CURR_SIG'}
                        {$sig_id}{'NO_LISTEN'}{$dp}{'PKTS'};
                    &Psad::logr("\"$msg\" dp=$dp flags=[$flags] packets=$pkts " .
                        "No server on TCP port: $dp\n", $print_hsh_href);
                }
            } elsif ($proto eq 'UDP') {
                for my $dp (keys
                    %{$scan{$src}{$dst}{'PROTO'}{'UDP'}{'CURR_SIG'}
                    {$sig_id}{'LISTEN'}}) {
                    my $pkts =
                        $scan{$src}{$dst}{'PROTO'}{'UDP'}{'CURR_SIG'}
                        {$sig_id}{'LISTEN'}{$dp}{'PKTS'};
                    &Psad::logr("\"$msg\" dp=$dp packets=$pkts " .
                        "** Your machine is listening on UDP port: $dp!\n",
                        $print_hsh_href);
                }
                for my $dp (keys
                    %{$scan{$src}{$dst}{'PROTO'}{'UDP'}{'CURR_SIG'}
                    {$sig_id}{'NO_LISTEN'}}) {
                    my $pkts =
                        $scan{$src}{$dst}{'PROTO'}{'UDP'}{'CURR_SIG'}
                        {$sig_id}{'NO_LISTEN'}{$dp}{'PKTS'};
                    &Psad::logr("\"$msg\" dp=$dp packets=$pkts " .
                        "No server on UDP port: $dp\n", $print_hsh_href);
                }
            } else {
                my $pkts = $scan{$src}{$dst}{'PROTO'}{'ICMP'}
                    {'CURR_SIG'}{$sig_id}{'PKTS'};
                &Psad::logr("\"$msg\"  packets=$pkts\n", $print_hsh_href);
            }

            ### signature logging with syslog is not yet supported
            ### (requires a message for each matched signature).
#            if ($sigmatch =~ /^(\".*\")/) {
#                $syslog_sig_title = "signature=$1";
#            }
        }
        ### need to delete the current signature so it
        ### won't show up in the next alert
        delete $scan{$src}{$dst}{'PROTO'}{$proto}{'CURR_SIG'}
            unless $config{'SHOW_ALL_SIGNATURES'} eq 'Y';
    }
    return;
}

sub old_auto_blocked_ips() {
    if (-e $auto_blocked_file) {
        open B, "< $auto_blocked_file" or
            warn " ** Could not open $auto_blocked_file\n" and return;
        my @blines = <B>;
        close B;
        my $use_ipchains;
        my $use_iptables;
        my @block_ips;
        for my $line (@blines) {
            chomp $line;
            if ($line =~ /IPTABLES/) {
                $use_iptables = 1;
            } elsif ($line =~ /IPCHAINS/) {
                $use_ipchains = 1;
            }
            if ($line =~ /^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/) {
                push @block_ips, $1;
            }
        }
        if ($use_iptables) {
            &iptables_flags unless $checked_iptables_flags;
            for my $blockip (@block_ips) {
                if ($flush_fw_rules) {
                    print " .. Removing rules for: $blockip\n";
                }
                for my $table (keys %iptables_chains) {
                    for my $chain (keys %{$iptables_chains{$table}}) {
                        ### The rule numbers can change for each ip
                        my @rules = `$cmds{'iptables'} -t $table -nL $chain`;
                        my $blocked = 0;
                        my $rulenum = 1;
                        RULE: for my $rule (@rules) {
                            next RULE if ($rule =~ /^Chain\s/);
                            next RULE if ($rule =~ /^target\s/);
                            chomp $rule;
                            ### DROP       all  --  1.1.1.1        0.0.0.0/0
                            if ($rule =~ /^DROP\s+all.*?$blockip\s+0\.0\.0\.0\/0/) {
                                ### all traffic from $blockip is being blocked
                                $blocked = 1;
                                if ($flush_fw_rules) {
                                    print "     Deleting rule $table $chain: $rule\n";
                                    system "$cmds{'iptables'} -t $table -D $chain $rulenum";
                                } else {
                                    last RULE;
                                }
                            }
                            $rulenum++;
                        }
                        unless ($blocked || $flush_fw_rules) {
                            &iptables_block($table, $chain, $blockip);
                        }
                        if ($flush_fw_rules && ! $blocked) {
                            print " .. Could not locate any $table $chain " .
                                "auto-generated rules for $blockip\n";
                        }
                    }
                }
            }
        } elsif ($use_ipchains) {
            for my $chain (@ipchains_chains) {
                for my $blockip (@block_ips) {
                    ### The rule numbers can change for each ip
                    my @rules = `$cmds{'ipchains'} -nL $chain`;
                    my $blocked = 0;
                    my $rulenum = 1;
                    if ($flush_fw_rules) {
                        print " .. Removing rules for: $blockip\n";
                    }
                    RULE: for my $rule (@rules) {
                        chomp $rule;
                        ### DENY       udp  ------  0.0.0.0/0      0.0.0.0/0      * ->   *
                        if ($rule =~ /^DENY\s+all.*?$blockip.*0\.0\.0\.0\/0\s+\*\s+\-\>\s+\*/) {
                            ### all traffic from $blockip is being blocked
                            $blocked = 1;
                            if ($flush_fw_rules) {
                                print "     Deleting rule: $rule\n";
                                system "$cmds{'ipchains'} -D $chain $rulenum";
                            } else {
                                last RULE;
                            }
                        }
                        $rulenum++;
                    }
                    unless ($blocked || $flush_fw_rules) {
                        &ipchains_block($chain, $blockip);
                    }
                    if ($flush_fw_rules && ! $blocked) {
                        print " .. Could not locate any auto-generated " .
                            "rules for: $blockip\n";
                    }
                }
            }
        }
    }
    return;
}

sub auto_psad_response() {
    if ($use_iptables && ! $checked_iptables_flags) {
        ### determine whether or not the NAT or mangle code has
        ### been compiled into iptables
        &iptables_flags();
    }
    SOURCE: for my $src (keys %scan) {
        for my $dst (keys %{$scan{$src}}) {
            my $current_danger_level = $scan{$src}{$dst}{'CURR_DL'};
            ### We only want to block the IP once.  Currently this will block
            ### all traffic from the host to _all_ destinations that are
            ### protected by the firewall if the ip trips the $auto_psad_level
            ### threshold for _any_ destination.
            if ($current_danger_level
                >= $config{'AUTO_IDS_DANGER_LEVEL'}
                && ! defined $scan{$src}{$dst}{'BLOCKED'}) {
                if ($use_ipchains) {
                    my $blocked_str = '';
                    if ($config{'IPCHAINS_BLOCK_METHOD'} eq 'Y') {
                        for my $chain (@ipchains_chains) {
                            &ipchains_block($chain, $src);
                        }
                        $blocked_str = 'via ipchains';
                    } elsif ($config{'TCPWRAPPERS_BLOCK_METHOD'} eq 'Y') {
                        ### NOTE the elsif here since we only really want
                        ### to block the ip in one way, and we prefer
                        ### the firewall.
                        open H, ">> /etc/hosts.deny" or die
                            "Could not open /etc/hosts.deny: $!";
                        print H "ALL: $src\n";
                        close H;
                        $blocked_str = 'via tcp wrappers';
                    }
                    for my $dst (keys %{$scan{$src}}) {
                        $scan{$src}{$dst}{'BLOCKED'} = 1;
                    }
                    if ($config{'ALERT_AUTO_BLOCKED'} eq 'Y' && $blocked_str) {
                        my $subject = "psad: All traffic from $src has been " .
                            "BLOCKED $blocked_str on $hostname ($dst)";
                        &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'},
                            $cmds{'mail'});
                    }
                    ### write the $src ip to the $auto_blocked_file
                    &write_blocked_ip($src);
                    next SOURCE;
                } elsif ($use_iptables) {
                    my $blocked_str = '';
                    if ($config{'IPTABLES_BLOCK_METHOD'} eq 'Y') {
                        for my $table (keys %iptables_chains) {
                            for my $chain (keys %{$iptables_chains{$table}}) {
                                &iptables_block($table, $chain, $src);
                            }
                        }
                        $blocked_str = 'via iptables';
                    } elsif ($config{'TCPWRAPPERS_BLOCK_METHOD'} eq 'Y') {
                        ### NOTE the elsif here since we only really want
                        ### to block the ip in one way, and we prefer
                        ### the firewall.
                        open H, '>> /etc/hosts.deny' or
                            die "Could not open /etc/hosts.deny: $!";
                        print H "ALL: $src\n";
                        close H;
                        $blocked_str = 'via tcp wrappers';
                    }
                    for my $dst (keys %{$scan{$src}}) {
                        $scan{$src}{$dst}{'BLOCKED'} = 1;
                    }
                    if ($config{'ALERT_AUTO_BLOCKED'} eq 'Y' && $blocked_str) {
                        my $subject = "psad: All traffic from $src has been ".
                            "BLOCKED $blocked_str on $hostname ($dst)";
                        &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'},
                            $cmds{'mail'});
                    }
                    ### write the $src ip to the $auto_blocked_file
                    &write_blocked_ip($src);
                    next SOURCE;
                }
            }
        }
    }
    return;
}

sub iptables_flags() {
    $checked_iptables_flags = 1;
    $iptables_chains{'filter'}{'INPUT'}   = '';
    $iptables_chains{'filter'}{'FORWARD'} = '';
    my $nat_rv    = (system "$cmds{'iptables'} -nL -t nat " .
        "> /dev/null 2>&1") >> 8;
    my $mangle_rv = (system "$cmds{'iptables'} -nL -t mangle " .
        "> /dev/null 2>&1") >> 8;
    if ($nat_rv == 0) {
        $iptables_chains{'nat'}{'PREROUTING'} = '';
    }
    if ($mangle_rv == 0) {
        $iptables_chains{'mangle'}{'PREROUTING'} = '';
    }
    return;
}

sub iptables_block() {
    my ($table, $chain, $src) = @_;
    system "$cmds{'iptables'} -t $table -I $chain 1 " .
        "-s $src -j DROP 2> /dev/null 1>&2";
    return;
}

sub ipchains_block() {
    my ($chain, $src) = @_;
    system "$cmds{'ipchains'} -I $chain 1 -s $src " .
        "-j DENY 2> /dev/null 1>&2";
    return;
}

sub write_blocked_ip() {
    my $src = shift;
    if (-e $auto_blocked_file) {
        open B, ">> $auto_blocked_file" or warn
                " ** Could not append to $auto_blocked_file\n" and return;
        print B "$src\n";
        close B;
    } else {
        open B, "> $auto_blocked_file" or warn
                " ** Could not create $auto_blocked_file\n" and return;
        print B "IPTABLES\n" if $use_iptables;
        print B "IPCHAINS\n" if $use_ipchains;
        print B "$src\n";
        close B;
    }
    return;
}

sub email_limit_reached() {
    my ($src, $dst) = @_;
    my $subject = "psad: Email message limit for $src has been reached on " .
        "$hostname ($dst)!!!";
    &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
    return;
}

sub print_scan() {  ### this should primarily be used for debugging
    my $scanfile = $config{'PRINT_SCAN_HASH'} . ".$$";
    open PSCAN, "> $scanfile";
    print PSCAN Dumper \%scan;
    close PSCAN;
    chmod 0600, $scanfile;
    print STDOUT " .. Printing scan data structures to $scanfile\n\n";
    return;
}

sub check_fw() {
    my $line = shift;
    ### ipchains log messages do not have a MAC address field
    if ($line !~ /MAC=/) {
        $use_ipchains = 1;
        ### check
    } else {
        $use_iptables = 1;
    }
}

sub get_local_ips() {
    my @ips = `$cmds{'ifconfig'} -a`;
    my %local_ips;
    for my $line (@ips) {
        if ($line =~ /inet\s+addr:(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s/) {
            $local_ips{$1} = '';
        }
    }
    return \%local_ips;
}

sub get_listening_ports() {
    %local_listening_ports = ();
    my @lines = `$cmds{'netstat'} -an`;
    for my $line (@lines) {
        chomp $line;
        if ($line =~ m/^\s*(tcp|udp)\s+\d+\s+\d+\s+\S+:(\d+)\s/) {
            ### $1 == protoco (tcp/udp), $2 == port number
            ### convert to upper case to be consistent with iptables
            ### messages (protocol is upper case 'TCP', etc.)
            $local_listening_ports{uc($1)}{$2} = '';
        }
    }
    return;
}

sub get_whois_data() {
    my ($ip, $whois_datafile) = @_;
    my @whois_data;
    if (defined $whois_cache{$ip}
        && $whois_cache{$ip} < $config{'WHOIS_THRESHOLD'}
        && -e $whois_datafile) {
        $whois_cache{$ip}++;
    } else {
        $whois_cache{$ip} = 0;
        eval {
            local $SIG{'ALRM'} = sub {die "whois alarm\n"};
            alarm $config{'WHOIS_TIMEOUT'};
            system "$cmds{'whois'} $ip > $whois_datafile";
            alarm 0;
        };
        if ($@) {
            ### die unless $@ eq "whois alarm\n";
            ### warn "$@: $?";  ### let the warning handler save the error.
            warn $@;
            $#whois_data = 0;
            @whois_data = ("Whois data not available!\n");
            unlink $whois_datafile;
            return \@whois_data;
        }
    }
    open W, "< $whois_datafile" or
        die " ** Could not open $whois_datafile: $!";
    @whois_data = <W>;
    close W;
    return \@whois_data;
}

sub REAPER {
    my $pid;
    $pid = waitpid(-1, WNOHANG);
#   if (WIFEXITED($?)) {
#       print STDERR " .. **  Process $pid exited.\n";
#   }
    $SIG{'CHLD'} = \&REAPER;
    return;
}

sub check_permissions() {
    my @files = @_;
    for my $file (@files) {
        if (-e $file) {
            chmod 0600, $file;
        } else {
            open T, "> $file";
            close T;
            chmod 0600, $file;
        }
    }
    return;
}

sub kill_psad() {
    ### must kill psadwatchd first since if not, it might try to restart
    ### any of the other three daemons (its pid file is listed first in
    ### @pidfiles)
    for my $pidfile (@pidfiles) {
        my ($pidname) = ($pidfile =~ m|.*/(\w+)\.pid|);
        if (-e $pidfile) {
            open PIDFILE, "< $pidfile";
            my $pid = <PIDFILE>;
            close PIDFILE;
            chomp $pid;
            if (kill 0, $pid) {
                print " .. Killing $pidname, pid: $pid\n";
                unless (kill 15, $pid) {
                    kill 9, $pid or print " ** psad: Could not kill " .
                        "$pidname, pid: $pid $!\n";
                }
            } else {
                print " ** psad: $pidname is not running on $hostname.\n";
            }
        } else {
            print " ** psad: pid file $pidfile does not exist for " . 
                "$pidname on $hostname\n";
        }
    }
    return;
}

sub restart() {
    my $cmdline;
    if (-e $cmdline_file) {
        open CMD, "< $cmdline_file";
        $cmdline = <CMD>;
        close CMD;
        chomp $cmdline;
    } else {
        die " ** psad:  No other psad process is ",
            "running on $hostname!";
    }
    &kill_psad();
    print " .. Restarting the psad daemons on $hostname\n";
    system "$cmds{'psad'} $cmdline";
    return;
}

### display the status of all four psad daemons
sub status() {
    my $cmdline;
    ### only the psad daemon (normally) runs with command line arguments
    if (-e $cmdline_file) {
        open CMD, "< $cmdline_file";
        $cmdline = <CMD>;
        chomp $cmdline;
    }
    my $rv = 0;   ### assume psad is not running and test...
    for my $pidfile ($config{'PSAD_PID_FILE'},
            $config{'PSADWATCHD_PID_FILE'},
            $config{'KMSGSD_PID_FILE'},
            $config{'DISKMOND_PID_FILE'}) {
        my ($pidname) = ($pidfile =~ /(\w+)\.pid$/);
        if (-e $pidfile) {
            open PIDFILE, "< $pidfile";
            my $pid = <PIDFILE>;
            close PIDFILE;
            chomp $pid;
            if (kill 0, $pid) {
                print " .. $pidname (pid: $pid)";
                my @ps_out = `$cmds{'ps'} -auxww`;
                PS: for my $line (@ps_out) {
                    chomp $line;
                    if ($line =~ /^\S+\s+$pid\s+(\S+)\s+(\S+)/) {
                        print "  %CPU: $1  %MEM: $2\n";
                        print "     Running since: " .
                            localtime(stat($pidfile)->mtime) . "\n";
                        if ($pidname eq 'psad') {
                            if ($cmdline) {
                                print "     Command line arguments: $cmdline\n";
                            } else {
                                print "     Command line arguments: [none specified]\n";
                            }
                            ### print the packet counters
                            if (-e $config{'PACKET_COUNTER_FILE'}) {
                                print "     Packets Counters:\n";
                                open F, "< $config{'PACKET_COUNTER_FILE'}" or
                                    die " ** $config{'PACKET_COUNTER_FILE'}: $!";
                                print STDOUT "        $_" while (<F>);
                                close F;
                            }
                            ### sort and print the scan source ips
                            my %scan_source_ips;
                            chdir $config{'PSAD_DIR'} or
                                die " ** Could not chdir $config{'PSAD_DIR'}: $!";
                            opendir D, $config{'PSAD_DIR'} or
                                die " ** Could not open dir: $config{'PSAD_DIR'}: $!";
                            my @files = readdir D;
                            closedir D;
                            shift @files; shift @files;
                            for my $file (@files) {
                                if ($file =~ /(?:\d{1,3}\.){3}\d{1,3}/
                                    && -d $file) {
                                    ### $file is a current scan source ip
                                    my $src_ipdir = $file;
                                    if (-e "${src_ipdir}/danger_level") {
                                        open F, "< ${src_ipdir}/danger_level" or
                                            die " ** Could not open ",
                                                "${src_ipdir}/danger_level\n";
                                        my $dl = <F>;
                                        close F;
                                        chomp $dl;
                                        $scan_source_ips{$dl}{$src_ipdir} = '';
                                    } else {
                                        $scan_source_ips{0}{$src_ipdir} = '';
                                    }
                                }
                            }
                            print STDOUT "     Danger_Level:   IP:\n";
                            if (%scan_source_ips) {
                                for my $dl (sort {$b <=> $a} keys %scan_source_ips) {
                                    for my $src (keys %{$scan_source_ips{$dl}}) {
                                        print STDOUT "                  $dl   " .
                                            sprintf("%16s", $src) . "\n";
                                    }
                                }
                            } else {
                                print STDOUT "     [No scans detected.]\n";
                            }
                        }
                        last PS;
                    }
                }
                print "\n";
                $rv = 1;
            } else {
                print " ** psad: $pidname is not running on $hostname\n";
            }
        } else {
            print " ** psad: pid file $pidfile does not exist for " .
                "$pidname on $hostname\n";
        }
    }
    exit $rv;
}

sub usr1() {
    my $rv = 0;
    my $psad_pidfile = $pidfiles[1];
    if (-e $psad_pidfile) {
        open PIDFILE, "< $psad_pidfile" or
                die " ** Could not open $psad_pidfile: $!";
        my $pid = <PIDFILE>;
        close PIDFILE;
        chomp $pid;
        if (kill 0, $pid) {  ### make sure psad is actually running
            if (kill 'USR1', $pid) {
                $rv = 1;
                ### sleep to give time for the USR1 signal to be delivered
                ### and for the file to be created.
                sleep 1;
                open U, "< $config{'PSAD_DIR'}/scan_hash.${pid}"
                    or print " ** Sent psad pid $pid a USR1 " .
                        "signal, but could not open\n" .
                        "\"$config{'PSAD_DIR'}/scan_hash.${pid}\n\""
                    and return $rv;
                print while(<U>);
                close U;
            } else {
                print " ** Could not send psad the USR1 signal on $hostname\n";
            }
        } else {
            print " ** psad is not running on $hostname\n";
        }
    }
    return $rv;
}

sub archive_data() {
    chdir $config{'PSAD_DIR'} or die " ** Could not chdir ",
        "$config{'PSAD_DIR'}: $!";
    unless (-d $config{'SCAN_DATA_ARCHIVE_DIR'}) {
        mkdir $config{'SCAN_DATA_ARCHIVE_DIR'}, 0500 or
            die " ** Could not create dir: ",
            "$config{'SCAN_DATA_ARCHIVE_DIR'}: $!";
    }

    ### archive all of the old ip address directories since
    ### we are restarting psad (should add a way to import
    ### these directories back into memory)
    opendir D, $config{'PSAD_DIR'} or die " ** Could not open dir: ",
        "$config{'PSAD_DIR'}: $!";
    my @files = readdir D;
    closedir D;
    shift @files; shift @files;

    for my $file (@files) {
        if ($file =~ /(?:\d{1,3}\.){3}\d{1,3}/ && -d $file) {
            ### $file is an old scaning ip from a previous psad execution
            my $old_ipdir     = $file;
            my $archive_ipdir = "$config{'SCAN_DATA_ARCHIVE_DIR'}/$old_ipdir";
            if (-d $archive_ipdir) {
                rmtree $archive_ipdir;
            }
            move $old_ipdir, $archive_ipdir;
        }
    }

    ### archive the fwdata file
    my $fwdata    = $config{'FW_DATA'};
    my $fwarchive = "$config{'SCAN_DATA_ARCHIVE_DIR'}/fwdata_archive";
    ### first see how big the archive file is and zero out if
    ### it is larger than about 10,000 lines
    if (-e $fwarchive && (-s $fwarchive) > 2367766) {  ### about 10,000 lines
        open F, "> $fwarchive";
        close F;
    }
    unless (-e $fwdata) {
        return;
    }
    open FW, "< $fwdata" or die "$fwdata exists but couldn't open it: $!";
    my @fwlines = <FW>;
    close FW;
    open AR, ">> $fwarchive" or die "Could not open $fwarchive: $!";
    print AR $_ for @fwlines;
    close AR;
    ### zero out $FW_DATA
    open F, "> $fwdata";
    close F;
    return;
}

sub check_old_cmdargs() {
    &print_old_arg('auto_ips', 'auto-ips') if $oldarg_autoips;
    &print_old_arg('Logging_server', 'log-server') if $oldarg_logserv;
    &print_old_arg('errors', 'no-errors') if $oldarg_errs;
    &print_old_arg('no_errors', 'no-errors') if $oldarg_nerrs;
    &print_old_arg('reversedns', 'no-rdns') if $oldarg_rdns;
    &print_old_arg('no_rdns', 'no-rdns') if $oldarg_nrdns;
    &print_old_arg('whois', 'no-whois') if $oldarg_whois;
    &print_old_arg('no_whois', 'no-whois') if $oldarg_nwhois;
    &print_old_arg('no_localport', 'no-localport') if $oldarg_nlport;
    &print_old_arg('localport', 'no-netstat') if $oldarg_netstat;
    &print_old_arg('firewallcheck', 'no-fwcheck') if $oldarg_fwcheck;
    &print_old_arg('no_fw_check', 'no-fwcheck') if $oldarg_nfwchk;
    &print_old_arg('Daemon', 'no-daemon') if $oldarg_daemon;
    return;
}

sub print_old_arg() {
    my ($oldarg, $newarg) = @_;
    print " ** The \"$oldarg\" option has been changed to \"$newarg\"\n";
    &usage(1);
    return;
}

sub setup() {

    ### turn off buffering
    $| = 1;

    unless (-d $config{'PSAD_DIR'}) {
        mkdir $config{'PSAD_DIR'}, 0500;
    }
    unless (-d $config{'PSAD_ERROR_DIR'}) {
        mkdir $config{'PSAD_ERROR_DIR'}, 0500;
    }
    unless (-e $config{'FW_DATA'}) {
        open F, "> $config{'FW_DATA'}";
        close F;
    }
    unless (-e $config{'ERROR_LOG'}) {
        open E, "> $config{'ERROR_LOG'}";
        close E;
    }
    unless (-e $config{'PSAD_FIFO'}) {
        system "$cmds{'mknod'} -m 600 $config{'PSAD_FIFO'} p";
    }
    unless (-e '/etc/syslog.conf.orig') {
        copy('/etc/syslog.conf', '/etc/syslog.conf.orig');
    }
    open RS, '< /etc/syslog.conf' or
        die " ** Unable to open /etc/syslog.conf: $!";
    my @slines = <RS>;
    close RS;
    my $found = 0;
    for my $line (@slines) {
        $found = 1 if $line =~ m/|\s*$config{'PSAD_FIFO'}/;
    }
    unless ($found) {
        open SYSLOG, '> /etc/syslog.conf' or
            die " ** Unable to open /etc/syslog.conf: $!";
        for my $line (@slines) {
            unless ($line =~ /psadfifo/) {
                print SYSLOG $line;
            }
        }
        ### reinstate kernel logging to our named pipe
        print SYSLOG "### Send kern.info messages to psadfifo for " .
            "analysis by kmsgsd\n";
        print SYSLOG "kern.info\t\t|$config{'PSAD_FIFO'}\n";
        close SYSLOG;
        system "$cmds{'killall'} -HUP $cmds{'syslogd'}";
    }
    if (-e '/etc/syslog-ng/syslog-ng.conf') {
        open RS, '< /etc/syslog-ng/syslog-ng.conf' or
            die " ** Unable to open /etc/syslog-ng/syslog-ng.conf: $!\n";
        my @slines = <RS>;
        close RS;

        my $found_fifo = 0;
        for my $line (@slines) {
            $found_fifo = 1 if ($line =~ /psadfifo/);
        }

        unless ($found_fifo) {
            open SYSLOGNG, '>> /etc/syslog-ng/syslog-ng.conf' or
                die " ** Unable to open /etc/syslog-ng/syslog-ng.conf: $!\n";
            print SYSLOGNG "\n";
            print SYSLOGNG "destination psadpipe { pipe(\"/var/run/psadfifo\"); };\n";
            print SYSLOGNG "filter f_kerninfo { facility(kern) and level(info); };\n";
            print SYSLOGNG "log { source(src); filter(f_kerninfo); destination(psadpipe); };\n";
            close SYSLOGNG;
            system "$cmds{'killall'} -HUP syslog-ng";
        }
    }
    return;
}

sub check_config() {
    my @required_vars = qw(
        EMAIL_ADDRESSES  PSAD_CHECK_INTERVAL FW_DATA ERROR_LOG
        FW_MSG_SEARCH1 FW_MSG_SEARCH2 ENABLE_AUTO_IDS
        IGNORE_CONNTRACK_BUG_PKTS SCAN_TIMEOUT DANGER_LEVEL1
        DANGER_LEVEL2 DANGER_LEVEL3 DANGER_LEVEL4 DANGER_LEVEL5
        PORT_RANGE_SCAN_THRESHOLD ALERT_ALL PSAD_EMAIL_LIMIT
        IPTABLES_BLOCK_METHOD IPCHAINS_BLOCK_METHOD
        TCPWRAPPERS_BLOCK_METHOD EMAIL_ALERT_DANGER_LEVEL
        PSAD_FIFO WHOIS_THRESHOLD WHOIS_TIMEOUT
        PACKET_COUNTER_FILE SCAN_DATA_ARCHIVE_DIR
        ENABLE_PERSISTENCE
    );
    &Psad::validate_config($config_file, \@required_vars, $config_href);
    return;
}

sub dump_conf() {
    for my $var (keys %config) {
        printf("%30s%s\n", " .. $var", $config{$var});
    }
    exit 0;
}

sub usage() {
    my $exitcode = shift;
    print <<_HELP_;

psad; the Port Scan Attack Detector
Version: $version
By Michael Rash (mbr\@cipherdyne.com, http://www.cipherdyne.com)

Usage: psad [-s <signature file>] [-a <auto ips file>] [-c <config file>]
       [-l] [-i <interval>] [-h] [-B] [-F] [-S] [-K] [-R] [-U] [-V] [-f] [-o]
       [-p] [--no-fwcheck] [--no-daemon] [--no-rdns] [--no-whois]
       [--no-netstat] [--no-errors]

Options:
      -s   --signatures <sig file>    - Import scan signatures.
      -a   --auto-ips <ips file>      - Import auto ips file for automatic
                                        ip danger level increases/decreses.
      -c   --config <config file>     - Use config file instead of the
                                        values contained within the psad
                                        script.
      -f   --fw-check                 - Analyze the local firewall ruleset
                                        and exit.
      -i   --interval                 - Configure the check interval from
                                        the command line to override the 15
                                        second default.
      -d   --debug                    - Run psad in debugging mode.
      -o   --output                   - Print all messages to STDOUT (this
                                        does not include bad packet messages
                                        that are printed to the error log).
      -l   --log-server               - Psad is being run on a syslog
                                        logging server.
      -F   --Flush                    - Remove any auto-generated firewall
                                        block rules.
      -K   --Kill                     - Kill all running psad processes.
      -R   --Restart                  - Restart all running psad processes.
      -S   --Status                   - Displays the status of any
                                        currently running psad processes.
      -B   --Benchmark                - run psad in benchmark mode.
      -p   --packets                  - Specify number of packets to use in
                                        benchmark test.
      -U   --USR1                     - Send a running psad process a USR1
                                        signal (generates a dump of psad
                                        data structures on STDOUT).
      -V   --Version                  - Print the psad version and exit.

      --no-daemon                     - Do not run as a daemon.
      --no-errors                     - Do not write errors to the error
                                        log.
      --no-whois                      - Disable whois lookups.
      --no-fwcheck                    - Disable firewall rules verification.
      --no-rdns                       - Disable name resolution against
                                        scanning ips.
      --no-netstat                    - Disable local port lookups for scan
                                        signatures.
      -h   --help                     - Prints this usage message.

_HELP_
    exit $exitcode;
}
