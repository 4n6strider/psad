#!/usr/bin/perl -w
#
################################################################################
#
# File: psad
#
# Purpose: psad makes use of ipchains/iptables logs to detect port
#          scans.  Data is provided by kmsgsd which reads firewall
#          messages out of the /var/lib/psad/psadfifo named pipe
#          (syslog is reconfigured to write kern.info messages there
#          which include firewall messages).  For more information
#          read the psad man page.
#
# Author: Michael B. Rash (mbr@cipherdyne.com)
#
# Credits:  (see the CREDITS file)
#
# Version: 1.0.0-pre4
#
# Copyright (C) 1999-2002 Michael B. Rash (mbr@cipherdyne.com)
#
# License (GNU Public License):
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
#    USA
#
# TODO:
#   - Make use of other logging options available in iptables to detect
#     more tcp signatures.  (E.g. --log-tcp-options, --log-ip-options,
#     --log-tcp-sequence, etc.) for better signature recognition.
#   - Make use of string matching support to look for application level
#     signatures.  See http://www.stearns.org/snort2iptables.
#   - Include a verbose message in the body of certain emails that as
#     of psad-1.0.0-pre2 only contain a subject line.
#   - Allow ipchains to use tcp signatures that only require a syn packet
#     to a port as well as udp signatures.
#   - Deal with the possibility that psad could eat lots of memory over
#     time if $ENABLE_PERSISTENCE="Y". This should involve periodically
#     deleting entries in %scan (or maybe the entire hash), but this
#     should be done in a way that allows some scan data to persist.
#   - Put source and destination ip addresses back into psad_signatures.
#   - Ipfilter support on *BSD platforms.
#   - Possibly add a daemon to take into account ACK PSH, ACK FIN, RST etc.
#     packets that the client may generate after the ip_conntrack module
#     is reloaded.  Without anticipating such packets psad will interpret
#     them as a belonging to a port scan.  NOTE: This problem is mostly
#     corrected by the conntrack patch to the kernel.
#   - Improve check_firewall_rules() to check for a state rule (iptables)
#     since having such a rule greatly improves the quality of the data
#     stream provided to psad by kmsgsd since more packet types will be
#     denied without requiring overly complicated firewall rules to detect
#     odd tcp flag combinations.
#   - Investigate the possibility of passive OS fingerprinting by looking
#     at TTL and other fields in the headers (good idea Jay).
#   - Handle various logging daemons other than syslog such as syslog-ng,
#     msyslog, and metalog.
#   - perldoc
#
# Default Command Line Arguments:  As of the 1.0.0-pre3 release, psad by
#   by default will have the --signatures and --auto_ips options set even
#   if these options are not specified on the command line, and psad
#   will use the default locations for the signatures and auto_ips files.
#   The default file locations can be changed by manually specifying the
#   locations to these files with the --signatures and --auto_ips options.
#   The signature matching and the auto_ips danger level assignments can
#   be disabled by using the --no_signatures and --no_auto_ips options
#   respectively.  In addition the psad adheres to the following
#   defaults:
#       -write errors to error log            = yes
#       -daemon mode                          = yes
#       -reverse dns lookups                  = yes
#       -check firewall rules                 = yes
#       -whois lookups of scanning ips        = yes
#       -parse netstat output for local ports = yes
#
# Coding Style:  All configuration variables from psad.conf are stored in
#   the $config hash ref by keys that are in capital letters.  This is
#   the only place in the code where capital letters will be used in
#   variables names.  There are several variables with file-scope, and
#   these variables are clearly commented near the top of each of the
#   psad daemons.
#
# Sample packets:
#
#  Sample packet (rejected by ipchains)
#  Dec 19 11:54:07 orthanc kernel: Packet log: input REJECT lo PROTO=1
#  10.0.0.4:3127.0.0.1:3 L=88 S=0xC0 I=49513 F=0x0000 T=255
#
#  Sample tcp packet (rejected by iptables... --log-prefix = "DROP")
#  Mar 11 13:15:52 orthanc kernel: DROP IN=lo OUT= MAC=00:00:00:00:00:00:00:00:
#  00:00:00:00:08:00 SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00
#  TTL=64 ID=0 DF PROTO=TCP SPT=44847
#  DPT=35 WINDOW=32304 RES=0x00 SYN URGP=0
#
#  Sample icmp packet rejected by iptables
#  Nov 27 15:45:51 orthanc kernel: DROP IN=eth1 OUT= MAC=00:a0:cc:e2:1f:f2:00:
#  20:78:10:70:e7:08:00 SRC=192.168.10.20 DST=192.168.10.1 LEN=84 TOS=0x00
#  PREC=0x00 TTL=64 ID=0 DF PROTO=ICMP TYPE=8 CODE=0 ID=61055 SEQ=256
#
#  Occasionally the kernel klogd ring buffer must become full since log
#  entries are sometimes generated by a long port scan like this (note
#  there is no 'DPT' field):
#
#  Mar 16 23:50:25 orthanc kernel: DROP IN=lo OUT= MAC=00:00:00:00:00:00:00:
#  00:00:00:00:00:08:00 SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00
#  TTL=64 ID=0 DF PROTO=TCP SPT=39935 DINDOW=32304 RES=0x00 SYN URGP=0
#
###############################################################################
#
# $Id$
#

### modules used by psad
use lib '/usr/lib/psad';
use lib '/usr/lib/psad/i386-linux';  ### Syslog.pm is arch-dependent
use Psad;
use File::stat 'stat';
use File::Copy;
use File::Path;
use Getopt::Long 'GetOptions';
use Socket;
use Sys::Hostname 'hostname';
use Unix::Syslog qw(:subs :macros);
use POSIX;
use IO::Handle;
use Data::Dumper;
use strict;

### ========================== main =================================

### set current the psad version number
my $version = '1.0.0-pre4';

### establish some default paths
my $config_dir   = '/etc/psad';
my $config_file  = "${config_dir}/psad.conf";
my $sigs_file    = "${config_dir}/psad_signatures";
my $autoips_file = "${config_dir}/psad_auto_ips";

### disable debugging by default
my $debug = 0;

### we don't yet know which type of firewall we are
### running on; this will be calculated by check_scan()
### when the first dropped packet hits the firewall and
### we can examine the logging format.
my $use_ipchains = 0;
my $use_iptables = 0;

my $checked_iptables_flags = 0;
my $flush_fw_rules         = 0;

### Cache the default table->chain relationships used
### by the auto blocking code for iptables firewalls.
### The nat and mangle PREROUTING chains will be added
### by iptables_flags().
my %iptables_chains;

### define the input chains for ipchains firewalls (this
### is very simplistic).
my @ipchains_chains = qw(input);

### main psad data structure; contains ips, port ranges,
### protocol info, tcp flags, etc.
my %scan;

### %sigs holds all scan signatures (only initialized if
### "-s <sig file>" is specified on the command line).
my %sigs;

### %auto_ips holds all ip addresses that should automatically
### be assigned a danger level (or ignored).  (Only initialized
### if the "-a <auto ips file>" is specified on the command line).
my %auto_ips;

### cache the addresses we have executed whois lookups for
my %whois_cache;

### packet counters
my $tcp_ctr  = 0;
my $udp_ctr  = 0;
my $icmp_ctr = 0;

### initialize and scope some default variables (command
### line args can override some default values)
my $found_new_packets = 0;
my $output            = 0;
my $syslog_server     = 0;
my $kill              = 0;
my $restart           = 0;
my $status            = 0;
my $usr1              = 0;
my $print_version     = 0;
my $help              = 0;
my $check_interval    = 0;
my $netstat_lkup_cnt  = 0;

### these flags are used to disable several features
### in psad if specified from the command line
my $no_signatures = 0;
my $no_auto_ips   = 0;
my $no_daemon     = 0;
my $no_errors     = 0;
my $no_rdns       = 0;
my $no_whois      = 0;
my $no_netstat    = 0;
my $no_fwcheck    = 0;

### old command line options
my $errors;
my $dnslookups;
my $whoislookups;
my $netstat_lookup;
my $fwcheck;
my $daemon;

### get the hostname of the machine
my $hostname = hostname;

### save a copy of the command line arguments
my @args_cp = @ARGV;

### make Getopts case sensitive
Getopt::Long::Configure('no_ignore_case');

&usage(1) unless (GetOptions (
    'signatures=s'   => \$sigs_file,      # Path to psad signatures file.
    'auto_ips=s'     => \$autoips_file,   # Path to psad auto ips file for
                                          # auto-setting ip danger level.
    'output'         => \$output,         # Write scanlog messages to STDOUT.
    'debug'          => \$debug,          # Run in debug mode.
    'interval=s'     => \$check_interval, # Set $check_interval from the
                                          # command line.
    'config=s'       => \$config_file,    # Specify configuration file.
    'Logging_server' => \$syslog_server,  # We are running psad on a syslog
                                          # logging server.
    'Kill'           => \$kill,           # Kill all running psad processes.
                                          # (psadwatchd, psad, kmsgsd,
                                          # diskmond).
    'Restart'        => \$restart,        # Restart psad with all options of
                                          # the currently running psad process.
    'Flush'          => \$flush_fw_rules, # Flush any rules that psad added
                                          # via the auto blocking code.
    'Status'         => \$status,         # Display status of any currently
                                          # running psad processes.
    'USR1'           => \$usr1,           # Send an existing psad process a
                                          # USR1 signal (useful for debugging).
    'no_whois'       => \$no_whois,       # Do not issue whois lookups against
    'no_signatures'  => \$no_signatures,  # Disable signature processing.
    'no_auto_ips'    => \$no_auto_ips,    # Disable auto danger level
                                          # assignment.
    'no_daemon'      => \$no_daemon,      # Do not run as a daemon.
    'no_fw_check'    => \$no_fwcheck,     # Do not check firewall rules.
    'no_rdns'        => \$no_rdns,        # Do not issue dns lookups against
                                          # Scanning ip address.
    'no_localport'   => \$no_netstat,     # Do not check to see if the
                                          # firewall is listening on localport
                                          # that has been scanned.
    'no_errors'      => \$no_errors,      # Do not write malformed packet.
                                          # messages to error log.
    'Version'        => \$print_version,  # Print the psad version and exit.
    'Daemon'         => \$daemon,         #    old command line arg
    'firewallcheck'  => \$fwcheck,        #    old command line arg
    'reversedns'     => \$dnslookups,     #    old command line arg
    'localport'      => \$netstat_lookup, #    old command line arg
    'errors'         => \$errors,         #    old command line arg
    'whois'          => \$whoislookups,   #    old command line arg
    'help'           => \$help,           # Display help.
));
&usage(0) if ($help);

### Print the version number and exit if -V given on the command line.
if ($print_version) {
    print " ... psad version $version, by Michael B. Rash " .
        "(mbr\@cipherdyne.com)\n";
    exit 0;
}

### check for any old command line arguements
&check_old_cmdargs();

### Everthing after this point must be executed as root.
$< == 0 && $> == 0 or
    die "\n ... @@@  psad: You must be root (or equivalent " .
        "UID 0 account) to execute psad!  Exiting.\n\n";

### read in configuration file
my ($config_href, $cmds_href) = &Psad::buildconf($config_file);

### make sure the configuration is complete
&check_config();

my %config = %$config_href;
my %cmds   = %$cmds_href;

### release the memory in config_href and cmds_href
%$config_href = ();
%$cmds_href   = ();

### store the psad command line.
my $cmdline_file = $config{'PSAD_CMDLINE_FILE'};

### define the path to the auto_blocked_ips file
my $auto_blocked_file = "$config{'PSAD_DIR'}/auto_blocked_ips";

### pid file array
my @pidfiles = (
    $config{'PSADWATCHD_PID_FILE'},
    $config{'PSAD_PID_FILE'},
    $config{'KMSGSD_PID_FILE'},
    $config{'DISKMOND_PID_FILE'}
);

### The --Kill command line switch was given.
if ($kill) {
    &kill_psad();
    exit 0;
}

### The --Flush command line switch was given.
if ($flush_fw_rules) {
    if (-e $auto_blocked_file) {
        print " ... Removing auto-generated block rules.\n";
        &old_auto_blocked_ips();
        unlink $auto_blocked_file;
    } else {
        print " ... @@@ Currently there are no auto-generated block rules in effect.\n";
    }
    exit 0;
}

### The --USR1 command line switch was given.
if ($usr1) {
    exit &usr1();
}

### The -i <check interval> command line argument was given
if ($check_interval) {
    $config{'PSAD_CHECK_INTERVAL'} = $check_interval;
}

### check to make sure the commands specified in the config section
### are in the right place, and attempt to correct automatically if not.
&Psad::check_commands(\%cmds);

### Now that we are sure the psad command is where it should be,
### assign $PSADCMD (used by the SEGV handler)
my $PSADCMD = $cmds{'psad'};

### the --Status command line switch was given
&status_psad() if $status;

### make sure $PSAD_DIR, $FW_DATA, and /var/lib/psad/psadfifo, etc.
### actually exist
&setup_psad();

### the --Restart command line switch was given
if ($restart) {
    &restart_psad();
    exit 0;
}

### check to make sure another psad process is not already running.
&Psad::unique_pid($config{'PSAD_PID_FILE'});

### make sure the permissions on these files is 0600
&check_permissions(
    $config{'FW_DATA'},
    $config{'ERROR_LOG'},
);

### get the ip addresses that are local to this machine
my $local_ips_href = &get_local_ips();

### disable whois lookups if for some reason the whois client that is
### bundled with psad can't be found
unless ($no_whois) {
    unless (defined $cmds{'whois'}
            && -x $cmds{'whois'}) {  ### we couldn't find whois.psad
        warn " ... @@@ Could not locate whois.psad binary.  " .
            "Disabling whois lookups.\n";
        $no_whois = 1;
    }
}

### if psad is running on a syslog server, don't check the firewall
### rules since they may not be local.
unless ($no_fwcheck || $syslog_server) {
    &Psad::check_firewall_rules(
        $config{'FW_MSG_SEARCH'},
        $config{'EMAIL_ADDRESSES'},
        "$config{'PSAD_DIR'}/fw_check.txt",
        \%cmds
    );
}

### daemonize psad unless running with --no_daemon or --debug
unless ($no_daemon || $debug) {
    my $pid = fork();
    exit if $pid;
    die " ... @@@  $0: Couldn't fork: $!" unless defined($pid);
    POSIX::setsid() or die " ... @@@ $0: Can't start a new session: $!";
}

### write the current pid associated with psad to the psad pid file
&Psad::writepid($config{'PSAD_PID_FILE'});

### write the command line args used to start psad to $cmdline_file
&Psad::writecmdline(\@args_cp, $cmdline_file);

### psad _requires_ that kmsgsd is running to receive any data, so let's
### start it here for good measure (as of 0.9.2 it makes use of the pid
### files and unique_pid(), so we don't have to worry about starting a
### duplicate copy).  While we're at it, start psadwatchd and diskmond too
### Note that this is the best place to start the other daemons since we
### just wrote the psad pid to PSAD_PID_FILE above.
if ($config_file eq '/etc/psad/psad.conf') {
    system $cmds{'kmsgsd'};
    system $cmds{'diskmond'};
    system $cmds{'psadwatchd'} unless ($debug);
} else {  ### start the other daemons with the new (non-default) config file
    system "$cmds{'kmsgsd'} $config_file";
    system "$cmds{'diskmond'} $config_file";
    system "$cmds{'psadwatchd'} $config_file" unless ($debug);
}

### import the scan signatures and auto ips file
&import_signatures() if $sigs_file;
&import_auto_ips()   if $autoips_file;

### Check to see if psad automatically blocked some ips from
### a previous run.  This feature is most useful for preserving
### automatically blocked ips after a reboot.
if ($config{'ENABLE_AUTO_IDS'} eq 'Y') {
    &old_auto_blocked_ips();
}

### archive old firewall and scan data
&archive_data();

### Install signal handlers for debugging %scan with Data::Dumper,
### and for reaping zombie whois processes
$SIG{'__WARN__'} = \&Psad::warn_handler;
$SIG{'__DIE__'}  = \&Psad::die_handler;
$SIG{'CHLD'}     = \&REAPER;
$SIG{'USR1'}     = \&print_scan;

### Get the mtimes of the signatures and auto ips files.
my $sigs_mtime     = stat($sigs_file)->mtime;
my $auto_ips_mtime = stat($autoips_file)->mtime;
my $config_mtime   = stat($config_file)->mtime;

### zero out the packet counter file (the counters
### are all zero at this point).
&write_packet_counters();

### Get an open filehandle for the main firewall data file $FW_DATA.
### All firewall drop/deny/reject log messages are written to $FW_DATA
### by kmsgsd.
open FWDATA, $config{'FW_DATA'};

###=========================================================###
######                    MAIN LOOP                      ######
###=========================================================###
for (;;) {
    ### See if we need to import any changed config variables
    &check_import_config(\$config_mtime, $config_file);

    ### See if we need to import any new signatures
    &check_import(\$sigs_mtime, $sigs_file, 1);

    ### See if we need to re-import the psad_auto_ips file
    &check_import(\$auto_ips_mtime, $autoips_file, 0);

    ### Get any new packets have been written to
    ### $FW_DATA by kmsgsd for psad analysis.
    my @new_packets = <FWDATA>;
    if (@new_packets) {
        my $found_potential_scan = &check_scan(
            \@new_packets,
            $sigs_file,
        );
        if ($found_potential_scan) {

            ### Assign a danger level to the scan
            &assign_danger_level();

            ### Log and send an email/syslog alert
            &scan_logr();

            ### Don't manage the firewall rules if
            ### psad is running on a syslog server
            if ($config{'ENABLE_AUTO_IDS'} eq 'Y' && ! $syslog_server) {
                &auto_psad_response();
            }
        }
        ### write the number of tcp/udp/icmp packets out
        ### to the packet counters file
        &write_packet_counters();
    }
    ### Print how many new packets we got in $FW_DATA if we are
    ### running in $debug mode
    if ($debug) {
        print "MAIN: number of new packets: $#new_packets\n";
    }

    sleep $config{'PSAD_CHECK_INTERVAL'};
    ### clearerr() on the FWDATA filehandle to be ready for new packets
    FWDATA->clearerr();
}
exit 0;
###=========================================================###
######                    END MAIN                       ######
###=========================================================###

#=================== BEGIN SUBROUTINES ========================

### Keeps track of scanning ip's, increments packet counters,
### keep track of tcp flags for each scan (iptables only)
sub check_scan() {
    my ($process_lines_aref, $signatures) = @_;
    my @bad_packets;
    my $local_listening_ports_href;
    my $src;
    my $dst;
    my $len;
    my $ttl;
    my $proto;
    my $srcport;
    my $dstport;
    my $flags;
    my $type;
    my $code;
    my $id;
    my $seq;
    my $matched_packet = 0;

    ### If necessary, check which firewall (ipchains vs. iptables)
    unless ($use_ipchains || $use_iptables) {
        &check_fw($process_lines_aref->[0]);
    }
    unless ($no_netstat) {
        if ($netstat_lkup_cnt == 10) {
            ### we don't expect the list of ports the machine is listening
            ### on to change very often.
            $local_listening_ports_href = &get_listening_ports();
            $netstat_lkup_cnt = 0;
        } else {
            $netstat_lkup_cnt++;
        }
    }
    READPKT: for my $line (@$process_lines_aref) {
        chomp $line;
        if ($use_iptables) {
            ### Sometimes the log entry is messed up by iptables so
            ### we write it to the error log.
            if ($line =~ /SRC=(\S+)\s+DST=(\S+)\s+
                          LEN=(\d+).*TTL=(\d+).*PROTO=(\S+)\s+
                          SPT=(\d+)\s+DPT=(\d+)/x) {
                ($src, $dst, $len, $ttl, $proto, $srcport, $dstport) =
                    ($1,$2,$3,$4,$5,$6,$7,$8);
                if ($proto ne 'TCP' && $proto ne 'UDP') {
                    ### it was some weird non-tcp/udp packet
                    ### with source and destination ports
                    push @bad_packets, $line;
                    next READPKT;
                }
                if ($proto eq 'TCP') {
                    $tcp_ctr++;
                    if ($line =~ /RES=\S+\s+(.*)\s+URGP=/) {
                        $flags = $1;
                    } else {
                        $flags = 'NULL';
                    }
                    ### per page 595 of the Camel book, "if /blah1|blah2/"
                    ### can be slower than "if /blah1/ || /blah2/
                    unless (($flags =~ /SYN/ ||
                             $flags =~ /FIN/ ||
                             $flags =~ /URG/ ||
                             $flags =~ /PSH/ ||
                             $flags =~ /ACK/ ||
                             $flags =~ /RST/ ||
                             $flags =~ /NULL/) &&
                            ($flags !~ /WINDOW/)) {
                        push @bad_packets, $line;
                        next READPKT;
                    }
                } else {
                    ### it is UDP, but there are no more fields we need to
                    ### define since we already have the ports, etc.
                    $udp_ctr++;
                }
            } elsif ($line =~ /SRC=(\S+)\s+DST=(\S+)\s+LEN=(\d+).*
                               TTL=(\d+).*PROTO=ICMP\s+TYPE=(\d+)\s+
                               CODE=(\d+)\s+ID=(\d+)\s+SEQ=(\d+)/x) {
                ($src, $dst, $len, $ttl, $type, $code, $id, $seq) =
                    ($1,$2,$3,$4,$5,$6,$7,$8);
                $proto = 'ICMP';
                $icmp_ctr++;
            } else {
                push @bad_packets, $line;
                next READPKT;
            }
        } elsif ($use_ipchains) {
            ### could implement source port checking here
            if ($line =~ /PROTO\=(\d+)\s(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\:
                          (\d+)\s(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\:(\d+)/x) {
                ($proto, $src, $srcport, $dst, $dstport) = ($1,$2,$3,$4,$5);
                ### should implement protocol mapping
                ### with /etc/protocols here
                if ($proto == 1) {
                    $proto = 'ICMP';
                } elsif ($proto == 6) {
                    $proto = 'TCP';
                } elsif ($proto == 17) {
                    $proto = 'UDP';
                }
                $flags = 'NONE';
            } else {
                push @bad_packets, $line;
                next READPKT;
            }
        }
        if ($config{'ENABLE_PERSISTENCE'} eq 'Y') {
            my $currtime = time();
            if (defined $scan{$src}{$dst}{'S_TIME'}{'EPOCH_SECONDS'}) {
                my $tmp = $currtime -
                    $scan{$src}{$dst}{'S_TIME'}{'EPOCH_SECONDS'};
                if (($currtime - $scan{$src}{$dst}{'S_TIME'}{'EPOCH_SECONDS'})
                    >= $config{'SCAN_TIMEOUT'}) {
                    delete $scan{$src}{$dst};
                }
            }
        }
        $matched_packet = 1;
        ### hash initialization
        $scan{$src}{$dst}{'LOGR'} = 1;
        unless (defined $scan{$src}{$dst}{'CURR_DL'}) {
            $scan{$src}{$dst}{'CURR_DL'} = 0;
        }
        unless (defined $scan{$src}{$dst}{'S_PORT'} || $proto eq 'ICMP') {
            ### This is the absolute
            ### starting port since the
            ### first packet was detected.
            ### Make sure the initial start port is not too low
            $scan{$src}{$dst}{'S_PORT'} = 65535;
            ### make sure the initial end port is not too high
            $scan{$src}{$dst}{'E_PORT'} = 0;
        }
        my $epoch_seconds = time() if ($config{'ENABLE_PERSISTENCE'} eq 'N');
        ### get rid of the day and the year to make the time
        ### consistent with syslog
        my ($time) = ((scalar localtime()) =~ /^\S+\s+(.*)\s+\d+/);

        ### initialize values for the current interval
        unless (defined $scan{$src}{$dst}{$proto}{'CURR_INT'}) {
            $scan{$src}{$dst}{$proto}{'CURR_INT'}{'S_TIME'} = $time;
            $scan{$src}{$dst}{$proto}{'CURR_INT'}{'PKTS'} = 0;
            unless ($proto eq 'ICMP') {
                ### make sure the initial start port is not too low
                $scan{$src}{$dst}{$proto}{'CURR_INT'}{'S_PORT'} = 65535;
                ### make sure the initial end port is not too high
                $scan{$src}{$dst}{$proto}{'CURR_INT'}{'E_PORT'} = 0;
            }
            if ($proto eq 'TCP') {
                $scan{$src}{$dst}{$proto}{'CURR_INT'}{'FLAGS'}{$flags} = 0;
            }
        }
        unless (defined $scan{$src}{$dst}{'S_TIME'}{'READABLE'}) {
            $scan{$src}{$dst}{'S_TIME'}{'READABLE'} = $time;
            if ($config{'ENABLE_PERSISTENCE'} eq 'N') {
                $scan{$src}{$dst}{'S_TIME'}{'EPOCH_SECONDS'} = $epoch_seconds;
            }
        }
        $scan{$src}{$dst}{$proto}{'CURR_INT'}{'PKTS'}++;
        $scan{$src}{$dst}{'E_TIME'}{'READABLE'}= $time;
        if ($config{'ENABLE_PERSISTENCE'} eq 'N') {
            $scan{$src}{$dst}{'E_TIME'}{'EPOCH_SECONDS'} = $epoch_seconds;
        }
        ### increment hash values
        ### if $scan{$src}{$dst}{'ABSNUM'} is not yet defined, incrementing
        ### it here will make it equal to 1 anyway
        $scan{$src}{$dst}{'ABSNUM'}++;
        if ($proto eq 'TCP') {
            $scan{$src}{$dst}{'TCP'}{'CURR_INT'}{'FLAGS'}{$flags}++;
        }
        ### see if this port lies outside our current range
        unless ($proto eq 'ICMP') {
            ($scan{$src}{$dst}{'S_PORT'}, $scan{$src}{$dst}{'E_PORT'}) =
                &check_range($dstport,
                    $scan{$src}{$dst}{'S_PORT'},
                    $scan{$src}{$dst}{'E_PORT'}
                );
            ($scan{$src}{$dst}{$proto}{'CURR_INT'}{'S_PORT'},
                $scan{$src}{$dst}{$proto}{'CURR_INT'}{'E_PORT'}) =
                &check_range($dstport,
                    $scan{$src}{$dst}{$proto}{'CURR_INT'}->{'S_PORT'},
                    $scan{$src}{$dst}{$proto}{'CURR_INT'}{'E_PORT'}
                );
        } 
        if ($debug) {
            print STDOUT "check_scan():\n";
            print STDOUT Dumper $scan{$src}{$dst};
        }
        ### might try to use ipchains also, but then
        ### cannot use tcp flags except for -y -l rules
        if ($signatures && $use_iptables) {
            for my $msg (keys %{$sigs{$proto}}) {
                ### need to iterate through all signatures
                ### since a packet may match several
                my $dstport_criteria = 0;
                my $srcport_criteria = 0;
                my $rv = 0;
                if ($proto eq 'TCP') {
                    if (&check_port($msg, $srcport, $dstport, $proto)
                        && &check_misc_fields($msg, $proto, $len, $ttl)
                        && &check_tcp_flags($msg, $flags, $proto)) {
                        ### tripped a tcp signature
                        $scan{$src}{$dst}{'TCP'}{'SIGMATCH'}{'SIGDL'} =
                            $sigs{'TCP'}{$msg}{'DL'};
                        $rv = 1;
                    }
                } elsif ($proto eq 'UDP') {
                    if (&check_port($msg, $srcport, $dstport, $proto)
                        && &check_misc_fields($msg, $proto, $len, $ttl)) {
                        ### tripped a udp signature
                        $scan{$src}{$dst}{'UDP'}{'SIGMATCH'}{'SIGDL'} =
                            $sigs{'UDP'}{$msg}{'DL'};
                        $rv = 1;
                    }
                } elsif ($proto eq 'ICMP') {
                    if (&check_icmp_sigs($msg, $ttl, $type, $code, $id, $seq)) {
                        $scan{$src}{$dst}{'ICMP'}{'SIGMATCH'}{'SIGDL'} =
                            $sigs{'ICMP'}{$msg}{'DL'};
                        $rv = 1;
                    }
                }
                if ($rv) {   ### we matched some signature
                    if ($debug) {
                        unless ($proto eq 'ICMP') {
                            print "     SIGMATCH on dstport: $dstport\n";
                        } else {
                            print "     ICMP SIGMATCH\n";
                        }
                    }
                    my $listening_port = '';
                    unless ($no_netstat || $proto eq 'ICMP') {
                        my $lprot = lc $proto;

                        ### check to see if the scan destination ip is directed
                        ### at the firewall.  If yes, then check to see if a
                        ### server is listening on the DSTPORT by parsing
                        ### netstat output.  If not, psad would have to connect
                        ### to the destination port on the remote machine, but
                        ### it should not do this so it is not implemented.
                        if (defined $local_ips_href->{$dst}) {
                            if (defined
                                $local_listening_ports_href->{$lprot}->{$dstport}) {
                                $listening_port = "YOUR MACHINE IS LISTENING ON " .
                                    "($lprot) PORT: $dstport";
                            } else {
                                $listening_port = "There is no server listening " .
                                    "on $lprot port $dstport";
                            }
                        } ### else $listening_port is already ''
                    }
                    ### including sp almost always changes the hash key:
                    ### my $alert_string = "$msg  sp=$srcport, dp=$dstport,
                    ### flags=$flags.  $listening_port";
                    my $alert_string;
                    if ($proto eq 'TCP') {
                        $alert_string = "$msg  dp=$dstport, flags=$flags. " .
                            $listening_port;
                    } elsif ($proto eq 'UDP') {
                        $alert_string = "$msg  dp=$dstport. $listening_port";
                    } else {
                        $alert_string = $msg;
                    }
                    if (defined $scan{$src}{$dst}{$proto}{'SIGMATCH'}{$alert_string}) {
                        $scan{$src}{$dst}{$proto}{'SIGMATCH'}{$alert_string}++;
                    } else {
                        $scan{$src}{$dst}{$proto}{'SIGMATCH'}{$alert_string} = 1;
                    }
                    unless (defined $scan{$src}{$dst}{'CURR_SIG'}) {
                        $scan{$src}{$dst}{$proto}{'CURR_SIG'}{$alert_string} = 0;
                        $scan{$src}{$dst}{$proto}{'CURR_SIG'}{'PKTS'} = 0;
                    }
                    $scan{$src}{$dst}{$proto}{'CURR_SIG'}{$alert_string}++;
                    $scan{$src}{$dst}{$proto}{'CURR_SIG'}{'PKTS'}++;
                }
            }
        }
    }
    &collect_errors(\@bad_packets) unless $no_errors;
    return $matched_packet;
}

### check_tcp_flags will eventually need to include all possible
### permutations of the six tcp flags so that any signature can
### be written, but for now this should be most of the important
### ones.
sub check_tcp_flags() {
    my ($msg, $flags_to_check, $proto) = @_;
    return 0 if ($proto ne 'TCP');
    my $msgflags = $sigs{$proto}{$msg}{'FLAGS'};
    ### syn scan
    return 1 if ($msgflags eq 'S'    && $flags_to_check eq 'SYN');
    ### fin scan
    return 1 if ($msgflags eq 'F'    && $flags_to_check eq 'FIN');
    return 1 if ($msgflags eq 'SF'   && $flags_to_check eq 'SYN FIN');
    ### "syn/fin" scan
    return 1 if ($msgflags eq 'UPF'  && $flags_to_check eq 'URG PSH FIN');
    ### nmap Xmas scan
    return 1 if ($msgflags eq 'NULL' && $flags_to_check eq 'NULL');
    ### nmap NULL scan
    return 1 if ($msgflags eq 'UPSF' && $flags_to_check eq 'URG PSH SYN FIN');
    ### nmap fingerprint scan
    return 1 if ($msgflags eq 'AP'   && $flags_to_check eq 'ACK PSH');
    ### see the signatures for these
    return 1 if ($msgflags eq 'AS'   && $flags_to_check eq 'ACK SYN');
    return 0;
}

sub check_port() {
    my ( $msg, $srcport, $dstport, $proto) = @_;
    print "check_port(): msg: $msg, srcport: $srcport, dstport: " .
        "$dstport, proto: $proto\n" if $debug;
    ### check dst port first
    if (defined $sigs{$proto}{$msg}{'DSTPORT'}{'UNIQUE_OR_ANY'}) {
        unless ($sigs{$proto}{$msg}{'DSTPORT'}{'UNIQUE_OR_ANY'} eq 'any') {
            if ($dstport != $sigs{$proto}{$msg}{'DSTPORT'}{'UNIQUE_OR_ANY'}) {
                return 0;
            }
        }
    }
    if (defined $sigs{$proto}{$msg}{'DSTPORT'}{'START'}) {
        my $start = $sigs{$proto}{$msg}{'DSTPORT'}{'START'};
        my $end = $sigs{$proto}{$msg}{'DSTPORT'}{'END'};
        return 0 if ($dstport < $start || $dstport > $end);
    }
    if (defined $sigs{$proto}{$msg}{'DSTPORT'}{'NOT'}) {
        return 0 if ($dstport == $sigs{$proto}{$msg}{'DSTPORT'}{'NOT'});
    }
    if (defined $sigs{$proto}{$msg}{'DSTPORT'}{'NEGSTART'}) {
        my $start = $sigs{$proto}{$msg}{'DSTPORT'}{'NEGSTART'};
        my $end = $sigs{$proto}{$msg}{'DSTPORT'}{'NEGEND'};
        return 0 if ($dstport > $start || $dstport < $end);
    }
    ### check src port
    if (defined $sigs{$proto}{$msg}{'SRCPORT'}{'UNIQUE_OR_ANY'}) {
        unless ($sigs{$proto}{$msg}{'SRCPORT'}{'UNIQUE_OR_ANY'} eq 'any') {
            if ($dstport != $sigs{$proto}{$msg}{'SRCPORT'}{'UNIQUE_OR_ANY'}) {
                return 0;
            }
        }
    }
    if (defined $sigs{$proto}{$msg}{'SRCPORT'}{'START'}) {
        my $start = $sigs{$proto}{$msg}{'SRCPORT'}{'START'};
        my $end = $sigs{$proto}{$msg}{'SRCPORT'}{'END'};
        return 0 if ($dstport < $start || $dstport > $end);
    }
    if (defined $sigs{$proto}{$msg}{'SRCPORT'}{'NOT'}) {
        return 0 if ($dstport == $sigs{$proto}{$msg}{'SRCPORT'}{'NOT'});
    }
    if (defined $sigs{$proto}{$msg}{'SRCPORT'}{'NEGSTART'}) {
        my $start = $sigs{$proto}{$msg}{'SRCPORT'}{'NEGSTART'};
        my $end   = $sigs{$proto}{$msg}{'SRCPORT'}{'NEGEND'};
        return 0 if ($dstport > $start || $dstport < $end);
    }
    return 1;   ### if we made it to here, then we matched both
                ### the src and dst port criteria
}

sub check_icmp_sigs() {
    my ($msg, $ttl, $type, $code, $icmp_id, $icmp_seq) = @_;
    ### check icmp type first
    if (defined $sigs{'ICMP'}{$msg}{'TYPE'}) {
        return 0 if ($sigs{'ICMP'}{$msg}{'TYPE'} != $type);
    }
    if (defined $sigs{'ICMP'}{$msg}{'TTL'}) {
        return 0 if ($sigs{'ICMP'}{$msg}{'TTL'} != $ttl);
    }
    if (defined $sigs{'ICMP'}{$msg}{'CODE'}) {
        return 0 if ($sigs{'ICMP'}{$msg}{'CODE'} != $code);
    }
    if (defined $sigs{'ICMP'}{$msg}{'ID'}) {
        return 0 if ($sigs{'ICMP'}{$msg}{'ICMP_ID'} != $icmp_id);
    }
    if (defined $sigs{'ICMP'}{$msg}{'SEQ'}) {
        return 0 if ($sigs{'ICMP'}{$msg}{'ICMP_SEQ'} != $icmp_seq);
    }
    return 1; ### if we got to this point, then we matched the signature
}

sub check_misc_fields() {
    my ($msg, $proto, $len, $ttl) = @_;
    if (defined $sigs{$proto}{$msg}{'LEN'}) {
        return 0 if ($sigs{$proto}{$msg}{'LEN'} != $len);
    }
    if (defined $sigs{$proto}{$msg}{'TTL'}) {
        return 0 if ($sigs{$proto}{$msg}{'TTL'} != $ttl);
    }
    return 1;
}

sub check_import() {
    my ($mtime_ref, $file, $sigs) = @_;
    my $mtime_tmp = stat($file)->mtime;
    if ($mtime_tmp != $$mtime_ref) {  ### the file was modified, so import
        if ($sigs) {  ### import signatures
            &import_signatures($file);
        } else {
            &import_auto_ips($file);
        }
        my $subject = "psad: re-read $file on $hostname";
        &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
        $$mtime_ref = $mtime_tmp;
    }
    return;
}

sub check_import_config() {
    my ($mtime_ref, $file) = @_;
    my $mtime_tmp = stat($file)->mtime;
    if ($mtime_tmp != $$mtime_ref) {  ### the file was modified, so import

        ($config_href, $cmds_href) = &Psad::buildconf($file);

        ### make sure the configuration is complete
        &check_config();

        %config = %$config_href;
        %cmds   = %$cmds_href;
        my $subject = "psad: re-read $file on $hostname";
        &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
        $$mtime_ref = $mtime_tmp;

        ### kill kmsgsd since it does not have the capability of
        ### checking for a modified config file
        open K, "< $config{'KMSGSD_PID_FILE'}" or warn
            " @@@ Could not open $config{'KMSGSD_PID_FILE'}";
        my $pid = <K>;
        close K;
        if (kill 0, $pid) {
            kill 15, $pid;
            ### NOTE: we are not restarting kmsgsd here since we
            ###       don't want to create a race condition between
            ###       psad and psadwatchd both starting kmsgsd
        }
    }
    return;
}

sub import_signatures() {
    %sigs = ();  ### undef %sigs so don't leave old signatures around
    open SIGS, "< $sigs_file" or die
            " ... @@@ Could not open the signatures file $sigs_file: $!";
    my @sigs = <SIGS>;
    close SIGS;
    for my $sig (@sigs) {
        chomp $sig;
        next if ($sig =~ /^\s*#/);
        &get_signature_fields($sig);
    }
    print STDOUT Dumper %sigs if $debug;
    return;
}

sub get_signature_fields() {
    my $sig = shift;
    my ($proto, $msg);
    if ($sig =~ /^tcp/) {
        $proto = 'TCP';
    } elsif ($sig =~ /^udp/) {
        $proto = 'UDP';
    } elsif ($sig =~ /^icmp/) {
        $proto = 'ICMP';
    } else {
        return;
    }
    my @fields = split /\;/, $sig;
    for my $f (@fields) {  ### get the msg first
        if ($f =~ /msg\:\s*?(\".*?\")/) {
            $msg = $1;
        }
    }
    if ($msg) {
        if (defined $sigs{$proto}{$msg}) {
            $msg .= ' ';   ### make sure we have a unique signature
                           ### by appending whitespace if necessary
        }
        if ($proto ne 'ICMP') {   ### it is either tcp or udp
            &get_signature_ports($sig, $proto, $msg);
        }
        for my $f (@fields) {
            if ($f =~ /flags\:\s*?(\w+)/i) {
                $sigs{$proto}{$msg}{'FLAGS'} = $1;
            } elsif ($f =~ /ttl\:\s*(\d+)/i) {
                $sigs{$proto}{$msg}{'TTL'} = $1;
            } elsif ($f =~ /itype\:\s*?(\d+)/i) {
                $sigs{$proto}{$msg}{'TYPE'} = $1;
            } elsif ($f =~ /icode\:\s*?(\d+)/i) {
                $sigs{$proto}{$msg}{'CODE'} = $1;
            } elsif ($f =~ /icmp_seq\:\s*?(\d+)/i) {
                $sigs{$proto}{$msg}{'ICMP_SEQ'} = $1;
            } elsif ($f =~ /icmp_id\:\s*?(\d+)/i) {
                $sigs{$proto}{$msg}{'ICMP_ID'} = $1;
            } elsif ($f =~ /dlevel\:\s*?(\d{1})/i) {
                $sigs{$proto}{$msg}{'DL'} = $1;
            }
        }
    }
    return;
}

sub get_signature_ports() {
    my ($sig, $proto, $msg) = @_;
    my ($srcport, $dstport);
    my ($start, $end, $tmpport);
    if ($sig =~ /^\w{3,4}\s+(\S+)\s+\-\>\s+(\S+)\s/) {
        ($srcport, $dstport) = ($1, $2);
    } else {
        return;
    }
    if ($srcport =~ /\:/ && $srcport !~ /\!/) {
        ($start, $end) = split /:/, $srcport;
        $start = 1   if ($start eq '');
        $end = 65535 if ($end   eq '');
        $sigs{$proto}{$msg}{'SRCPORT'}{'START'} = $start;
        $sigs{$proto}{$msg}{'SRCPORT'}{'END'}   = $end;
    } elsif ($srcport =~ /\!/ && $srcport !~ /\:/) {
        $tmpport = (split /\!/, $srcport)[1];
        $sigs{$proto}{$msg}{'SRCPORT'}{'NOT'} = $tmpport;
    } elsif ($srcport =~ /\:/ && $srcport =~ /\!/) {
        ($start, $end) = split /:/, $srcport;
        $start = 1   if ($start !~ /\d/);
        $end = 65535 if ($end   !~ /\d/);
        $sigs{$proto}{$msg}{'SRCPORT'}{'NEGSTART'} = $start;
        $sigs{$proto}{$msg}{'SRCPORT'}{'NEGEND'}   = $end;
    } else {
        $sigs{$proto}{$msg}{'SRCPORT'}{'UNIQUE_OR_ANY'} = $srcport;
    }
    if ($dstport =~ /\:/ && $dstport !~ /\!/) {
        ($start, $end) = split /:/, $dstport;
        $start = 1   if ($start eq '');
        $end = 65535 if ($end   eq '');
        $sigs{$proto}{$msg}{'DSTPORT'}{'START'} = $start;
        $sigs{$proto}{$msg}{'DSTPORT'}{'END'}   = $end;
    } elsif ($dstport =~ /\!/ && $dstport !~ /\:/) {
        $tmpport = (split /\!/, $dstport)[1];
        $sigs{$proto}{$msg}{'DSTPORT'}{'NOT'} = $tmpport;
    } elsif ($dstport =~ /\:/ && $dstport =~ /\!/) {
        ($start, $end) = split /:/, $dstport;
        $start = 1   if ($start !~ /\d/);
        $end = 65535 if ($end   !~ /\d/);
        $sigs{$proto}{$msg}{'DSTPORT'}{'NEGSTART'} = $start;
        $sigs{$proto}{$msg}{'DSTPORT'}{'NEGEND'}   = $end;
    } else {
        $sigs{$proto}{$msg}{'DSTPORT'}{'UNIQUE_OR_ANY'} = $dstport;
    }
    return;
}

sub import_auto_ips() {
    %auto_ips = ();  ### undef so we don't leave old ips in %auto_ips
    open A, "< $autoips_file";
    my @lines = <A>;
    close A;
    my $i = 1;
    for my $line (@lines) {
        $i++;
        next if ($line =~ /^\s*#/);
        next unless ($line =~ /\S/);
        if ($line =~ /^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+([0-5])/) {
            $auto_ips{$1} = $2;
        } else {
            my $subject = "psad import warning: $autoips_file " .
                "error on line: $i";
            &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'},
                $cmds{'mail'});
        }
    }
    return;
}

sub check_range() {
    my ($port, $start, $end) = @_;
    $start = $port if ($port < $start);
    $end   = $port if ($port > $end);
    return $start, $end;
}

sub assign_danger_level() {
    for my $src (keys %scan) {
        print "assign_danger_level(): source ip: $src\n" if $debug;
        if (%auto_ips) {
            if (defined $auto_ips{$src}) {
                for my $dst (keys %{$scan{$src}}) {
                    $scan{$src}{$dst}{'CURR_DL'} = $auto_ips{$src};
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                }
                ### ignore $src if the auto danger level is zero
                return if $auto_ips{$src} == 0;
            }
        }
        DST: for my $dst (keys %{$scan{$src}}) {
            my $absnum = $scan{$src}{$dst}{'ABSNUM'};
            my $range;
            if (defined $scan{$src}{$dst}{'S_PORT'}) {
                $range = $scan{$src}{$dst}{'E_PORT'} - $scan{$src}{$dst}{'S_PORT'};
            } else {
                $range = $absnum;
            }
            if ($debug) {
                print "assign_danger_level(): destination ip: $dst\n";
                print "assign_danger_level(): ABSNUM: $scan{$src}{$dst}{'ABSNUM'}\n";
                if (defined $scan{$src}{$dst}{'S_PORT'}) {
                    print "assign_danger_level(): S_PORT: $scan{$src}{$dst}{'S_PORT'}, " .
                        "E_PORT: $scan{$src}{$dst}{'E_PORT'}\n";
                }
                print 'assign_danger_level(): CURR_DL (before assignment) = ' .
                    "$scan{$src}{$dst}{'CURR_DL'}\n";
            }
            ### If a scan signature packet has been detected but no other
            ### packets are detected, assign a danger level of SIGDL.
            my $sigmatch = 0;
            my $sigproto = '';
            if (defined $scan{$src}{$dst}{'TCP'}{'SIGMATCH'}) {
                $sigmatch = 1;
                $sigproto = 'TCP';
                print "assign_danger_level(): sigmatch = $sigmatch\n" if $debug;
            }
            if (defined $scan{$src}{$dst}{'UDP'}{'SIGMATCH'}) {
                $sigmatch = 1;
                $sigproto = 'UDP';
                print "assign_danger_level(): sigmatch = $sigmatch\n" if $debug;
            }
            if (defined $scan{$src}{$dst}{'ICMP'}{'SIGMATCH'}) {
                $sigmatch = 1;
                $sigproto = 'ICMP';
                print "assign_danger_level(): sigmatch = $sigmatch\n" if $debug;
            }
            if ($sigmatch && $scan{$src}{$dst}{'CURR_DL'} <
                    $scan{$src}{$dst}{$sigproto}{'SIGMATCH'}{'SIGDL'}) {
                $scan{$src}{$dst}{'CURR_DL'} =
                    $scan{$src}{$dst}{$sigproto}{'SIGMATCH'}{'SIGDL'};
                $scan{$src}{$dst}{'ALERTED'} = 0;
                print "assign_danger_level(): danger level: " .
                    "$scan{$src}{$dst}{'CURR_DL'}\n" if $debug;
            }
            ### if $PORT_RANGE_SCAN_THRESHOLD is >= 1, then psad will not assign
            ### a danger level to repeated packets to the same port
            if ($absnum < $config{'DANGER_LEVEL1'}) {
                ### don't have enough packets to even reach danger level 1 yet.
                next DST;
            } elsif ($absnum < $config{'DANGER_LEVEL2'}
                        && $range >= $config{'PORT_RANGE_SCAN_THRESHOLD'}) {
                if ($scan{$src}{$dst}{'CURR_DL'} < 1
                        && $scan{$src}{$dst}{'CURR_DL'} != -1) {
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                    $scan{$src}{$dst}{'CURR_DL'} = 1;
                }
            } elsif ($absnum < $config{'DANGER_LEVEL3'}
                        && $range >= $config{'PORT_RANGE_SCAN_THRESHOLD'}) {
                if ($scan{$src}{$dst}{'CURR_DL'} < 2
                        && $scan{$src}{$dst}{'CURR_DL'} != -1) {
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                    $scan{$src}{$dst}{'CURR_DL'} = 2;
                }
            } elsif ($absnum < $config{'DANGER_LEVEL4'}
                        && $range >= $config{'PORT_RANGE_SCAN_THRESHOLD'}) {
                if ($scan{$src}{$dst}{'CURR_DL'} < 3
                        && $scan{$src}{$dst}{'CURR_DL'} != -1) {
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                    $scan{$src}{$dst}{'CURR_DL'} = 3;
                }
            } elsif ($absnum < $config{'DANGER_LEVEL5'}
                        && $range >= $config{'PORT_RANGE_SCAN_THRESHOLD'}) {
                if ($scan{$src}{$dst}{'CURR_DL'} < 4
                        && $scan{$src}{$dst}{'CURR_DL'} != -1) {
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                    $scan{$src}{$dst}{'CURR_DL'} = 4;
                }
            } elsif ($range >= $config{'PORT_RANGE_SCAN_THRESHOLD'}) {
                if ($scan{$src}{$dst}{'CURR_DL'} < 5
                        && $scan{$src}{$dst}{'CURR_DL'} != -1) {
                    $scan{$src}{$dst}{'ALERTED'} = 0;
                    $scan{$src}{$dst}{'CURR_DL'} = 5;
                }
            }
            ### we will always send an alert email for any new "bad" packet
            ### if $ALERT_ALL eq "Y"... Else email sent only if the scan
            ### increments its D.L.
            if ($config{'ALERT_ALL'} eq 'Y') {
                $scan{$src}{$dst}{'ALERTED'} = 0;
            }
            print 'assign_danger_level(): CURR_DL (after assignment) = ' .
                "$scan{$src}{$dst}{'CURR_DL'}\n" if $debug;
        }
    }
    return;
}

sub write_packet_counters() {
    open P, "> $config{'PACKET_COUNTER_FILE'}" or
        die " ... @@@ Could not open $config{'PACKET_COUNTER_FILE'}: $!";
    print P "tcp:  $tcp_ctr\n";
    print P "udp:  $udp_ctr\n";
    print P "icmp: $icmp_ctr\n";
    close P;
    return;
}

sub collect_errors() {
    my ($bad_packets_aref) = @_;
    open ERR, ">> $config{'ERROR_LOG'}";
    for my $line (@$bad_packets_aref) {
        print ERR "$line\n";
    }
    close ERR;
}

sub scan_logr() {
    my $range;
    my $tcp_newrange;
    my $udp_newrange;
    my $dnsstring = '';
    my $whois_info_aref;
    for my $src (keys %scan) {
        print STDOUT "scan_logr(): source ip: $src\n" if $debug;
        DST: for my $dst (keys %{$scan{$src}}) {
            unless (defined $scan{$src}{$dst}{'EMAIL_COUNT'}) {
                $scan{$src}{$dst}{'EMAIL_COUNT'} = 0;
            } elsif ($config{'PSAD_EMAIL_LIMIT'} > 0
                && $scan{$src}{$dst}{'EMAIL_COUNT'}
                > $config{'PSAD_EMAIL_LIMIT'}) {
                ### ignore PSAD_EMAIL_LIMIT if it is zero
                unless (defined $scan{$src}{$dst}{'EMAIL_STOPPED'}) {
                    &email_limit_reached($src, $dst);
                    $scan{$src}{$dst}{'EMAIL_STOPPED'} = 1;
                }
                next DST;
            }
            print STDOUT "scan_logr(): dst ip: $dst\n" if $debug;
            my $tcp  = 0;
            my $udp  = 0;
            my $icmp = 0;
            my $current_danger_level =
                $scan{$src}{$dst}{'CURR_DL'};
            if ($current_danger_level >= 1 && $scan{$src}{$dst}{'LOGR'} == 1) {
                ### make $src directory here in /var/log/psad
                ### unless it already exists
                mkdir "$config{'PSAD_DIR'}/${src}", 0500 unless
                    -d "$config{'PSAD_DIR'}/${src}";
                my $scanlog     = "$config{'PSAD_DIR'}/${src}/scanlog";
                my $email_alert = "$config{'PSAD_DIR'}/${src}/email_alert";
                my $ecount_file = "$config{'PSAD_DIR'}/${src}/email_count";
                my $whois_file  = "$config{'PSAD_DIR'}/${src}/whois";
                my $dl_file     = "$config{'PSAD_DIR'}/${src}/danger_level";
                my $sigs_file   = "$config{'PSAD_DIR'}/${src}/signatures";

                ### unlink $email_alert here since we print to this
                ### file multiple times
                unlink $email_alert;

                ### print the current danger level to the danger_level file
                &Psad::logr("$current_danger_level\n", {$dl_file => 0});

                ### log everything to stdout if $output of $debug is set
                $scanlog = *STDOUT if ($output || $debug);

                ### file => append?   e.g.  filename => 0  means don't append
                my %print_hsh = ($scanlog => 1, $email_alert => 1);

                ### scope these vars
                my $abs_start_range;
                my $abs_end_range;
                my $tcp_new_start_range;
                my $tcp_new_end_range;
                my $tcp_new_start_time;
                my $tcp_new_num_pkts;
                my $udp_new_start_range;
                my $udp_new_end_range;
                my $udp_new_start_time;
                my $udp_new_num_pkts;
                my $icmp_new_start_time;
                my $icmp_new_num_pkts;
                my $rdns = '';
                if (defined $scan{$src}{$dst}{'TCP'}{'CURR_INT'}) {
                    $tcp = 1;
                    $tcp_new_start_range = $scan{$src}{$dst}{'TCP'}{'CURR_INT'}{'S_PORT'};
                    $tcp_new_end_range   = $scan{$src}{$dst}{'TCP'}{'CURR_INT'}{'E_PORT'};
                    $tcp_new_start_time  = $scan{$src}{$dst}{'TCP'}{'CURR_INT'}{'S_TIME'};
                    $tcp_new_num_pkts    = $scan{$src}{$dst}{'TCP'}{'CURR_INT'}{'PKTS'};
                }
                if (defined $scan{$src}{$dst}{'UDP'}{'CURR_INT'}) {
                    $udp = 1;
                    $udp_new_start_range = $scan{$src}{$dst}{'UDP'}{'CURR_INT'}{'S_PORT'};
                    $udp_new_end_range   = $scan{$src}{$dst}{'UDP'}{'CURR_INT'}{'E_PORT'};
                    $udp_new_start_time  = $scan{$src}{$dst}{'UDP'}{'CURR_INT'}{'S_TIME'};
                    $udp_new_num_pkts    = $scan{$src}{$dst}{'UDP'}{'CURR_INT'}{'PKTS'};
                }
                if (defined $scan{$src}{$dst}{'ICMP'}{'CURR_INT'}) {
                    $icmp = 1;
                    $icmp_new_start_time = $scan{$src}{$dst}{'ICMP'}{'CURR_INT'}{'S_TIME'};
                    $icmp_new_num_pkts   = $scan{$src}{$dst}{'ICMP'}{'CURR_INT'}{'PKTS'};
                }
                my $start_time = $scan{$src}{$dst}{'S_TIME'}{'READABLE'};
                my $end_time   = $scan{$src}{$dst}{'E_TIME'}{'READABLE'};

                ### get rid of the day and the year to make the time
                ### consistent with syslog
                my ($time) = ((scalar localtime()) =~ /^\S+\s+(.*)\s+\d+/);
                unless ($no_rdns) {
                    if ($src =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/) {
                        my $ipaddr = gethostbyname($src);
                        ### my $rdns = gethostbyaddr($ipaddr, AF_INET);
                        $rdns = gethostbyaddr($ipaddr, 2);
                        if ($rdns) {
                            $dnsstring = "$src -> $rdns";
                        } else {
                            $dnsstring = "$src -> No reverse dns info available";
                        }
                    } else {
                        ### $ipaddr was already reported as
                        ### a host name by iptables
                        $dnsstring = $src;
                    }
                }
                unless ($no_whois) {
                    $whois_info_aref = &get_whois_data($src, $whois_file);
                }
                if ($tcp || $udp) {
                    $abs_start_range = $scan{$src}{$dst}{'S_PORT'};
                    $abs_end_range   = $scan{$src}{$dst}{'E_PORT'};
                    if ($abs_start_range == $abs_end_range) {
                        $range = $abs_start_range;
                    } else {
                        $range = "$abs_start_range-$abs_end_range";
                    }
                }
                my @tcp_flags;
                my $syslog_print_flags = '';
                if ($tcp) {
                    if ($tcp_new_start_range == $tcp_new_end_range) {
                        $tcp_newrange = $tcp_new_start_range;
                    } else {
                        $tcp_newrange = "$tcp_new_start_range-$tcp_new_end_range";
                    }
                    $syslog_print_flags = 'flags=[';
                    for my $flags (keys %{$scan{$src}{$dst}{'TCP'}{'CURR_INT'}{'FLAGS'}}) {
                        my $nmapOpts = '';
                        $nmapOpts = '  Nmap: [-sT or -sS]' if ($flags eq 'SYN');
                        $nmapOpts = '  Nmap: [-sF]' if ($flags eq 'FIN');
                        $nmapOpts = '  Nmap: [-sX]' if ($flags eq 'URG PSH FIN');
                        $nmapOpts = '  Nmap: [-O]'  if ($flags eq 'URG PSH SYN FIN');
                        my $num_pkts
                            = $scan{$src}{$dst}{'TCP'}{'CURR_INT'}{'FLAGS'}{$flags};
                        push @tcp_flags, "TCP flags:                   [$flags: " .
                                         "$num_pkts packets]${nmapOpts}\n";
                        $syslog_print_flags .= "$flags ";
                    }
                    $syslog_print_flags =~ s/\s$//;
                    $syslog_print_flags .= ']';
                    ### need to delete the current interval so
                    ### it won't show up in the next alert
                    delete $scan{$src}{$dst}{'TCP'}{'CURR_INT'};
                }
                if ($udp) {
                    if ($udp_new_start_range == $udp_new_end_range) {
                        $udp_newrange = $udp_new_start_range;
                    } else {
                        $udp_newrange = "$udp_new_start_range-$udp_new_end_range";
                    }
                    ### need to delete the current interval so
                    ### it won't show up in the next alert
                    delete $scan{$src}{$dst}{'UDP'}{'CURR_INT'};
                }
                if ($icmp) {
                    delete $scan{$src}{$dst}{'ICMP'}{'CURR_INT'};
                }
                print STDOUT "scan_logr():  generating email......\n" if $debug;

                &Psad::logr("=-=-=-=-=-=-=-=-=-=-=-=-=-= $time =-=-=-=-=-=-=-" .
                    "=-=-=-=-=-=-=\n", \%print_hsh);
                &Psad::logr("psad: portscan detected against $hostname ($dst).\n",
                    \%print_hsh);
                &Psad::logr("\n", \%print_hsh);
                &Psad::logr("Source:                      $src\n", \%print_hsh);
                &Psad::logr("Destination:                 $dst\n", \%print_hsh);
                if ($tcp) {
                    &Psad::logr("Newly scanned TCP ports:     " . sprintf("%-13s",
                        "[$tcp_newrange]") . "(since: $tcp_new_start_time)\n",
                        \%print_hsh);
                    &Psad::logr("Newly Blocked TCP packets:   " . sprintf("%-13s",
                        "[$tcp_new_num_pkts]") . "(since: $tcp_new_start_time)\n",
                        \%print_hsh);
                }
                if (@tcp_flags) {
                    for my $flag (@tcp_flags) {
                        &Psad::logr($flag, \%print_hsh);
                    }
                }
                if ($udp) {
                    &Psad::logr("Newly scanned UDP ports:     " . sprintf("%-13s",
                        "[$udp_newrange]") .  "(since: $udp_new_start_time)\n",
                        \%print_hsh);
                    &Psad::logr("Newly Blocked UDP packets:   " . sprintf("%-13s",
                        "[$udp_new_num_pkts]") . "(since: $udp_new_start_time)\n",
                        \%print_hsh);
                }
                if ($icmp) {
                    &Psad::logr("Newly Blocked ICMP packets:  " . sprintf("%-13s",
                        "[$icmp_new_num_pkts]") . "(since: $icmp_new_start_time)\n",
                        \%print_hsh);
                }
                unless ($icmp) {
                    &Psad::logr("Complete TCP/UDP port range: " . sprintf("%-13s",
                        "[$range]") .  "(since: $start_time)\n", \%print_hsh);
                }
                &Psad::logr("Total blocked packets:       " .
                    "$scan{$src}{$dst}{'ABSNUM'}\n", \%print_hsh);
                &Psad::logr("Start time:                  " .
                    "$start_time\n", \%print_hsh);
                &Psad::logr("End time:                    " .
                    "$end_time\n", \%print_hsh);
                &Psad::logr("Danger level:                " .
                    "$scan{$src}{$dst}{'CURR_DL'} out of 5\n", \%print_hsh);
                &Psad::logr("DNS info:                    " .
                    "$dnsstring\n", \%print_hsh) unless $no_rdns;

#                my $syslog_print_sig_title = '';
                if ($use_iptables) {
                    SIGS: for my $proto ('TCP', 'UDP', 'ICMP') {
                        if (defined $scan{$src}{$dst}{$proto}{'CURR_SIG'}) {
                            my $sig_start_time = $tcp_new_start_time;
                            &Psad::logr("\n", \%print_hsh);
                            &Psad::logr("---- $proto alert signatures found since " .
                                "[$sig_start_time]\n", \%print_hsh);
                            for my $sigmatch (keys %{$scan{$src}{$dst}{$proto}{'CURR_SIG'}}) {
                                next if ($sigmatch eq 'PKTS' || $sigmatch eq 'S_TIME');
                                my $sig_num_packets =
                                    $scan{$src}{$dst}{$proto}{'CURR_SIG'}{$sigmatch};
                                &Psad::logr("$sigmatch  Packets=$sig_num_packets\n",
                                    \%print_hsh);
                                ### signature logging with syslog is not yet supported
                                ### (requires a message for each matched signature).
#                                if ($sigmatch =~ /^(\".*\")/) {
#                                    $syslog_print_sig_title = "signature=$1";
#                                }
                            }
                            ### need to delete the current signature so it
                            ### won't show up in the next alert
                            delete $scan{$src}{$dst}{$proto}{'CURR_SIG'};
                        }
                        if (defined $scan{$src}{$dst}{$proto}{'SIGMATCH'}) {
                            if ($config{'SHOW_ALL_SIGNATURES'} eq 'Y') {
                                &Psad::logr("\n", \%print_hsh);
                                &Psad::logr("---- ALL $proto alert signatures " .
                                    "found since [$start_time]\n", \%print_hsh);
                            }
                            ### truncate the sigs file
                            &Psad::logr('', {$sigs_file => 0});
                            for my $sigmatch (keys %{$scan{$src}{$dst}{$proto}{'SIGMATCH'}}) {
                                next if $sigmatch eq 'SIGDL';
                                my $sig_num_packets =
                                    $scan{$src}{$dst}{$proto}{'SIGMATCH'}->{$sigmatch};
                                if ($config{'SHOW_ALL_SIGNATURES'} eq 'Y') {
                                    &Psad::logr("$sigmatch  Packets=$sig_num_packets\n",
                                        \%print_hsh);
                                }
                                ### print all of the signatures to $sigs_file
                                &Psad::logr("$sigmatch  Packets=$sig_num_packets\n",
                                    {$sigs_file => 1});
                            }
                        }
                    }
                }
                my $syslog_print_range = '';
                if ($tcp) {
                    $syslog_print_range .= "tcp=[$tcp_newrange] $syslog_print_flags";
                }
                if ($udp) {
                    $syslog_print_range .= "udp=[$udp_newrange] ";
                }
                my $syslog_num_pkts     = $scan{$src}{$dst}{'ABSNUM'};
                my $syslog_danger_level = $scan{$src}{$dst}{'CURR_DL'};

                ### write a message to syslog
                openlog 'psad', LOG_DAEMON, LOG_LOCAL7;
                syslog LOG_INFO, "scan detected: $src -> $dst $syslog_print_range " .
                    "pkts=$syslog_num_pkts dangerlevel: $syslog_danger_level";
                closelog();
                unless ($no_whois) {
                    &Psad::logr("\n\n", \%print_hsh);
                    &Psad::logr("---- Whois Information: ----\n", \%print_hsh);
                    for my $w (@$whois_info_aref) {
                        &Psad::logr($w, \%print_hsh);
                    }
                    &Psad::logr("\n", \%print_hsh);
                }
                &Psad::logr("=-=-=-=-=-=-=-=-=-=-=-=-=-= $time =-=-=-=-=-=-=-=-" .
                            "=-=-=-=-=-=\n", \%print_hsh);
                if ($scan{$src}{$dst}{'ALERTED'} == 0
                    && $current_danger_level >= $config{'EMAIL_ALERT_DANGER_LEVEL'}) {
                    my $subject;
                    if ($rdns) {
                        $subject = "psad: SCAN DETECTED from: $rdns";
                    } else {
                        $subject = "psad: SCAN DETECTED from: $src";
                    }
                    &Psad::sendmail($subject, $email_alert, $config{'EMAIL_ADDRESSES'},
                        $cmds{'mail'});
                    $scan{$src}{$dst}{'ALERTED'} = 1;
                    $scan{$src}{$dst}{'EMAIL_COUNT'}++;

                    ### print the number of email alerts we have sent
                    &Psad::logr("$scan{$src}{$dst}{'EMAIL_COUNT'}\n",
                        {$ecount_file => 0});
                }
                $scan{$src}{$dst}{'LOGR'} = 0;
            }
        }
    }
    return;
}

sub old_auto_blocked_ips() {
    if (-e $auto_blocked_file) {
        open B, "< $auto_blocked_file" or
            warn " ... @@@ Could not open $auto_blocked_file\n" and return;
        my @blines = <B>;
        close B;
        my $use_ipchains;
        my $use_iptables;
        my @block_ips;
        for my $line (@blines) {
            chomp $line;
            if ($line =~ /IPTABLES/) {
                $use_iptables = 1;
            } elsif ($line =~ /IPCHAINS/) {
                $use_ipchains = 1;
            }
            if ($line =~ /^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/) {
                push @block_ips, $1;
            }
        }
        if ($use_iptables) {
            &iptables_flags unless $checked_iptables_flags;
            for my $blockip (@block_ips) {
                if ($flush_fw_rules) {
                    print " ... Removing rules for: $blockip\n";
                }
                for my $table (keys %iptables_chains) {
                    for my $chain (keys %{$iptables_chains{$table}}) {
                        ### The rule numbers can change for each ip
                        my @rules = `$cmds{'iptables'} -t $table -nL $chain`;
                        my $blocked = 0;
                        my $rulenum = 1;
                        RULE: for my $rule (@rules) {
                            next RULE if ($rule =~ /^Chain\s/);
                            next RULE if ($rule =~ /^target\s/);
                            chomp $rule;
                            ### DROP       all  --  1.1.1.1        0.0.0.0/0
                            if ($rule =~ /^DROP\s+all.*?$blockip\s+0\.0\.0\.0\/0/) {
                                ### all traffic from $blockip is being blocked
                                $blocked = 1;
                                if ($flush_fw_rules) {
                                    print "     Deleting rule $table $chain: $rule\n";
                                    system "$cmds{'iptables'} -t $table -D $chain $rulenum";
                                } else {
                                    last RULE;
                                }
                            }
                            $rulenum++;
                        }
                        unless ($blocked || $flush_fw_rules) {
                            &iptables_block($table, $chain, $blockip);
                        }
                        if ($flush_fw_rules && ! $blocked) {
                            print " ... Could not locate any $table $chain " .
                                "auto-generated rules for $blockip\n";
                        }
                    }
                }
            }
        } elsif ($use_ipchains) {
            for my $chain (@ipchains_chains) {
                for my $blockip (@block_ips) {
                    ### The rule numbers can change for each ip
                    my @rules = `$cmds{'ipchains'} -nL $chain`;
                    my $blocked = 0;
                    my $rulenum = 1;
                    if ($flush_fw_rules) {
                        print " ... Removing rules for: $blockip\n";
                    }
                    RULE: for my $rule (@rules) {
                        chomp $rule;
                        ### DENY       udp  ------  0.0.0.0/0      0.0.0.0/0      * ->   *
                        if ($rule =~ /^DENY\s+all.*?$blockip.*0\.0\.0\.0\/0\s+\*\s+\-\>\s+\*/) {
                            ### all traffic from $blockip is being blocked
                            $blocked = 1;
                            if ($flush_fw_rules) {
                                print "     Deleting rule: $rule\n";
                                system "$cmds{'ipchains'} -D $chain $rulenum";
                            } else {
                                last RULE;
                            }
                        }
                        $rulenum++;
                    }
                    unless ($blocked || $flush_fw_rules) {
                        &ipchains_block($chain, $blockip);
                    }
                    if ($flush_fw_rules && ! $blocked) {
                        print " ... Could not locate any auto-generated " .
                            "rules for: $blockip\n";
                    }
                }
            }
        }
    }
    return;
}

sub auto_psad_response() {
    if ($use_iptables && ! $checked_iptables_flags) {
        ### determine whether or not the NAT or mangle code has
        ### been compiled into iptables
        &iptables_flags();
    }
    SOURCE: for my $src (keys %scan) {
        for my $dst (keys %{$scan{$src}}) {
            my $current_danger_level = $scan{$src}{$dst}{'CURR_DL'};
            ### We only want to block the IP once.  Currently this will block
            ### all traffic from the host to _all_ destinations that are
            ### protected by the firewall if the ip trips the $auto_psad_level
            ### threshold for _any_ destination.
            if ($current_danger_level
                >= $config{'AUTO_IDS_DANGER_LEVEL'}
                && ! defined $scan{$src}{$dst}{'BLOCKED'}) {
                if ($use_ipchains) {
                    my $blocked_str = '';
                    if ($config{'IPCHAINS_BLOCK_METHOD'} eq 'Y') {
                        for my $chain (@ipchains_chains) {
                            &ipchains_block($chain, $src);
                        }
                        $blocked_str = 'via ipchains';
                    } elsif ($config{'TCPWRAPPERS_BLOCK_METHOD'} eq 'Y') {
                        ### NOTE the elsif here since we only really want
                        ### to block the ip in one way, and we prefer
                        ### the firewall.
                        open H, ">> /etc/hosts.deny" or die
                            "Could not open /etc/hosts.deny: $!";
                        print H "ALL: $src\n";
                        close H;
                        $blocked_str = 'via tcp wrappers';
                    }
                    for my $dst (keys %{$scan{$src}}) {
                        $scan{$src}{$dst}{'BLOCKED'} = 1;
                    }
                    if ($config{'ALERT_AUTO_BLOCKED'} eq 'Y' && $blocked_str) {
                        my $subject = "psad: All traffic from $src has been " .
                            "BLOCKED $blocked_str on $hostname ($dst)";
                        &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'},
                            $cmds{'mail'});
                    }
                    ### write the $src ip to the $auto_blocked_file
                    &write_blocked_ip($src);
                    next SOURCE;
                } elsif ($use_iptables) {
                    my $blocked_str = '';
                    if ($config{'IPTABLES_BLOCK_METHOD'} eq 'Y') {
                        for my $table (keys %iptables_chains) {
                            for my $chain (keys %{$iptables_chains{$table}}) {
                                &iptables_block($table, $chain, $src);
                            }
                        }
                        $blocked_str = 'via iptables';
                    } elsif ($config{'TCPWRAPPERS_BLOCK_METHOD'} eq 'Y') {
                        ### NOTE the elsif here since we only really want
                        ### to block the ip in one way, and we prefer
                        ### the firewall.
                        open H, '>> /etc/hosts.deny' or
                            die "Could not open /etc/hosts.deny: $!";
                        print H "ALL: $src\n";
                        close H;
                        $blocked_str = 'via tcp wrappers';
                    }
                    for my $dst (keys %{$scan{$src}}) {
                        $scan{$src}{$dst}{'BLOCKED'} = 1;
                    }
                    if ($config{'ALERT_AUTO_BLOCKED'} eq 'Y' && $blocked_str) {
                        my $subject = "psad: All traffic from $src has been ".
                            "BLOCKED $blocked_str on $hostname ($dst)";
                        &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'},
                            $cmds{'mail'});
                    }
                    ### write the $src ip to the $auto_blocked_file
                    &write_blocked_ip($src);
                    next SOURCE;
                }
            }
        }
    }
    return;
}

sub iptables_flags() {
    $checked_iptables_flags = 1;
    $iptables_chains{'filter'}{'INPUT'}   = '';
    $iptables_chains{'filter'}{'FORWARD'} = '';
    my $nat_rv    = (system "$cmds{'iptables'} -nL -t nat " .
        "> /dev/null 2>&1") >> 8;
    my $mangle_rv = (system "$cmds{'iptables'} -nL -t mangle " .
        "> /dev/null 2>&1") >> 8;
    if ($nat_rv == 0) {
        $iptables_chains{'nat'}{'PREROUTING'} = '';
    }
    if ($mangle_rv == 0) {
        $iptables_chains{'mangle'}{'PREROUTING'} = '';
    }
    return;
}

sub iptables_block() {
    my ($table, $chain, $src) = @_;
    system "$cmds{'iptables'} -t $table -I $chain 1 " .
        "-s $src -j DROP 2> /dev/null 1>&2";
    return;
}

sub ipchains_block() {
    my ($chain, $src) = @_;
    system "$cmds{'ipchains'} -I $chain 1 -s $src " .
        "-j DENY 2> /dev/null 1>&2";
    return;
}

sub write_blocked_ip() {
    my $src = shift;
    if (-e $auto_blocked_file) {
        open B, ">> $auto_blocked_file" or warn
                " @@@ Could not append to $auto_blocked_file\n" and return;
        print B "$src\n";
        close B;
    } else {
        open B, "> $auto_blocked_file" or warn
                " @@@ Could not create $auto_blocked_file\n" and return;
        print B "IPTABLES\n" if $use_iptables;
        print B "IPCHAINS\n" if $use_ipchains;
        print B "$src\n";
        close B;
    }
    return;
}

sub email_limit_reached() {
    my ($src, $dst) = @_;
    my $subject = "psad: Email message limit for $src has been reached on " .
        "$hostname ($dst)!!!";
    &Psad::sendmail($subject, '', $config{'EMAIL_ADDRESSES'}, $cmds{'mail'});
    return;
}

sub print_scan() {  ### this should primarily be used for debugging
    my $scanfile = $config{'PRINT_SCAN_HASH'} . ".$$";
    open PSCAN, "> $scanfile";
    print PSCAN Dumper \%scan;
    close PSCAN;
    chmod 0600, $scanfile;
    print STDOUT "\n ... Printing scan data structures to $scanfile\n\n";
    return;
}

sub check_fw() {
    my $line = shift;
    ### ipchains log messages do not have a MAC address field
    if ($line !~ /MAC=/) {
        $use_ipchains = 1;
        ### check
    } else {
        $use_iptables = 1;
    }
}

sub get_local_ips() {
    my @ips = `$cmds{'ifconfig'} -a`;
    my %local_ips;
    for my $ipline (@ips) {
        if ($ipline =~ /inet\s+addr:(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s/) {
            $local_ips{$1} = '';
        }
    }
    return \%local_ips;
}

sub get_listening_ports() {
    my %listening_ports;
    my @lines = `$cmds{'netstat'} -an`;
    for my $line (@lines) {
        chomp $line;
        if ($line =~ m/^\s*(tcp|udp)\s+\d+\s+\d+\s+\S+:(\d+)\s/) {
            ### $1 == protoco (tcp/udp), $2 == port number
            $listening_ports{$1}{$2} = '';
        }
    }
    return \%listening_ports;
}

sub get_whois_data() {
    my ($ip, $whois_datafile) = @_;
    my @whois_data;
    if (defined $whois_cache{$ip}
        && $whois_cache{$ip} < $config{'WHOIS_THRESHOLD'}
        && -e $whois_datafile) {
        $whois_cache{$ip}++;
    } else {
        $whois_cache{$ip} = 0;
        eval {
            local $SIG{'ALRM'} = sub {die "whois alarm\n"};
            alarm $config{'WHOIS_TIMEOUT'};
            system "$cmds{'whois'} $ip > $whois_datafile";
            alarm 0;
        };
        if ($@) {
            ### die unless $@ eq "whois alarm\n";
            ### warn "$@: $?";  ### let the warning handler save the error.
            warn $@;
            $#whois_data = 0;
            @whois_data = ("Whois data not available!\n");
            unlink $whois_datafile;
            return \@whois_data;
        }
    }
    open W, "< $whois_datafile" or
        die " ... @@@ Could not open $whois_datafile: $!";
    @whois_data = <W>;
    close W;
    return \@whois_data;
}

sub REAPER {
    my $pid;
    $pid = waitpid(-1, WNOHANG);
#   if (WIFEXITED($?)) {
#       print STDERR " .. @@@  Process $pid exited.\n";
#   }
    $SIG{'CHLD'} = \&REAPER;
    return;
}

sub check_permissions() {
    my @files = @_;
    for my $f (@files) {
        if (-e $f) {
            chmod 0600, $f;
        } else {
            open T, "> $f";
            close T;
            chmod 0600, $f;
        }
    }
    return;
}

sub kill_psad() {
    ### must kill psadwatchd first since if not, it might try to restart
    ### any of the other three daemons (its pid file is listed first in
    ### @pidfiles)
    for my $pidfile (@pidfiles) {
        my ($pidname) = ($pidfile =~ m|.*/(\w+)\.pid|);
        if (-e $pidfile) {
            open PIDFILE, "< $pidfile";
            my $pid = <PIDFILE>;
            close PIDFILE;
            chomp $pid;
            if (kill 0, $pid) {
                print " ... Killing $pidname, pid: $pid\n";
                kill 15, $pid or print " ... @@@  psad: Could not kill " .
                    "$pidname, pid: $pid\n";
            } else {
                print " ... @@@  psad: $pidname is not running on $hostname.\n";
            }
        } else {
            print " ... @@@  psad: pid file $pidfile does not exist for " . 
                "$pidname on $hostname\n";
        }
    }
    return;
}

sub restart_psad() {
    my $cmdline;
    if (-e $cmdline_file) {
        open CMD, "< $cmdline_file";
        $cmdline = <CMD>;
        close CMD;
        chomp $cmdline;
    } else {
        die " ... @@@  psad:  No other psad process is currently " .
            "running on $hostname!";
    }
    &kill_psad();
    print " ... Restarting the psad daemons on $hostname\n";
    system "$cmds{'psad'} $cmdline";
    return;
}

### display the status of all four psad daemons
sub status_psad() {
    my $cmdline;
    ### only the psad daemon (normally) runs with command line arguments
    if (-e $cmdline_file) {
        open CMD, "< $cmdline_file";
        $cmdline = <CMD>;
        chomp $cmdline;
    }
    my $rv = 0;   ### assume psad is not running and test...
    for my $pidfile ($config{'PSAD_PID_FILE'},
            $config{'PSADWATCHD_PID_FILE'},
            $config{'KMSGSD_PID_FILE'},
            $config{'DISKMOND_PID_FILE'}) {
        my ($pidname) = ($pidfile =~ /(\w+)\.pid$/);
        if (-e $pidfile) {
            my $pid_mtime = stat($pidfile)->mtime;
            ### ($sec, $min, $hr, $day_of_month, $mon, $year,
            ### $wday, $yday, $isdst) = localtime($mtime);
            my @timevars = localtime($pid_mtime);
            $timevars[4] += 1;
            if ($timevars[4] =~ /^\d$/) {
                $timevars[4] = '0' . $timevars[4];
            }
            if ($timevars[3] =~ /^\d$/) {
                $timevars[3] = '0' . $timevars[3];
            }
            if ($timevars[0] =~ /^\d$/) {
                $timevars[0] = '0' . $timevars[0];
            }
            if ($timevars[1] =~ /^\d$/) {
                $timevars[1] = '0' . $timevars[1];
            }
            if ($timevars[2] =~ /^\d$/) {
                $timevars[2] = '0' . $timevars[2];
            }
            $timevars[5] += 1900;
            open PIDFILE, "< $pidfile";
            my $pid = <PIDFILE>;
            close PIDFILE;
            chomp $pid;
            if (kill 0, $pid) {
                print " ... $pidname (pid: $pid)";
                my @ps_out = `$cmds{'ps'} -auxww`;
                PS: for my $line (@ps_out) {
                    chomp $line;
                    if ($line =~ /^\S+\s+$pid\s+(\S+)\s+(\S+)/) {
                        print "  %CPU: $1  %MEM: $2\n";
                        print "     Running since: $timevars[2]:$timevars[1]:$timevars[0] " .
                            "$timevars[4]/$timevars[3]/$timevars[5]\n";
                        if ($pidname eq 'psad') {
                            if ($cmdline) {
                                print "     Command line arguments: $cmdline\n";
                            } else {
                                print "     Command line arguments: [none specified]\n";
                            }
                            ### print the packet counters
                            if (-e $config{'PACKET_COUNTER_FILE'}) {
                                print "     Packets Counters:\n";
                                open F, "< $config{'PACKET_COUNTER_FILE'}" or
                                    die " ... $config{'PACKET_COUNTER_FILE'}: $!";
                                print STDOUT "        $_" while (<F>);
                                close F;
                            }
                            ### sort and print the scan source ips
                            my %scan_source_ips;
                            chdir $config{'PSAD_DIR'} or
                                die " ... @@@ Could not chdir $config{'PSAD_DIR'}: $!";
                            opendir D, $config{'PSAD_DIR'} or
                                die " ... @@@ Could not open dir: $config{'PSAD_DIR'}: $!";
                            my @files = readdir D;
                            closedir D;
                            shift @files; shift @files;
                            for my $file (@files) {
                                if ($file =~ /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/ && -d $file) {
                                    ### $file is a current scan source ip
                                    my $src_ipdir = $file;
                                    if (-e "${src_ipdir}/danger_level") {
                                        open F, "< ${src_ipdir}/danger_level" or die;
                                        my $dl = <F>;
                                        close F;
                                        chomp $dl;
                                        $scan_source_ips{$src_ipdir} = $dl;
                                    } else {
                                        $scan_source_ips{$src_ipdir} = '[N/A]';
                                    }
                                }
                            }
#                            print STDOUT "     scan source ip addresses and danger levels:\n";
                            print STDOUT "     IP:           Danger Level:\n";
                            if (%scan_source_ips) {
                                for my $src (keys %scan_source_ips) {
                                    print STDOUT "   " . sprintf("%16s", $src) .
                                                 "    $scan_source_ips{$src}\n";
                                }
                            } else {
                                print STDOUT "     [No scans detected.]\n";
                            }
                        }
                        last PS;
                    }
                }
                print "\n";
                $rv = 1;
            } else {
                printf "%-16s %s", " ... @@@ $pidname ", "is not currently " .
                    "running on $hostname\n\n";
            }
        } else {
            print " ... @@@  psad: pid file $pidfile does not exist for " .
                "$pidname on $hostname\n";
        }
    }
    exit $rv;
}

sub usr1() {
    my $rv = 0;
    my $psad_pidfile = $pidfiles[1];
    if (-e $psad_pidfile) {
        open PIDFILE, "< $psad_pidfile" or
                die " ... @@@  Could not open $psad_pidfile: $!";
        my $pid = <PIDFILE>;
        close PIDFILE;
        chomp $pid;
        if (kill 0, $pid) {  ### make sure psad is actually running
            if (kill 'USR1', $pid) {
                $rv = 1;
                ### sleep to give time for the USR1 signal to be delivered
                ### and for the file to be created.
                sleep 1;
                open U, "< $config{'PSAD_DIR'}/scan_hash.${pid}"
                    or print " ... @@@  Sent psad pid $pid a USR1 " .
                        "signal, but could not open\n" .
                        "\"$config{'PSAD_DIR'}/scan_hash.${pid}\n\""
                    and return $rv;
                print while(<U>);
                close U;
            } else {
                print " ... @@@  Could not send psad the USR1 signal on $hostname\n";
            }
        } else {
            print " ... psad is not currently running on $hostname\n";
        }
    }
    return $rv;
}

sub archive_data() {
    chdir $config{'PSAD_DIR'} or die " ... @@@ Could not chdir " .
        "$config{'PSAD_DIR'}: $!";
    unless (-d $config{'SCAN_DATA_ARCHIVE_DIR'}) {
        mkdir $config{'SCAN_DATA_ARCHIVE_DIR'}, 0500 or
            die " ... @@@ Could not create dir: " .
            "$config{'SCAN_DATA_ARCHIVE_DIR'}: $!";
    }

    ### archive all of the old ip address directories since
    ### we are restarting psad (should add a way to import
    ### these directories back into memory)
    opendir D, $config{'PSAD_DIR'} or die " ... @@@ Could not open dir: " .
        "$config{'PSAD_DIR'}: $!";
    my @files = readdir D;
    closedir D;
    shift @files; shift @files;

    for my $file (@files) {
        if ($file =~ /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/ && -d $file) {
            ### $file is an old scaning ip from a previous psad execution
            my $old_ipdir     = $file;
            my $archive_ipdir = "$config{'SCAN_DATA_ARCHIVE_DIR'}/$old_ipdir";
            if (-d $archive_ipdir) {
                rmtree $archive_ipdir;
            }
            move $old_ipdir, $archive_ipdir;
        }
    }

    ### archive the fwdata file
    my $fwdata    = $config{'FW_DATA'};
    my $fwarchive = "$config{'SCAN_DATA_ARCHIVE_DIR'}/fwdata_archive";
    ### first see how big the archive file is and zero out if
    ### it is larger than about 10,000 lines
    if (-e $fwarchive) {
        my $size = -s $fwarchive;
        if ($size > 2367766) {  ### about 10,000 lines
            open F, "> $fwarchive";
            close F;
        }
    }
    unless (-e $fwdata) {
        return;
    }
    open FW, "< $fwdata" or die "$fwdata exists but couldn't open it: $!";
    my @fwlines = <FW>;
    close FW;
    open AR, ">> $fwarchive" or die "Could not open $fwarchive: $!";
    print AR $_ for @fwlines;
    close AR;
    ### zero out $FW_DATA
    open F, "> $fwdata";
    close F;
    return;
}

sub check_old_cmdargs() {
    if ($errors) {
        print " ... @@@ The \"errors\" option has been changed to \"no_errors.\"\n";
        &usage(1);
    }
    if ($errors) {
        print " ... @@@ The \"reversedns\" option has been changed to \"no_rdns.\"\n";
        &usage(1);
    }
    if ($errors) {
        print " ... @@@ The \"whois\" option has been changed to \"no_whois.\"\n";
        &usage(1);
    }
    if ($errors) {
        print " ... @@@ The \"localport\" option has been changed to \"no_netstat.\"\n";
        &usage(1);
    }
    if ($errors) {
        print " ... @@@ The \"firewallcheck\" option has been changed to \"no_fwcheck.\"\n";
        &usage(1);
    }
    if ($errors) {
        print " ... @@@ The \"Daemon\" option has been changed to \"Daemon.\"\n";
        &usage(1);
    }
    return;
}

sub setup_psad() {
    unless (-d $config{'PSAD_DIR'}) {
        mkdir $config{'PSAD_DIR'}, 0500;
    }
    unless (-d $config{'PSAD_ERROR_DIR'}) {
        mkdir $config{'PSAD_ERROR_DIR'}, 0500;
    }
    unless (-e $config{'FW_DATA'}) {
        open F, "> $config{'FW_DATA'}";
        close F;
    }
    unless (-e $config{'ERROR_LOG'}) {
        open E, "> $config{'ERROR_LOG'}";
        close E;
    }
    unless (-e $config{'PSAD_FIFO'}) {
        system "$cmds{'mknod'} -m 600 $config{'PSAD_FIFO'} p";
    }
    unless (-e '/etc/syslog.conf.orig') {
        copy('/etc/syslog.conf', '/etc/syslog.conf.orig');
    }
    open RS, '< /etc/syslog.conf' or
        die " ... @@@  Unable to open /etc/syslog.conf: $!";
    my @slines = <RS>;
    close RS;
    my $found = 0;
    for my $line (@slines) {
        $found = 1 if $line =~ m/|\s*$config{'PSAD_FIFO'}/;
    }
    unless ($found) {
        open SYSLOG, '> /etc/syslog.conf' or
            die " ... @@@  Unable to open /etc/syslog.conf: $!";
        for my $line (@slines) {
            unless ($line =~ /psadfifo/) {
                print SYSLOG $line;
            }
        }
        ### reinstate kernel logging to our named pipe
        print SYSLOG "### Send kern.info messages to psadfifo for " .
            "analysis by kmsgsd\n";
        print SYSLOG "kern.info		|$config{'PSAD_FIFO'}\n";
        close SYSLOG;
        system "$cmds{'killall'} -HUP $cmds{'syslogd'}";
    }

    return;
}

sub check_config() {
    my @required_vars = qw(
        EMAIL_ADDRESSES  PSAD_CHECK_INTERVAL
        FW_DATA ERROR_LOG  FW_MSG_SEARCH ENABLE_AUTO_IDS
        SCAN_TIMEOUT DANGER_LEVEL1 DANGER_LEVEL2 DANGER_LEVEL3
        DANGER_LEVEL4 DANGER_LEVEL5 PORT_RANGE_SCAN_THRESHOLD
        ALERT_ALL PSAD_EMAIL_LIMIT IPTABLES_BLOCK_METHOD
        IPCHAINS_BLOCK_METHOD TCPWRAPPERS_BLOCK_METHOD
        EMAIL_ALERT_DANGER_LEVEL PSAD_FIFO WHOIS_THRESHOLD
        WHOIS_TIMEOUT PACKET_COUNTER_FILE SCAN_DATA_ARCHIVE_DIR
        ENABLE_PERSISTENCE
    );
    &Psad::validate_config($config_file, \@required_vars, $config_href);
    return;
}

sub usage() {
    my $exitcode = shift;
    print <<_HELP_;

psad; the Port Scan Attack Detector
Version: $version
By Michael B. Rash (mbr\@cipherdyne.com, http://www.cipherdyne.com)

USAGE: psad [-s <signature file>] [-a <auto ips file>] [-c <config file>] [-o]
       [-L] [-i <interval>] [-h] [-F] [-S] [-K] [-R] [-U] [-V] [--no_fwcheck]
       [--no_daemon] [--no_rdns] [--no_whois] [--no_netstat] [--no_errors]

OPTIONS:
      -s   --signatures <sig file>    - import scan signatures.
      -a   --auto_ips <ips file>      - import auto ips file for automatic
                                        ip danger level increases/decreses.
      -c   --config <config file>     - use config file instead of the
                                        values contained within the psad
                                        script.
      -i   --interval                 - configure the check interval from
                                        the command line to override the 15
                                        second default.
      -d   --debug                    - run psad in debugging mode.
      -o   --output                   - print all messages to STDOUT (this
                                        does not include bad packet messages
                                        that are printed to the error log).
      -L   --Logging_server           - psad is being run on a syslog
                                        logging server.
      -F   --Flush                    - remove any auto-generated firewall
                                        block rules.
      -K   --Kill                     - kill all running psad processes.
      -R   --Restart                  - restart all running psad processes.
      -S   --Status                   - displays the status of any
                                        currently running psad processes.
      -U   --USR1                     - send a running psad process a USR1
                                        signal.
      -V   --Version                  - print the psad version and exit.

      --no_daemon                     - do not run as a daemon.
      --no_errors                     - do not write errors to the error
                                        log.
      --no_whois                      - disable whois lookups.
      --no_fwcheck                    - disable firewall rules verification.
      --no_rdns                       - disable name resolution against
                                        scanning ips.
      --no_netstat                    - disable local port lookups for scan
                                        signatures.
      -h   --help                     - prints this help message.

_HELP_
    exit $exitcode;
}
