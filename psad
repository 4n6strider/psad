#!/usr/bin/perl -w
#
# Description: Port Scan Attack Detector (psad)
# - uses ipchains/iptables logs.  Uses input from /var/log/psad/fwdata 
# generated kmsgsd
#
# version 0.9.2
# Copyright (C) 1999-2001 Michael B. Rash (mbr@cipherdyne.com)
#
# Credits:  (see the CREDITS file)
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
#    USA
#
# TODO: 
#	- Make use of other logging options available in iptables to detect
#	  more tcp signatures.  (E.g. --log-tcp-options, --log-ip-options,
#	  --log-tcp-sequence, etc.) for better signature recognition.
#	- Allow ipchains to use udp signatures as well as tcp signatures that
#	  only require a syn packet to a port.
#	- Deal with the possibility that psad could eat lots of memory over
#	  time if $ENABLE_PERSISTENCE="Y". This should involve periodically
#	  undef'ing entries in %Scan (or maybe the entire hash), but this 
#	  should be done in a way that allows some scan data to persist.
#	- Put source and destination ip addresses back into psad_signatures.
#	- Ipfilter support on *BSD platforms.
#	- Icmp support.
#	- Re-write significant components (kmsgsd, diskmond, psadwatchd) in C.
#	- Possibly add a daemon to take into account ACK PSH, ACK FIN, RST etc.
#	  packets that the client may generate after the ip_conntrack module
#	  is reloaded.  Without anticipating such packets psad will interpret
# 	  them as a belonging to a port scan.
#	- Improve check_firewall_rules() to check for a state rule (iptables) 
#	  since having such a rule greatly improves the quality of the data 
# 	  stream provided to psad by kmsgsd since more packet types will be 
#	  denied without requiring overly complicated firewall rules to detect 
#	  odd tcp flag combinations.
#	- Investigate the possibility of passive OS fingerprinting by looking
#	  at TTL and other fields in the headers (good idea Jay).
#	- Sometimes packets (particularly ACK and RST packets) seem to not
#	  recognized by ipt_state/ip_conntrack, so such packets get denied and
#	  hence are picked up by psad.  Solution: parse /proc/net/ip_conntrack
#	  for existing sessions and don't alert on these packets.
#	- Enhance the check_firewall_rules() routine to correct any problems
#	  with the firewall ruleset.  This is part of the integration of psad 
#	  with Bastille Linux.
#	- (psad-init) make sure the init script will work on different Linux
#	  distros.
#	- Threshold-based rate limiting for email messages.
#	- perldoc
#
# Sample packet (rejected by ipchains)
# Dec 19 11:54:07 orthanc kernel: Packet log: input REJECT lo PROTO=1
# 10.0.0.4:3127.0.0.1:3 L=88 S=0xC0 I=49513 F=0x0000 T=255
#
# Sample packet (rejected by iptables... --log-prefix = "DENY")
# Mar 11 13:15:52 orthanc kernel: DENY IN=lo OUT= MAC=00:00:00:00:00:00:00:00:00:00:00:00:08:00
# SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=44847 
# DPT=35 WINDOW=32304 RES=0x00 SYN URGP=0
#
# There may be a bug in iptables, since occasionally log entries are generated 
# by a long port scan like this (note there is no 'DPT' field): 
#   Mar 16 23:50:25 orthanc kernel: DENY IN=lo OUT= MAC=00:00:00:00:00:00:00:00:00:00:00:00:08:00 
#   SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=TCP SPT=39935 
#   DINDOW=32304 RES=0x00 SYN URGP=0
#################################################################################################

### modules used by psad
use Psad;
use File::stat "stat";
use Getopt::Long "GetOptions";
use autouse 'Data::Dumper' => "Dumper";  ### this one is not used very much so don't load immediately
use autouse 'Socket';       ### not used until a scan is detected so don't load until it is needed
use Sys::Hostname "hostname";
# use Sys::Syslog qw(openlog syslog closelog);   ### this does not seem to play nice with perl-5.005_03
use POSIX "setsid";
# use strict;
### psad does not yet support 'strict refs' since several hashes have $hsh{key} = "someval" and $hsh{key1}{key2} = "anotherval"... should probably fix this.
# no strict "refs";

### globals
use vars qw($VERSION %Scan $PRINT_SCAN_HASH $USE_IPCHAINS $USE_IPTABLES $DEBUG $HOSTNAME);

#==================== config ======================= ## do not remove this line (used by install.pl to preserve configs) ##
### Initialize config variables.  Some can be overriden with command line args
my $PSAD_LOGFILE = "/var/log/psad/scanlog";
my $FW_DATA = "/var/log/psad/fwdata";
my $ERROR_LOG = "/var/log/psad/fwerrorlog";
my $EMAIL_ALERTFILE = "/var/log/psad/email_alert";
$PRINT_SCAN_HASH = "/var/log/psad/scan_hash";  # global for sub print_scan
my $CHECK_INTERVAL = 15;
my $PORT_RANGE_SCAN_THRESHOLD = 1;
my $ENABLE_PERSISTENCE = "Y";	# if "Y", means that scans will never timeout
my $SCAN_TIMEOUT = 3600;	# this is used only if $ENABLE_PERSISTENCE = "N";
my $SHOW_ALL_SIGNATURES = "N";	# if "Y", means that all tcp signatures will be shown since the scan started instead of just the current ones.
my %DANGER_LEVELS;
$DANGER_LEVELS{'1'} = 5;
$DANGER_LEVELS{'2'} = 50;
$DANGER_LEVELS{'3'} = 1000;
$DANGER_LEVELS{'4'} = 5000;
$DANGER_LEVELS{'5'} = 10000;
my $ENABLE_EMAIL_ALERTS = "Y";
my $EMAIL_ALERT_DANGER_LEVEL = 1;  # Send email alert if danger level >= to this value
my @EMAIL_ADDRESSES = ('root@localhost');  # supports multiple email addresses
my $ALERT_ALL = "Y";	# if "Y", send email for all new bad packets instead of just when a danger level increases
my $ENABLE_AUTO_IDS = "N"; 	# if "Y", enable automated IDS response (auto manages firewall rulesets). 
my $AUTO_IDS_DANGER_LEVEL = 5;  # Block all traffic from offending IP if danger level >= to this value 
my $WHOIS_TIMEOUT = 60;

### system binaries ###
my $ipchainsCmd = "/sbin/ipchains";
my $iptablesCmd = "/usr/local/bin/iptables";
my $wcCmd = "/usr/bin/wc";
my $tailCmd = "/usr/bin/tail";
my $mailCmd = "/bin/mail";
my $ifconfigCmd = "/sbin/ifconfig";
my $grepCmd = "/bin/grep";
my $netstatCmd = "/bin/netstat";
my $unameCmd = "/bin/uname";
my $whoisCmd = "/usr/local/bin/whois.psad";
my $psadwatchdCmd = "/usr/local/bin/psadwatchd";
my $kmsgsdCmd = "/usr/local/bin/kmsgsd";
my $diskmondCmd = "/usr/local/bin/diskmond";
my $psadCmd = "/usr/local/bin/psad";
#================== end config ==================== ## do not remove this line (used by install.pl to preserve configs) ##
#===================== main =======================

### a few more configuration variables that should not really be in the config section
$VERSION = "0.9.2";

### pid files
my @PIDFILES = qw(/var/run/psadwatchd.pid
		  /var/run/psad.pid
		  /var/run/kmsgsd.pid
		  /var/run/diskmond.pid);

### file used to store the psad command line
my $cmdline_file = "/var/run/psad.cmd";

### these are global variables
$USE_IPCHAINS = 0;
$USE_IPTABLES = 0;
$DEBUG = 0;
$HOSTNAME = hostname;

### initialize and scope some default variables (command line args can override some default values)
my $Scan_href;  # main psad data structure; contains ips, port ranges, tcp flags, and danger levels
my $daemon = 0;
my $output = 0;
my $errors = 0;
my $dnslookups = 0;
my $whoislookups = 0;
my $signatures = 0;
my $auto_ips = 0;
my $netstat_lookup = 0;
my $fwcheck = 0;
my $Syslog_server = 0;
my $kill = 0;
my $restart = 0;
my $status = 0;
my $print_version = 0;
my $help = 0;
my $config = 0;

### save a copy of the command line arguments
my @args_cp = @ARGV;

Getopt::Long::Configure("no_ignore_case");  # make Getopts case sensitive

&usage_and_exit(1) unless (GetOptions (
        'help'           => \$help,             # display help
        'auto_ips=s'     => \$auto_ips,         # enable automatic ip danger level assignment
        'output'         => \$output,           # write scanlog messages to STDOUT
        'Daemon'         => \$daemon,           # do not run as a daemon
        'debug'          => \$DEBUG,            # run in debug mode
        'interval=s'     => \$CHECK_INTERVAL,   # set $CHECK_INTERVAL from the command line
        'firewallcheck'  => \$fwcheck,          # do not check firewall rules
        'config=s'       => \$config,           # specify configuration file
        'reversedns'     => \$dnslookups,       # do not issue dns lookups against scanning ip address
        'signatures=s'   => \$signatures,       # scan signatures
        'localport'      => \$netstat_lookup,   # do not check to see if the firewall is listening on localport that has been scanned
        'errors'         => \$errors,           # do not write malformed packet messages to error log
        'Logging_server' => \$Syslog_server,    # we are running psad on a syslog logging server
        'Kill'           => \$kill,             # kill all running psad processes (psadwatchd, psad, kmsgsd, diskmond)
	'Restart'	 => \$restart,		# restart psad with all options of the currently running psad process
	'Status'	 => \$status,		# display status of any currently running psad processes
        'Version'        => \$print_version,    # print the psad version and exit
        'whois'          => \$whoislookups      # do not issue whois lookups against the scanning ip
));
&usage_and_exit(0) if ($help);

### print the version number and exit if -V given on the command line
print "psad version $VERSION, by Michael B. Rash (mbr\@cipherdyne.com)\n" and exit 0 if $print_version;

### everthing after this point must be executed as root.
$< == 0 && $> == 0 or die "\n@@@@@  psad: You must be root (or equivalent UID 0 account) to execute psad!  Exiting.\n\n";

### the --Kill command line switch was given
if ($kill) {
        &kill_psad(\@PIDFILES);
        exit 0;
}

### the --Status command line switch was given
if ($status) {
        $rv = &psad_status(\@PIDFILES);
        exit $rv;
}

my %Cmds = (
        "ipchains"      => $ipchainsCmd,
        "iptables"      => $iptablesCmd,
	"wc"		=> $wcCmd,
	"tail"		=> $tailCmd,
	"mail"		=> $mailCmd,
	"ifconfig"	=> $ifconfigCmd,
	"grep"		=> $grepCmd,
	"netstat"	=> $netstatCmd,
	"uname"		=> $unameCmd,
	"whois"		=> $whoisCmd,
	"psadwatchd"	=> $psadwatchdCmd,
	"kmsgsd"	=> $kmsgsdCmd,
	"diskmond"	=> $diskmondCmd,
	"psad"		=> $psadCmd
);

### check to make sure the commands specified in the config section are in the right place, and attempt to correct automatically if not.
%Cmds = &check_commands(\%Cmds);

### the --Restart command line switch was given
if ($restart) {
	&restart_psad(\@PIDFILES, $cmdline_file, \%Cmds);
	exit 0;
}

### check to make sure another psad process is not already running.
&unique_pid($PIDFILES[1]);

### make sure the permissions on these files is 0600
&check_permissions($PSAD_LOGFILE, $FW_DATA, $ERROR_LOG, $EMAIL_ALERTFILE);

### get the ip addresses that are local to this machine
my $local_ips_href = &get_local_ips(\%Cmds);

### disable whois lookups if for some reason the whois client that is bundled with psad can't be found
$whoislookups = 1 if ($Cmds{'whois'} !~ /psad/); 

### install signal handler for debugging %Scan with Data::Dumper
$SIG{USR1} = \&print_scan;

### if psad is running on a syslog server, don't check the firewall rules since they may not be local.
unless ($fwcheck || $Syslog_server) {
	unlink "/var/log/psad/fw_check.txt";
	&check_firewall_rules(\@EMAIL_ADDRESSES, ["/var/log/psad/fw_check.txt"], \%Cmds);
}

### daemonize psad unless running with --Daemon or --debug
unless ($daemon || $DEBUG) {
	my $pid = fork;
	exit if $pid;
	die "@@@@@  $0: Couldn't fork: $!" unless defined($pid);
	POSIX::setsid() or die "@@@@@  $0: Can't start a new session: $!\n";
}

### write the current pid associated with psad to the psad pid file
&writepid($PIDFILES[1]);

### write the command line args used to start psad to $cmdline_file
&writecmdline(\@args_cp, $cmdline_file);

### psad _requires_ that kmsgsd is running to receive any data, so let's start it here for good measure (as of 0.9.2 it
### makes use of the pid files and unique_pid(), so we don't have to worry about starting a duplicate copy).  While we're at
### it, start psadwatchd and diskmond too.  Note that this is the best place to start the other daemons since we just wrote
### the psad pid to $PIDFILES[1] above.
system "$Cmds{'kmsgsd'}";
system "$Cmds{'diskmond'}";
system "$Cmds{'psadwatchd'}" unless ($DEBUG);	### if running in debug mode, starting psadwatchd can start unwanted
						### copies of psad after the debugging process is killed.

### import config variables from the config file if running with --config=<config file>
if ($config) {
	open CONF, "< $config";
	while(<CONF>) {
		# don't allow system calls and other mischief in the config file... just variable assignments.  Thanks Jay Beale (Bastille Linux).
		next and print $_ if ($_ =~ /system/ && $_ !~ /\#.*?system/);
		next if ($_ =~ /\`.*?\`/);
		next if ($_ =~ /open/ && $_ !~ /\#.*?open/);
		next if ($_ =~ /qx/);
		next unless ($_ =~ /my\s+\$|\@|\%.*?\=.*?\;/ || $_ =~ /\$|\@|\%.*?\=.*?\;/);
		eval $_;
	}
	close CONF;
}	

unless (-e $FW_DATA) {
	open F, ">> $FW_DATA";
	close F;
}
my $Sigs_href = &import_signatures($signatures) if $signatures;
my $Auto_ips_href;
if ($auto_ips) {  # support automatic ip danger level increases/decreases.
	$Auto_ips_href = &import_auto_ips($auto_ips);
} else {
	$Auto_ips_href = 0;
}

### initialize fwdata_start_lines
my $fwdata_start_lines = (split /\s+/, `$Cmds{'wc'} -l $FW_DATA`)[1];
#=================================== main loop ======================================
for (;;) {
	my $auto_ips_mtime_start = stat($auto_ips)->mtime if $auto_ips;
	my $sigs_mtime_start = stat($signatures)->mtime if $signatures;
	sleep $CHECK_INTERVAL;
	my $fwdata_end_lines = (split /\s+/, `$Cmds{'wc'} -l $FW_DATA`)[1];
	if ($signatures) {  # scan $signatures for any signature updates
		my $sigs_mtime_end = stat($signatures)->mtime;
		if ($sigs_mtime_start != $sigs_mtime_end) {  # the signatures were updated... import the new signatures.
			$Sigs_href = &import_signatures($signatures);
                	foreach my $email_address (@EMAIL_ADDRESSES) {
                        	system "$Cmds{'mail'} $email_address -s \"psad: re-read $signatures file on $HOSTNAME\" < /dev/null";
                	}
		}
	}
	if ($auto_ips) {  # scan $auto_ips for any ips that should automatically have a certain danger threshold set.
		my $auto_ips_mtime_end = stat($auto_ips)->mtime;
		if ($auto_ips_mtime_start != $auto_ips_mtime_end) {  # the auto ips file was updated... import the new ip/danger level pairs.
			$Auto_ips_href = &import_auto_ips($auto_ips);
			$Scan_href = &reset_auto_tags($Scan_href);  # need to set $Scan_href->{$srcip}->{$dstip}->{'AUTO'} = "N" since $Auto_ips_href was updated.
			foreach my $email_address (@EMAIL_ADDRESSES) {
                                system "$Cmds{'mail'} $email_address -s \"psad: re-read $auto_ips file on $HOSTNAME\" < /dev/null";
                        }
		}
	}
	if ($fwdata_end_lines - $fwdata_start_lines > 0) {   # new packets have been written to $FW_DATA by kmsgsd for psad analysis
		my $grabnum = $fwdata_end_lines - $fwdata_start_lines;
		my @process_lines = `$Cmds{'tail'} -$grabnum $FW_DATA`;
		print "MAIN: calling check_scan()\n" if $DEBUG;
		$Scan_href = &check_scan(\@process_lines, $Sigs_href, $signatures, $netstat_lookup, $local_ips_href, $errors, 
									$ERROR_LOG, $ENABLE_PERSISTENCE, $SCAN_TIMEOUT, \%Cmds);
		print "MAIN: calling assign_danger_level()\n" if $DEBUG;
		$Scan_href = &assign_danger_level($Scan_href, $Auto_ips_href, $PORT_RANGE_SCAN_THRESHOLD, $ALERT_ALL, \%DANGER_LEVELS);
		print "MAIN: calling scan_logr()\n" if $DEBUG;
		$Scan_href = &scan_logr($Scan_href, $PSAD_LOGFILE, $output, $dnslookups, $whoislookups, $WHOIS_TIMEOUT, $ENABLE_EMAIL_ALERTS,
					$EMAIL_ALERT_DANGER_LEVEL, $EMAIL_ALERTFILE, \@EMAIL_ADDRESSES, $SHOW_ALL_SIGNATURES, \%Cmds);
		if ($ENABLE_AUTO_IDS eq "Y" && ! $Syslog_server) {  # don't manage the firewall rules if psad is running on a syslog server.
			$Scan_href = &auto_psad_response($Scan_href, $AUTO_IDS_DANGER_LEVEL, \%Cmds, \@EMAIL_ADDRESSES);
		}
	}
	print "MAIN: number of lines in $FW_DATA: $fwdata_end_lines\n" if $DEBUG;
	$fwdata_start_lines = $fwdata_end_lines; # reset fwdata_start_lines to where we just left off so that we don't miss any packets
}

#==================================== end main =========================================
sub check_scan() {  # keeps track of scanning ip's, increments packet counters, keep track of tcp flags for each
		    # scan (iptables only)
	my ($process_lines_aref, $sigs_href, $signatures, $netstat_lookup, $local_ips_href, $errors, 
							$error_log, $enable_persistence, $scan_timeout, $Cmds_href) = @_;
	my @bad_packets;
	my $local_listening_ports_href;
	my ($srcip, $dstip, $proto, $srcport, $dstport, $flags);
	# if necessary check which firewall (ipchains vs. iptables)
	check_fw($process_lines_aref->[0]) unless ($USE_IPCHAINS || $USE_IPTABLES);
	unless ($netstat_lookup) {
		$local_listening_ports_href = get_listening_ports($Cmds_href);
	}
	READPKT: foreach my $l (@$process_lines_aref) {
		chomp $l;
		if ($USE_IPTABLES) {
			# sometimes the log entry is messed up by iptables so we write it to the error log
			if ($l =~ /SRC\=(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\sDST\=(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s.+?PROTO\=(\w{3,4})\sSPT\=(\d+)\sDPT\=(\d+)/) {
				($srcip, $dstip, $proto, $srcport, $dstport) = ($1,$2,$3,$4,$5);
				if ($proto ne "TCP" && $proto ne "UDP") {  # psad does not yet support any protocols other than tcp and udp....
					push @bad_packets, $l;
					next READPKT;
				}
				if ($proto eq "TCP") {
					if ($l =~ /RES\S+\s(.*?)URGP/ || $l =~ /RES(\s)URGP/) {
						$flags = $1;
						chop $flags;
						$flags = "NULL" if ($flags eq ""); 
						# per page 595 of the Camel book, if /blah1|blah2/ can be slower than if /blah1/ || /blah2/
					        unless (($flags =~ /SYN/ || $flags =~ /FIN/ || $flags =~ /URG/ || $flags =~ /PSH/ || $flags =~ /ACK/ 
							  		 || $flags =~ /RST/ || $flags =~ /NULL/) && ($flags !~ /LEN/ || $flags !~ /TOS/
									 || $flags !~ /PREC/ || $flags !~ /PROTO/ || $flags !~ /WINDOW/ ||
									    $flags !~ /RES/)) {
                                			push @bad_packets, $l;
                                			next READPKT;
                        			}
					} else {
						push @bad_packets, $l;
						next READPKT;
					}
				}	
			} else {
				push @bad_packets, $l;
				next READPKT;
			}
		} elsif ($USE_IPCHAINS) {
			# could implement source port checking here
			if ($l =~ /PROTO\=(\d+)\s(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\:(\d+)\s(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\:(\d+)/) {
				($proto, $srcip, $srcport, $dstip, $dstport) = ($1,$2,$3,$4,$5);
				$flags = "NONE";
			} else {
				push @bad_packets, $l;
                                next READPKT;
                        }
		}
		if ($enable_persistence eq "N") {
			my $currtime = time();
			if (defined $Scan{$srcip}{$dstip}{'START_TIME'}{'EPOCH_SECONDS'}) {
				my $tmp = $currtime - $Scan{$srcip}{$dstip}{'START_TIME'}{'EPOCH_SECONDS'};
				if (($currtime - $Scan{$srcip}{$dstip}{'START_TIME'}{'EPOCH_SECONDS'}) >= $scan_timeout) {
					undef $Scan{$srcip}{$dstip};
				}
			}
		} 
		# hash initialization
		$Scan{$srcip}{$dstip}{'LOGR'} = "Y";
		if ($proto eq "TCP") {
			$Scan{$srcip}{$dstip}{$proto}{'FLAGS'}{$flags} = 0 unless (defined $Scan{$srcip}{$dstip}{$proto}{'FLAGS'}{$flags});
		}
		$Scan{$srcip}{$dstip}{'AUTO'} = "N" unless (defined $Scan{$srcip}{$dstip}{'AUTO'});
		$Scan{$srcip}{$dstip}{'CURRENT_DANGER_LEVEL'} = 0 unless (defined $Scan{$srcip}{$dstip}{'CURRENT_DANGER_LEVEL'});
		unless (defined $Scan{$srcip}{$dstip}{'START_PORT'}) {  # this is the absolute starting port since the first packet was detected
			$Scan{$srcip}{$dstip}{'START_PORT'} = 65535; # make sure the initial start port is not too low
			$Scan{$srcip}{$dstip}{'END_PORT'} = 0; # make sure the initial end port is not too high
		}
		my $epoch_seconds = time() if ($enable_persistence eq "N");
		my @time = split / /, scalar localtime;   # Get the current time as a nice ASCII string.
		pop @time; shift @time;    # Get rid of the day and the year to make the time consistent with syslog
		my $time = join ' ', @time;
		unless (defined $Scan{$srcip}{$dstip}{$proto}{'CURRENT_INTERVAL'}{'START_PORT'}) {  # this is the current starting port since $CHECK_INTERVAL
			$Scan{$srcip}{$dstip}{$proto}{'CURRENT_INTERVAL'}{'START_TIME'} = $time;
                       	$Scan{$srcip}{$dstip}{$proto}{'CURRENT_INTERVAL'}{'START_PORT'} = 65535; # make sure the initial start port is not too low
                       	$Scan{$srcip}{$dstip}{$proto}{'CURRENT_INTERVAL'}{'END_PORT'} = 0; # make sure the initial end port is not too high
		}
		unless (defined $Scan{$srcip}{$dstip}{'START_TIME'}{'READABLE'}) {
			$Scan{$srcip}{$dstip}{'START_TIME'}{'READABLE'} = $time;
			$Scan{$srcip}{$dstip}{'START_TIME'}{'EPOCH_SECONDS'} = $epoch_seconds if ($enable_persistence eq "N");
		}
		$Scan{$srcip}{$dstip}{'END_TIME'} = $time;
		$Scan{$srcip}{$dstip}{'END_TIME'}{'EPOCH_SECONDS'} = $epoch_seconds if ($enable_persistence eq "N");
		# increment hash values
		$Scan{$srcip}{$dstip}{'ABSNUM'}++;  # if $Scan{$srcip}{$dstip}{'ABSNUM'} is not yet defined, incrementing it here will make it equal to 1 anyway
		if ($proto eq "TCP") {
			$Scan{$srcip}{$dstip}{'TCP'}{'FLAGS'}{$flags}++;
		}
		# see if this port lies outside our current range
		($Scan{$srcip}{$dstip}{'START_PORT'}, $Scan{$srcip}{$dstip}{'END_PORT'}) = 
			check_range($dstport, $Scan{$srcip}{$dstip}{'START_PORT'}, $Scan{$srcip}{$dstip}{'END_PORT'});
		($Scan{$srcip}{$dstip}{$proto}{'CURRENT_INTERVAL'}{'START_PORT'}, $Scan{$srcip}{$dstip}{$proto}{'CURRENT_INTERVAL'}{'END_PORT'}) =
                        check_range($dstport, $Scan{$srcip}{$dstip}{$proto}{'CURRENT_INTERVAL'}{'START_PORT'}, $Scan{$srcip}{$dstip}{$proto}{'CURRENT_INTERVAL'}{'END_PORT'});
		if ($DEBUG) {
			print "check_scan():\n";
			print "     srcip: $srcip, dstip: $dstip\n";
			print "     Scan{srcip} = $Scan{$srcip}\n";
			print "     Scan{srcip}{dstip} = $Scan{$srcip}{$dstip}\n";
			print "     Scan{srcip}{dstip}{'LOGR'} = $Scan{$srcip}{$dstip}{'LOGR'}\n";
			print "     Scan{srcip}{dstip}{'ABSNUM'} = $Scan{$srcip}{$dstip}{'ABSNUM'}\n";
			print "     Scan{srcip}{dstip}{'TCP'}{'FLAGS'}{flags} = $Scan{$srcip}{$dstip}{'TCP'}{'FLAGS'}{$flags}\n" if ($proto eq "TCP");
			print "     flags: $flags\n" if ($proto eq "TCP");
			print "     Scan{srcip}{dstip}{'AUTO'} $Scan{$srcip}{$dstip}{'AUTO'}\n";
			print "     Scan{srcip}{dstip}{'CURRENT_DANGER_LEVEL'} = $Scan{$srcip}{$dstip}{'CURRENT_DANGER_LEVEL'}\n";
			print "     Scan{srcip}{dstip}{'START_PORT'} = $Scan{$srcip}{$dstip}{'START_PORT'}\n";
			print "     Scan{srcip}{dstip}{'END_PORT'} = $Scan{$srcip}{$dstip}{'END_PORT'}\n";
			print "     Scan{srcip}{dstip}{'START_TIME'}{'READABLE'} = $Scan{$srcip}{$dstip}{'START_TIME'}{'READABLE'}\n";
			print "     Scan{srcip}{dstip}{'START_TIME'}{'EPOCH_SECONDS'} = $Scan{$srcip}{$dstip}{'START_TIME'}{'EPOCH_SECONDS'}\n" if ($enable_persistence eq "N");
			print "     Scan{srcip}{dstip}{'END_TIME'} = $Scan{$srcip}{$dstip}{'END_TIME'}\n";
			print "     Scan{srcip}{dstip}{'END_TIME'}{'EPOCH_SECONDS'} = $Scan{$srcip}{$dstip}{'END_TIME'}{'EPOCH_SECONDS'}\n" if ($enable_persistence eq "N");
			print "     Scan{srcip}{dstip}{$proto}{'CURRENT_INTERVAL'}{'START_PORT'} = $Scan{$srcip}{$dstip}{$proto}{'CURRENT_INTERVAL'}{'START_PORT'}\n";
			print "     Scan{srcip}{dstip}{$proto}{'CURRENT_INTERVAL'}{'END_PORT'} = $Scan{$srcip}{$dstip}{$proto}{'CURRENT_INTERVAL'}{'END_PORT'}\n";
		}
		if ($signatures && $USE_IPTABLES) {  # might try use ipchains also, but then cannot use tcp flags except for -y -l rules
			foreach my $msg (keys %{$sigs_href->{$proto}}) {   # need to iterate through all signatures since a packet may match several
				my $dstport_criteria = 0;
				my $srcport_criteria = 0;
				my $rv = 0;
				if ($proto eq "TCP") {
					if (check_port($sigs_href, $msg, $dstport, "DSTPORT", $proto)
						&& check_port($sigs_href, $msg, $srcport, "SRCPORT", $proto)
							&& check_flags($sigs_href, $msg, $flags, $proto)) {     # tripped a tcp signature
						$Scan{$srcip}{$dstip}{'TCP'}{'SIGMATCH'}{'SIGDL'} = $sigs_href->{'TCP'}->{$msg}->{'DANGERLEVEL'};
						$rv = 1;
					}
				} elsif ($proto eq "UDP") {
                                        if (check_port($sigs_href, $msg, $dstport, "DSTPORT", $proto)
                                                && check_port($sigs_href, $msg, $srcport, "SRCPORT", $proto)) {     # tripped a udp signature
						$Scan{$srcip}{$dstip}{'UDP'}{'SIGMATCH'}{'SIGDL'} = $sigs_href->{'UDP'}->{$msg}->{'DANGERLEVEL'};
						$rv = 1;
					}
				}
				if ($rv) {
					print "     SIGMATCH on dstport: $dstport\n" if $DEBUG;
					my $listening_port = "";
					unless ($netstat_lookup) {
						my $lprot;
						$lprot = "tcp" if ($proto eq "TCP");
						$lprot = "udp" if ($proto eq "UDP");
						my $dstip_is_local = 0;
						# check to see if the scan destination ip is directed at the firewall.  If yes, then check to see if
						# a server is listening on the DSTPORT by parsing netstat output.  If not, psad would have to connect
						# to the deestination port on the remote machine, but it should not do this so it is not implemented.
						$dstip_is_local = 1 if defined $local_ips_href->{$dstip};
						if ($dstip_is_local) {
							my $key = $lprot . $dstport;
							if (defined $local_listening_ports_href->{$key}) {
								$listening_port = "YOUR MACHINE IS LISTENING ON ($lprot) PORT: $dstport";
							} else {
								$listening_port = "There is no server listening on $lprot port $dstport";
							}
						} # else $listening_port is already ""
					}
# including sp almost always changes the hash key: 	my $alert_string = "$msg  sp=$srcport, dp=$dstport, flags=$flags.  $listening_port";
					my $alert_string;
					$alert_string = "$msg  dp=$dstport, flags=$flags. $listening_port";
					if (defined $Scan{$srcip}{$dstip}{$proto}{'SIGMATCH'}{$alert_string}) {
						$Scan{$srcip}{$dstip}{$proto}{'SIGMATCH'}{$alert_string}++;
					} else {
						$Scan{$srcip}{$dstip}{$proto}{'SIGMATCH'}{$alert_string} = 1;
					}
					unless (defined $Scan{$srcip}{$dstip}{$proto}{'CURRENT_SIGMATCH_START_TIME'}) {
						$Scan{$srcip}{$dstip}{$proto}{'CURRENT_SIGMATCH_START_TIME'} = $time;
					}
					if (defined $Scan{$srcip}{$dstip}{$proto}{'CURRENT_SIGMATCH'}{$alert_string}) {
                               	                $Scan{$srcip}{$dstip}{$proto}{'CURRENT_SIGMATCH'}{$alert_string}++;
                                       	} else {
                                               	$Scan{$srcip}{$dstip}{$proto}{'CURRENT_SIGMATCH'}{$alert_string} = 1;
                                       	}
				}
			} 
		}
	}
	collect_errors(\@bad_packets, $error_log) unless $errors;
	return \%Scan;
}
# check_flags will eventually need to include all possible permutations of the six 
# tcp flags so that any signature can be written, but for now this should be most 
# of the important ones.
sub check_flags() {
	my ($sigs_href, $msg, $flags_to_check, $proto) = @_;
	return 0 if ($proto ne "TCP");
	my $msgflags = $sigs_href->{$proto}->{$msg}->{'FLAGS'};
	return 1 if ($msgflags eq "S" && $flags_to_check eq "SYN");		# syn scan
	return 1 if ($msgflags eq "F" && $flags_to_check eq "FIN");		# fin scan
	return 1 if ($msgflags eq "SF" && $flags_to_check eq "SYN FIN"); 	# "syn/fin" scan
	return 1 if ($msgflags eq "UPF" && $flags_to_check eq "URG PSH FIN");	# nmap Xmas scan
	return 1 if ($msgflags eq "NULL" && $flags_to_check eq "NULL");		# nmap NULL scan
	return 1 if ($msgflags eq "UPSF" && $flags_to_check eq "URG PSH SYN FIN");  # nmap fingerprint scan
	return 1 if ($msgflags eq "AP" && $flags_to_check eq "ACK PSH");	# see the signatures for these
	return 1 if ($msgflags eq "AS" && $flags_to_check eq "ACK SYN");
	return 0;
}
sub check_port() {
	my ($sigs_href, $msg, $port_to_check, $portdirection, $proto) = @_;
	print "check_port(): msg: $msg, start: port_to_check: $port_to_check\n" if $DEBUG;
        if (defined $sigs_href->{$proto}->{$msg}->{$portdirection} && $sigs_href->{$proto}->{$msg}->{$portdirection} eq "any") {
        	return 1;
        } elsif (defined $sigs_href->{$proto}->{$msg}->{$portdirection} && $port_to_check == $sigs_href->{$proto}->{$msg}->{$portdirection}) {
        	return 1;
        } elsif (defined $sigs_href->{$proto}->{$msg}->{$portdirection}->{'START'}) {
        	my $start = $sigs_href->{$proto}->{$msg}->{$portdirection}->{'START'};
        	my $end = $sigs_href->{$proto}->{$msg}->{$portdirection}->{'END'};
        	return 1 if ($port_to_check >= $start && $port_to_check <= $end);
        } elsif (defined $sigs_href->{$proto}->{$msg}->{$portdirection}->{'NOT'}) {
        	return 1 if ($port_to_check != $sigs_href->{$proto}->{$msg}->{$portdirection}->{'NOT'});
        } elsif (defined $sigs_href->{$proto}->{$msg}->{$portdirection}->{'NEGSTART'}) {
        	my $start = $sigs_href->{$proto}->{$msg}->{$portdirection}->{'NEGSTART'};
        	my $end = $sigs_href->{$proto}->{$msg}->{$portdirection}->{'NEGEND'};
        	return 1 if ($port_to_check < $start || $port_to_check > $end);
       }
	return 0;
}
sub import_signatures() {
	my $sigfile = shift;
	my ($proto, $srcport, $dstport, $msg, $flags, $dangerlevel);
	my %Sigs;
	my ($start, $end, $tmpport);
	open SIGS, "< $sigfile" or die "Could not open the signatures file $sigfile: $!\n";
	my @sigs = <SIGS>;
	close SIGS;
	foreach my $s (@sigs) {
		chomp $s;
		next if ($s =~ /^#/);
		if ($s =~ /^tcp/) {
			if ($s =~ /^(\w{3,4})\s+(\S+)\s+\-\>\s+(\S+)\s+msg:(\".*?\")\;\s+flags:\s?(\w+)\;.*?dlevel:\s?(\d{1})\;/) {
				($proto, $srcport, $dstport, $msg, $flags, $dangerlevel) = ($1,$2,$3,$4,$5,$6);
				$Sigs{'TCP'}{$msg}{'FLAGS'} = $flags;
				$Sigs{'TCP'}{$msg}{'DANGERLEVEL'} = $dangerlevel;
				if ($srcport =~ /\:/ && $srcport !~ /\!/) {
					($start, $end) = split /:/, $srcport;
					$start = 1 if ($start eq '');
					$end = 65535 if ($end eq '');
					$Sigs{'TCP'}{$msg}{'SRCPORT'}{'START'} = $start;
					$Sigs{'TCP'}{$msg}{'SRCPORT'}{'END'} = $end;
				} elsif ($srcport =~ /\!/ && $srcport !~ /\:/) {
					$tmpport = (split /\!/, $srcport)[1];
					$Sigs{'TCP'}{$msg}{'SRCPORT'}{'NOT'} = $tmpport;
				} elsif ($srcport =~ /\:/ && $srcport =~ /\!/) {
					($start, $end) = split /:/, $srcport;
               	        	        $start = 1 if ($start !~ /\d/);
					$end = 65535 if ($end !~ /\d/);
					$Sigs{'TCP'}{$msg}{'SRCPORT'}{'NEGSTART'} = $start;
       		                       	$Sigs{'TCP'}{$msg}{'SRCPORT'}{'NEGEND'} = $end;
				} else {
					$Sigs{'TCP'}{$msg}{'SRCPORT'} = $srcport;
				}
				if ($dstport =~ /\:/ && $dstport !~ /\!/) {
       	                       		($start, $end) = split /:/, $dstport;
        	                       	$start = 1 if ($start eq '');
        		                $end = 65535 if ($end eq '');
       	                	        $Sigs{'TCP'}{$msg}{'DSTPORT'}{'START'} = $start;
               	       	        	$Sigs{'TCP'}{$msg}{'DSTPORT'}{'END'} = $end;
                        	} elsif ($dstport =~ /\!/ && $dstport !~ /\:/) {
       	                       		$tmpport = (split /\!/, $dstport)[1];
               	               		$Sigs{'TCP'}{$msg}{'DSTPORT'}{'NOT'} = $tmpport;
	        	        } elsif ($dstport =~ /\:/ && $dstport =~ /\!/) {
       		        	        ($start, $end) = split /:/, $dstport;
               	                	$start = 1 if ($start !~ /\d/);
                        	        $end = 65535 if ($end !~ /\d/);
       	                       		$Sigs{'TCP'}{$msg}{'DSTPORT'}{'NEGSTART'} = $start;
               	               		$Sigs{'TCP'}{$msg}{'DSTPORT'}{'NEGEND'} = $end;
				} else {
                              			$Sigs{'TCP'}{$msg}{'DSTPORT'} = $dstport;
                       		}
			}
		} elsif ($s =~ /^udp/) {
			# udp any -> 31337 msg:"Back Orifice";
			if ($s =~ /^(\w{3,4})\s+(\S+)\s+\-\>\s+(\S+)\s+msg:(\".*?\")\;.*?dlevel:\s?(\d{1})\;/) {
				($proto, $srcport, $dstport, $msg, $dangerlevel) = ($1,$2,$3,$4,$5);	
				$Sigs{'UDP'}{$msg}{'DANGERLEVEL'} = $dangerlevel;
                                if ($srcport =~ /\:/ && $srcport !~ /\!/) {
                                        ($start, $end) = split /:/, $srcport;
                                        $start = 1 if ($start eq '');
                                        $end = 65535 if ($end eq '');
                                        $Sigs{'UDP'}{$msg}{'SRCPORT'}{'START'} = $start;
                                        $Sigs{'UDP'}{$msg}{'SRCPORT'}{'END'} = $end;
                                } elsif ($srcport =~ /\!/ && $srcport !~ /\:/) {
                                        $tmpport = (split /\!/, $srcport)[1];
                                        $Sigs{'UDP'}{$msg}{'SRCPORT'}{'NOT'} = $tmpport;
                                } elsif ($srcport =~ /\:/ && $srcport =~ /\!/) {
                                        ($start, $end) = split /:/, $srcport;
                                        $start = 1 if ($start !~ /\d/);
                                        $end = 65535 if ($end !~ /\d/);
                                        $Sigs{'UDP'}{$msg}{'SRCPORT'}{'NEGSTART'} = $start;
                                        $Sigs{'UDP'}{$msg}{'SRCPORT'}{'NEGEND'} = $end;
                                } else {
                                        $Sigs{'UDP'}{$msg}{'SRCPORT'} = $srcport;
                                }
                                if ($dstport =~ /\:/ && $dstport !~ /\!/) {
                                        ($start, $end) = split /:/, $dstport;
                                        $start = 1 if ($start eq '');
                                        $end = 65535 if ($end eq '');
                                        $Sigs{'UDP'}{$msg}{'DSTPORT'}{'START'} = $start;
                                        $Sigs{'UDP'}{$msg}{'DSTPORT'}{'END'} = $end;
                                } elsif ($dstport =~ /\!/ && $dstport !~ /\:/) {
                                        $tmpport = (split /\!/, $dstport)[1];
                                        $Sigs{'UDP'}{$msg}{'DSTPORT'}{'NOT'} = $tmpport;
                                } elsif ($dstport =~ /\:/ && $dstport =~ /\!/) {
                                        ($start, $end) = split /:/, $dstport;
                                        $start = 1 if ($start !~ /\d/);
                                        $end = 65535 if ($end !~ /\d/);
                                        $Sigs{'UDP'}{$msg}{'DSTPORT'}{'NEGSTART'} = $start;
                                        $Sigs{'UDP'}{$msg}{'DSTPORT'}{'NEGEND'} = $end;
                                } else {
                                        $Sigs{'UDP'}{$msg}{'DSTPORT'} = $dstport;
                                }
                        }
		}
	}
	print STDOUT Dumper %Sigs if $DEBUG;
	return \%Sigs;	
}
sub import_auto_ips() {
	my $auto_ips_file = shift;
	my %Auto_ips;
	open AUTO, "< $auto_ips_file";
	my @lines = <AUTO>;
	close AUTO;
	foreach my $l (@lines) {
		next if ($l =~ /^#/);
		if ($l =~ /^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+([0-5]|\-1)/) {
			$Auto_ips{$1} = $2;
		}
	}
	return \%Auto_ips;
}
sub reset_auto_tags() {
	my $Scan_href = shift;
	foreach my $srcip (keys %$Scan_href) {
		foreach my $dstip (keys %{$Scan_href->{$srcip}}) {
			$Scan_href->{$srcip}->{$dstip}->{'AUTO'} = "N";
		}
	}
	return $Scan_href;
}
sub check_range() {
	my ($port, $start, $end) = @_;
	$start = $port if ($port < $start);
	$end = $port if ($port > $end);
	return $start, $end;
}
sub assign_danger_level() {
	my ($Scan_href, $Auto_ips_href, $port_range_scan_threshold, $alert_all, $danger_levels_href) = @_;
	$Scan_href = automatic_ip_danger_assignment($Scan_href, $Auto_ips_href) if ($Auto_ips_href); 
	foreach my $srcip (keys %$Scan_href) {
		print "assign_danger_level(): source ip: $srcip\n" if $DEBUG;
		foreach my $dstip (keys %{$Scan_href->{$srcip}}) {
			my $absnum = $Scan_href->{$srcip}->{$dstip}->{'ABSNUM'};
			my $range = $Scan_href->{$srcip}->{$dstip}->{'END_PORT'} - $Scan_href->{$srcip}->{$dstip}->{'START_PORT'};
			if ($DEBUG) {
				print "assign_danger_level(): destination ip: $dstip\n";
				print "assign_danger_level(): ABSNUM: $Scan_href->{$srcip}->{$dstip}->{'ABSNUM'}\n";
				print "assign_danger_level(): START_PORT: $Scan_href->{$srcip}->{$dstip}->{'START_PORT'}, END_PORT: $Scan_href->{$srcip}->{$dstip}->{'END_PORT'}\n";
				print "assign_danger_level(): CURRENT_DANGER_LEVEL (before assignment) = $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'}\n";
			}
			# If a scan signature packet has been detected but no other packets are detected, assign a danger
			# level of 1.  (This should really look at the danger level field for each signature to assign a real
			# danger level that is based on the type of signature... see the TODO)
			my $sigmatch = 0;
			my $sigproto = "";
			if (defined $Scan_href->{$srcip}->{$dstip}->{'TCP'}->{'SIGMATCH'}) {
				$sigmatch = 1;
				$sigproto = "TCP";
				print "assign_danger_level(): sigmatch = $sigmatch (definitely 1 here)\n" if $DEBUG;
			}
                        if (defined $Scan_href->{$srcip}->{$dstip}->{'UDP'}->{'SIGMATCH'}) {
                                $sigmatch = 1;
				$sigproto = "UDP";
                                print "assign_danger_level(): sigmatch = $sigmatch (definitely 1 here)\n" if $DEBUG;
                        }
			if ($sigmatch && $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} < $Scan_href->{$srcip}->{$dstip}->{$sigproto}->{'SIGMATCH'}->{'SIGDL'}) {
#				$Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} = 1;
				$Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} = $Scan_href->{$srcip}->{$dstip}->{$sigproto}->{'SIGMATCH'}->{'SIGDL'};
				print "assign_danger_level(): danger level: $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'}\n" if $DEBUG;
			}
			# if $port_range_scan_threshold is >= 1, then psad will not assign a danger level to repeated packets to the same tcp port
			if ($absnum >= $danger_levels_href->{'1'} && $absnum < $danger_levels_href->{'2'} && $range >= $port_range_scan_threshold) {
				if ($Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} < 1 && $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} != -1) {
					$Scan_href->{$srcip}->{$dstip}->{'ALERTED'} = "N";
					$Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} = 1;
				}
			}
			if ($absnum >= $danger_levels_href->{'2'} && $absnum < $danger_levels_href->{'3'} && $range >= $port_range_scan_threshold) {
				if ($Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} < 2 && $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} != -1) {
					$Scan_href->{$srcip}->{$dstip}->{'ALERTED'} = "N";
					$Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} = 2;
				}
			}
			if ($absnum >= $danger_levels_href->{'3'} && $absnum < $danger_levels_href->{'4'} && $range >= $port_range_scan_threshold) {
				if ($Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} < 3 && $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} != -1) {
					$Scan_href->{$srcip}->{$dstip}->{'ALERTED'} = "N";
					$Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} = 3;
				}
			}
			if ($absnum >= $danger_levels_href->{'4'} && $absnum < $danger_levels_href->{'5'} && $range >= $port_range_scan_threshold) {
				if ($Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} < 4 && $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} != -1) {
					$Scan_href->{$srcip}->{$dstip}->{'ALERTED'} = "N";
					$Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} = 4;
				}
			}
			if ($absnum >= $danger_levels_href->{'5'} && $range >= $port_range_scan_threshold) {
				if ($Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} < 5 && $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} != -1) {
					$Scan_href->{$srcip}->{$dstip}->{'ALERTED'} = "N";
					$Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} = 5;
				}
			}
			# we will always send an alert email for any new "bad" packet if $alert_all eq "Y".  Else email sent only if the scan increments its D.L.
			if ($alert_all eq "Y") {  
				$Scan_href->{$srcip}->{$dstip}->{'ALERTED'} = "N";
			}
			print "assign_danger_level(): CURRENT_DANGER_LEVEL (after assignment) = $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'}\n" if $DEBUG;
		}
	}
	return $Scan_href;
}
sub automatic_ip_danger_assignment() {
	my ($Scan_href, $Auto_ips_href) = @_;
	foreach my $scan_ip (keys %$Scan_href) {
		foreach my $dstip (keys %{$Scan_href->{$scan_ip}}) {
			foreach my $auto_ip (keys %$Auto_ips_href) {
				if ($scan_ip eq $auto_ip && $Scan_href->{$scan_ip}->{$dstip}->{'AUTO'} eq "N") {
					$Scan_href->{$scan_ip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} = $Auto_ips_href->{$auto_ip};
					$Scan_href->{$scan_ip}->{$dstip}->{'ALERTED'} = "N";
					$Scan_href->{$scan_ip}->{$dstip}->{'AUTO'} = "Y";
				}
			}
		}
	}
	return $Scan_href;
}
sub collect_errors() {
	my ($bad_packets_aref, $error_log) = @_;
	open ERRORS, ">> $error_log";
	foreach my $l (@$bad_packets_aref) {
		print ERRORS "$l\n";
	}
	close ERRORS;
}
sub scan_logr() {
	my ($Scan_href, $logfile, $output, $dnslookups, $whoislookups, $whois_timeout, $enable_email_alerts, $email_alert_danger_level,
					$email_alertfile, $email_addresses_aref, $show_all_signatures, $Cmds_href) = @_;
	my $flags_mesg;
	my $hndl;
	my $range;
	my ($tcp_newrange, $udp_newrange, $tcp_new_start_range, $tcp_new_end_range, $udp_new_start_range, $udp_new_end_range);
	my ($tcp_new_start_time, $udp_new_start_time);
	my $dnsstring = "";
	my $whois_info_aref;
       	if ($output || $DEBUG) {
                $hndl = "STDOUT";
       	} else {
		$hndl = "LOG"; 
		open $hndl, ">> $logfile";
       	}
	foreach my $srcip (keys %$Scan_href) {
		print "scan_logr(): source ip: $srcip\n" if $DEBUG;
		foreach my $dstip (keys %{$Scan_href->{$srcip}}) {
			print "scan_logr(): dst ip: $dstip\n" if $DEBUG;
			my ($tcp, $udp) = (0,0);
			my $current_danger_level = $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'};
			if ($current_danger_level >= 1 && $Scan_href->{$srcip}->{$dstip}->{'LOGR'} eq "Y") {
				my $abs_start_range = $Scan_href->{$srcip}->{$dstip}->{'START_PORT'};
				my $abs_end_range = $Scan_href->{$srcip}->{$dstip}->{'END_PORT'};

				if (defined $Scan_href->{$srcip}->{$dstip}->{'TCP'}->{'CURRENT_INTERVAL'}) {
					$tcp = 1;
				 	$tcp_new_start_range = $Scan_href->{$srcip}->{$dstip}->{'TCP'}->{'CURRENT_INTERVAL'}->{'START_PORT'};
				 	$tcp_new_end_range = $Scan_href->{$srcip}->{$dstip}->{'TCP'}->{'CURRENT_INTERVAL'}->{'END_PORT'};
				 	$tcp_new_start_time = $Scan_href->{$srcip}->{$dstip}->{'TCP'}->{'CURRENT_INTERVAL'}->{'START_TIME'};
				}
                                if (defined $Scan_href->{$srcip}->{$dstip}->{'UDP'}->{'CURRENT_INTERVAL'}) {
					$udp = 1;
                                        $udp_new_start_range = $Scan_href->{$srcip}->{$dstip}->{'UDP'}->{'CURRENT_INTERVAL'}->{'START_PORT'};
                                        $udp_new_end_range = $Scan_href->{$srcip}->{$dstip}->{'UDP'}->{'CURRENT_INTERVAL'}->{'END_PORT'};
                                        $udp_new_start_time = $Scan_href->{$srcip}->{$dstip}->{'UDP'}->{'CURRENT_INTERVAL'}->{'START_TIME'};
                                }

				my $start_time = $Scan_href->{$srcip}->{$dstip}->{'START_TIME'}->{'READABLE'};
				my $end_time = $Scan_href->{$srcip}->{$dstip}->{'END_TIME'};
                        	my @time = split / /, scalar localtime;   ### Get the current time as a nice ASCII string.
                        	pop @time; shift @time;    ### Get rid of the day and the year to make the time consistent with syslog
                        	my $time = join ' ', @time;
                        	unless ($dnslookups) {
                                	my $ipaddr = gethostbyname($srcip);
                                	my $rdns = gethostbyaddr($ipaddr, AF_INET);
                                	$rdns = "No reverse dns info available" unless $rdns;
                                	$dnsstring = "$srcip -> $rdns";
                        	} 
				unless ($whoislookups) {
					$whois_info_aref = get_whois_data($whois_timeout, $srcip, $Cmds_href);
				}
				if ($abs_start_range == $abs_end_range) {
					$range = $abs_start_range;
				} else {
					$range = "$abs_start_range-$abs_end_range";
				}
				if ($tcp) {
					if ($tcp_new_start_range == $tcp_new_end_range) {
                                		$tcp_newrange = $tcp_new_start_range;
                        		} else {
                                		$tcp_newrange = "$tcp_new_start_range-$tcp_new_end_range";
                        		}
					undef $Scan_href->{$srcip}->{$dstip}->{'TCP'}->{'CURRENT_INTERVAL'};
				}
				if ($udp) {
                                	if ($udp_new_start_range == $udp_new_end_range) {
                                        	$udp_newrange = $udp_new_start_range;
                                	} else {
                                        	$udp_newrange = "$udp_new_start_range-$udp_new_end_range";
                                	}
					undef $Scan_href->{$srcip}->{$dstip}->{'UDP'}->{'CURRENT_INTERVAL'};
				}
#				undef $Scan_href->{$srcip}->{$dstip}->{'CURRENT_INTERVAL'};  # get rid of the current range to make room for a new one.
				print STDOUT "scan_logr():  gernerating email......\n" if $DEBUG;
		        	open EMAILALERT, "> $email_alertfile";
				&markerline($hndl);
				### could use logr() here, but perhaps the subroutine call is slower?
				print $hndl "$time:     Portscan Detected by psad (pid $$) on $HOSTNAME.\n";
				print $hndl "\n";
				print $hndl "Source:                     $srcip\n";
				print $hndl "Destination:                $dstip\n";
				print $hndl "Newly scanned TCP ports:    [$tcp_newrange]  (since: $tcp_new_start_time)\n" if ($tcp);
				print $hndl "Newly scanned UDP ports:    [$udp_newrange]  (since: $udp_new_start_time)\n" if ($udp);
				print $hndl "Complete port range:        [$range]  (since: $start_time) TCP and/or UDP\n";
				print $hndl "Total number of packets:    $Scan_href->{$srcip}->{$dstip}->{'ABSNUM'}\n";
				print $hndl "Start time:                 $start_time\n";
				print $hndl "End time:                   $end_time\n";
				print $hndl "Danger level:               $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} out of 5\n";
				print $hndl "DNS info:                   $dnsstring\n" unless $dnslookups;
				&markerline("EMAILALERT");
                               	print EMAILALERT "$time:     Portscan Detected by psad (pid $$) on $HOSTNAME.\n";
				print EMAILALERT "\n";
                               	print EMAILALERT "Source:                     $srcip\n";
                               	print EMAILALERT "Destination:                $dstip\n";
                                print EMAILALERT "Newly scanned TCP ports:    [$tcp_newrange]  (since: $tcp_new_start_time)\n" if ($tcp);
                                print EMAILALERT "Newly scanned UDP ports:    [$udp_newrange]  (since: $udp_new_start_time)\n" if ($udp);
                               	print EMAILALERT "Complete port range:        [$range]  (since: $start_time) TCP and/or UDP\n";
                               	print EMAILALERT "Total number of packets:    $Scan_href->{$srcip}->{$dstip}->{'ABSNUM'}\n";
                               	print EMAILALERT "Start time:                 $start_time\n";
                               	print EMAILALERT "End time:                   $end_time\n";
                               	print EMAILALERT "Danger level:               $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} out of 5\n";
                               	print EMAILALERT "DNS info:                   $dnsstring\n" unless $dnslookups;

				### write a syslog message
#				openlog("psad", "ndelay", "daemon");
#				my $syslog_print_range = "";
#				if ($tcp) {
#					$syslog_print_range .= "TCP ports: [$tcp_newrange] ";
#				}
#				if ($udp) {
#					$syslog_print_range .= "UCP ports: [$udp_newrange] ";
#				}
#				my $syslog_num_pkts = $Scan_href->{$srcip}->{$dstip}->{'ABSNUM'};
#				my $syslog_danger_level = $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'};
#
#				syslog("warning", "Port scan detected: src: $srcip, dst: $dstip, $syslog_print_range, pkts: $syslog_num_pkts, dangerlevel: $syslog_danger_level");
#				closelog();
				if ($DEBUG) {
					print STDOUT "scan_logr(): printing email..................\n";
					print STDOUT "     $time: Portscan Detected by psad (pid $$) on $HOSTNAME.\n";
                                       	print STDOUT "     Source:                   $srcip\n";
                                       	print STDOUT "     Destination:              $dstip\n";
					print STDOUT "     Newly scanned TCP ports:  [$tcp_newrange]  (since: $tcp_new_start_time)\n" if ($tcp);
					print STDOUT "     Newly scanned UDP ports:  [$udp_newrange]  (since: $udp_new_start_time)\n" if ($udp);
                                       	print STDOUT "     Complete port range:      [$range]  (since: $start_time) TCP and/or UDP\n";
                                       	print STDOUT "     Total number of packets:  $Scan_href->{$srcip}->{$dstip}->{'ABSNUM'}\n";
                                       	print STDOUT "     Start time:               $start_time\n";
                                       	print STDOUT "     End time:                 $end_time\n";
                                       	print STDOUT "     Danger level:             $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'} out of 5\n";
                                       	print STDOUT "     DNS info:                 $dnsstring\n" unless $dnslookups;
				}
				if ($USE_IPTABLES) {
					my $i = 0;
					SIGS: foreach my $p ($tcp, $udp) {
						my $proto;
						next SIGS unless $p;
						if ($p && $i == 0) {
							$proto = "TCP";
						} elsif ($p && $i == 1) {
							$proto = "UDP";
						}
						if ($proto eq "TCP") {  # print tcp flags
							foreach my $flags (keys %{$Scan_href->{$srcip}->{$dstip}->{'TCP'}->{'FLAGS'}}) {
								my $nmapOpts = 0;
								$nmapOpts = "-sT or -sS" if ($flags eq "SYN");
								$nmapOpts = "-sF" if ($flags eq "FIN");
								$nmapOpts = "-sX" if ($flags eq "URG PSH FIN"); 
								$nmapOpts = "-O" if ($flags eq "URG PSH SYN FIN");
								if ($nmapOpts) {
									$flags_mesg = "TCP flags:                  [$flags: $Scan_href->{$srcip}->{$dstip}->{'TCP'}->{'FLAGS'}->{$flags} packets]  Nmap: [$nmapOpts]";
									print $hndl "$flags_mesg\n";
									print EMAILALERT "$flags_mesg\n";
								} else {
									$flags_mesg = "TCP flags:                  [$flags: $Scan_href->{$srcip}->{$dstip}->{'TCP'}->{'FLAGS'}->{$flags} packets]";
									print $hndl "$flags_mesg\n";
									print EMAILALERT "$flags_mesg\n";
								}
							}
						}
						if (defined $Scan_href->{$srcip}->{$dstip}->{$proto}->{'CURRENT_SIGMATCH_START_TIME'}) {
							print $hndl "\n";
							print EMAILALERT "\n";
							print $hndl "=-=-= $proto alert signatures found since [$Scan_href->{$srcip}->{$dstip}->{$proto}->{'CURRENT_SIGMATCH_START_TIME'}]\n";
							print EMAILALERT "=-=-= $proto alert signatures found since [$Scan_href->{$srcip}->{$dstip}->{$proto}->{'CURRENT_SIGMATCH_START_TIME'}]\n";
							foreach my $sigmatch (keys %{$Scan_href->{$srcip}->{$dstip}->{$proto}->{'CURRENT_SIGMATCH'}}) {
                                        	        	print $hndl "$sigmatch  Packets=$Scan_href->{$srcip}->{$dstip}->{$proto}->{'CURRENT_SIGMATCH'}->{$sigmatch}\n";
                                                		print EMAILALERT "$sigmatch  Packets=$Scan_href->{$srcip}->{$dstip}->{$proto}->{'CURRENT_SIGMATCH'}->{$sigmatch}\n";
	                                        	}
							undef $Scan_href->{$srcip}->{$dstip}->{$proto}->{'CURRENT_SIGMATCH_START_TIME'};
							undef $Scan_href->{$srcip}->{$dstip}->{$proto}->{'CURRENT_SIGMATCH'};
						}
						if (defined $Scan_href->{$srcip}->{$dstip}->{$proto}->{'SIGMATCH'} && $show_all_signatures eq "Y") {
							print $hndl "\n";
                                        		print EMAILALERT "\n";
							print $hndl "=-=-= ALL $proto alert signatures found since [$start_time]\n";
        	                                	print EMAILALERT "=-=-= ALL $proto alert signatures found since [$start_time]\n";
							foreach my $sigmatch (keys %{$Scan_href->{$srcip}->{$dstip}->{$proto}->{'SIGMATCH'}}) {
								print $hndl "$sigmatch  Packets=$Scan_href->{$srcip}->{$dstip}->{$proto}->{'SIGMATCH'}->{$sigmatch}\n";
								print EMAILALERT "$sigmatch  Packets=$Scan_href->{$srcip}->{$dstip}->{$proto}->{'SIGMATCH'}->{$sigmatch}\n";
							}
						}
						$i++;
					}
				} else {
					$flags_mesg = 0;
				}
                                unless ($whoislookups) {
                                        print $hndl "\n\n";
                                        print $hndl "   =-=-=-=-=-=-= Whois Information: =-=-=-=-=-=-=\n";
                                        print EMAILALERT "\n\n";
                                        print EMAILALERT "   =-=-=-=-=-=-= Whois Information =-=-=-=-=-=-=\n";
                                        print $hndl $_ foreach (@$whois_info_aref);
                                        print EMAILALERT $_ foreach (@$whois_info_aref);
                                        print $hndl "\n";
                                        print EMAILALERT "\n";
                                }
                                if ($USE_IPCHAINS) {
					&markerline($hndl);
					&markerline("EMAILALERT");
                                }
				&markerline("EMAILALERT");
                                close EMAILALERT;
                                if ($Scan_href->{$srcip}->{$dstip}->{'ALERTED'} eq "N" && $current_danger_level >= $EMAIL_ALERT_DANGER_LEVEL) {
                                        $Scan_href = send_email_alert($Scan_href, $srcip, $dstip, $flags_mesg, $email_alertfile, $email_addresses_aref, $Cmds_href);
                                }
                                $Scan_href->{$srcip}->{$dstip}->{'LOGR'} = "N";
				&markerline($hndl);
			}
		}
	}
	close $hndl unless ($output || $DEBUG);
	return $Scan_href;
}
sub auto_psad_response(){
        my ($Scan_href, $auto_psad_level, $Cmds_href, $email_addresses_aref) = @_;
	SOURCEIP: foreach my $srcip (keys %$Scan_href) {
		foreach my $dstip (keys %{$Scan_href->{$srcip}}) {
			my $current_danger_level = $Scan_href->{$srcip}->{$dstip}->{'CURRENT_DANGER_LEVEL'};
			### We only want to block the IP once.  Currently this will block all traffic from the host to _all_ destinations
			### that are protected by the firewall if the ip trips the $auto_psad_level threshold for _any_ destination. 
        		if ($current_danger_level >= $auto_psad_level && !(defined $Scan_href->{$srcip}->{$dstip}->{'BLOCKED'})) {
                		if ($USE_IPCHAINS) {
                        		my @chains = get_input_chains($Cmds_href->{'ipchains'});
                        		foreach my $inchain (@chains) {
                                		`$Cmds_href->{'ipchains'} -I $inchain 1 -s $srcip -l -j DENY`;
                        		}
					foreach my $dst (keys %{$Scan_href->{$srcip}}) {
						$Scan_href->{$srcip}->{$dst}->{'BLOCKED'} = "Y";
					}
                			foreach my $email_address (@$email_addresses_aref) {
                        			system "$Cmds_href->{'mail'} $email_address -s \"psad: All traffic from $srcip has been BLOCKED on $HOSTNAME\" < /dev/null";
                			}
					next SOURCEIP; 
                		} elsif ($USE_IPTABLES) {
                        		my @chains = get_input_chains($Cmds_href->{'iptables'});
                        		foreach my $inchain (@chains) {
                                		`$Cmds_href->{'iptables'} -I $inchain 1 -s $srcip -j DROP`;
                        		}
					foreach my $dst (keys %{$Scan_href->{$srcip}}) {
                                                $Scan_href->{$srcip}->{$dst}->{'BLOCKED'} = "Y";
                                        }
                                        foreach my $email_address (@$email_addresses_aref) {
                                                system "$Cmds_href->{'mail'} $email_address -s \"psad: All traffic from $srcip has been BLOCKED on $HOSTNAME\" < /dev/null";
                                        }
                                        next SOURCEIP;
                		}
			}
		}
        }
	return $Scan_href;
}
sub get_input_chains() {
	my $fwCmd = shift;
        my @rules;
        my @chains;
        @rules = `$fwCmd -L`;
        foreach my $r (@rules) {
                next unless ($r =~ /Chain/);
                my ($cname) = ($r =~ /Chain\s(\w+)/);
                next unless ($cname =~ /in/i);  # we don't have an input chain
                push @chains, $cname;
        }
        return @chains;
}
sub send_email_alert() {
        my ($Scan_href, $srcip, $dstip, $flags_mesg, $email_alertfile, $email_addresses_aref, $Cmds_href) = @_;
	foreach my $email_address (@$email_addresses_aref) {
		print "send_email_alert(): sending scan alert email to: $email_address\n" if $DEBUG;
		system("$Cmds_href->{'mail'} $email_address -s \"psad WARNING: $HOSTNAME has been scanned!\" < $email_alertfile");
	}
	$Scan_href->{$srcip}->{$dstip}->{'ALERTED'} = "Y";
	return $Scan_href;
}
sub print_scan() {  # this should primarily be used for debugging
	my $scanfile = $PRINT_SCAN_HASH . ".$$";
	open PSCAN, "> $scanfile";
	print PSCAN Dumper $Scan_href;
	close PSCAN;
	chmod 0600, $scanfile;
	return;
}
sub check_fw() {
	my $line = shift;
	if ($line !~ /MAC/) {  # ipchains log messages do not have a MAC address field
		$USE_IPCHAINS = 1;
	} else {
		$USE_IPTABLES = 1;
	}
}
sub get_local_ips() {
	my $Cmds_href = shift;
        my %localips;
        my @ips = `$Cmds_href->{'ifconfig'} -a |$Cmds_href->{'grep'} inet`;
	for my $iptmp (@ips) {
		my $ip = (split /:/, (split /\s+/, $iptmp)[2])[1];
		$localips{$ip} = "";
	}
	return \%localips;
}
sub get_listening_ports() {
	my $Cmds_href = shift;
	my %listening_ports;
	my @ports = `$Cmds_href->{'netstat'} -an |$Cmds_href->{'grep'} \"LISTEN\\b\"`;
	for my $port_tmp (@ports) {
		my ($proto, $p_tmp) = (split /\s+/, $port_tmp)[0,3];
		my $port = (split /:/, $p_tmp)[1];
		my $key = $proto . $port;
		$listening_ports{$key} = "";
	}
	return \%listening_ports;
}
sub get_whois_data() {
	my ($whois_timeout, $ip, $Cmds_href) = @_;
	my @whois_data;
	eval {
		local $SIG{'ALRM'} = sub {die "alarm\n"};
		alarm $whois_timeout;
		@whois_data = `$Cmds_href->{'whois'} $ip`;
		alarm 0;
	};
	if ($@) {
		die unless $@ eq "alarm\n";
		$#whois_data = 0;
		@whois_data = ("Whois data not available!\n");
		return \@whois_data;
	} else {
		return \@whois_data;
	}
}
sub check_permissions() {
	my @files = @_;
	for my $f (@files) {
		if (-e $f) {
			chmod 0600, $f;
		} else {
			open T, "> $f";
			close T;
			chmod 0600, $f;
		}
	}
	return;
}
sub kill_psad() {
	my $pidfiles_aref = shift;

	### must kill psadwatchd first since if not, it might try to restart any of the other three daemons; 
	### (it's the first element of $pidfiles_aref)
	for my $pidfile (@$pidfiles_aref) {
		# my $pidname = (split /\./, $pidfile)[1];
		my $pidname = (split /\./, (split /\//, $pidfile)[$#_])[0];
		if (-e $pidfile) {
			open PIDFILE, "< $pidfile";
			my $pid = <PIDFILE>;
			close PIDFILE;
			chomp $pid;
			if (kill 0, $pid) {
				print " ----  Killing $pidname, pid: $pid  ----\n";
				kill 15, $pid or print "@@@@@  psad: Could not kill $pidname, pid: $pid\n";
			} else {
				print "@@@@@  psad: $pidname is not running on $HOSTNAME.\n";
			}
		} else {
			print "@@@@@  psad: pid file $pidfile does not exist for $pidname on $HOSTNAME\n";
		}
	}
	return;
}
sub restart_psad() {
	my ($pidfiles_aref, $cmdline_file, $Cmds_href) = @_;
        my $cmdline;
        if (-e $cmdline_file) {
                open CMD, "< $cmdline_file";
                $cmdline = <CMD>;
                close CMD;
                chomp $cmdline;
        } else {
                die "@@@@@  psad:  No other psad process is currently running on $HOSTNAME!\n";
        }
        &kill_psad($pidfiles_aref);
        print " ----  Restarting the psad daemons on $HOSTNAME.  ----\n";
        system "$Cmds_href->{'psad'} $cmdline";
	return;
}
sub psad_status() {
	my $pidfiles_aref = shift;
	my $rv = 0;   ### assume psad is not running and test...
	for my $pidfile (@$pidfiles_aref) {
		my $pidname = (split /\./, (split /\//, $pidfile)[$#_])[0];
		if (-e $pidfile) {
			open PIDFILE, "< $pidfile";
			my $pid = <PIDFILE>;
			close PIDFILE;
			chomp $pid;
			if (kill 0, $pid) {
				print " ----  $pidname is running on $HOSTNAME as pid: $pid\n";
				$rv = 1;
			} else {
				print " ----  $pidname is not currently running on $HOSTNAME  ----\n";
			}
		} else {
			print "@@@@@  psad: pid file $pidfile does not exist for $pidname on $HOSTNAME\n";
		}
	}
	return $rv;
}
sub markerline() {
        my $hndl = shift;
	print $hndl "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n";
        return;
}
sub usage_and_exit() {
        my $exitcode = shift;
        print <<_HELP_;

psad; the Port Scan Attack Detector
Version: $VERSION
By Michael B. Rash (mbr\@cipherdyne.com, http://www.cipherdyne.com)

USAGE: psad [-D] [-d] [-o] [-e] [-L] [-f] [-r] [-w] [-l] [-i <interval>] [-h]
       [-V] [-K] [-R] [-S] [-c <config file>] [-s <signature file>] 
       [-a <auto ips file>]

OPTIONS:
        -D   --Daemon                   - do not run as a daemon.
        -e   --errors                   - do not write errors to the error
                                          log.
        -d   --debug                    - run psad in debugging mode.
        -w   --whois                    - disable whois lookups.
        -i   --interval                 - configure the check interval from
                                          the command line to override the 15
                                          second default.
        -f   --firewallcheck            - disable firewall rules verification.
        -o   --output                   - print all messages to STDOUT (this
                                          does not include bad packet messages
                                          that are printed to the error log).
        -c   --config <config file>     - use config file instead of the
                                          values contained within the psad
                                          script.
	-L   --Logging_server		- psad is being run on a syslog
					  logging server.
        -r   --reversedns               - disable name resolution against
                                          scanning ips.
        -s   --signatures <sig file>    - import scan signatures.
        -a   --auto_ips <ips file>      - import auto ips file for automatic
                                          ip danger level increases/decreses.
        -l   --local_port_lookup        - disable local port lookups for scan
                                          signatures.
	-K   --Kill			- kill all running psad processes.
	-R   --Restart			- restart all running psad processes.
	-S   --Status			- displays the status of any
					  currently running psad processes.
	-V   --Version			- print the psad version and exit.
        -h   --help                     - prints this help message.

_HELP_
        exit $exitcode;
}
